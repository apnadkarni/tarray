text {
    ((= chap_xtal_lang "The Xtal Language"))
    include::header.ad[]

    ((author "Ashok P. Nadkarni"))
}

outputlimit-default 10

text {
    == Introduction

    [TIP]
    This document assumes the reader is familiar with typed arrays.
    If not, please glance through the ((^ chap_guide)) before continuing.

    The (e**X**tended **t**yped **a**rray **l**anguage) *Xtal*
    (pronounced __Crystal__footnote:[Xtal is an abbreviation for crystal in the electronics world.])
    is an alternative to Tcl commands for 
    working with collections (lists, typed array columns and tables).
    It provides convenient and succint syntax for 
    
    * vector operations
    * searching and sorting
    * flexible indexing

    Although geared towards operations on typed arrays, Xtal can be used as
    a general purpose language in its own right.
    Note however, that Xtal is not a replacement for Tcl.
    Rather, it is embedded in
    Tcl and the two can be intermixed according to whatever syntax suits
    the task at hand.

}

eval {
    package require xtal
    namespace path [list xtal tarray];      # Allows use of xtal commands without qualification
}

text {
    ((== sect_xtal_quick_tour "Quick Tour"))

    This section provides a short tour of Xtal to
    introduce the reader to the language. 
}

text {
    Because the primary purpose of Xtal is to work conveniently with
    typed arrays - columns and tables - we illustrate its use in that
    context first.

    .Working with columns

    For purposes of demonstration,
    let us start off by creating two columns containing the months in a year
    and rainfall received in a particular year.
} xtal {
    Months = @string {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"}
    Rainfall = @double {
        11.0, 23.3, 18.4, 14.7, 70.3, 180.5, 210.2, 205.8, 126.4, 64.9, 33.1, 19.2
    }
} text {
    Elements in the column are retrieved using indexing.
} prompt {} xtal_shell {
    Rainfall[0]          # Rainfall in January
    
    Rainfall[11] = 21.5  # Update the measured amount for December
} text {
    Instead of a simple integer index, we may specify a range instead in
    which case a column of the same type containing the elements in the
    specified range is returned.
} prompt {} xtal_shell {
    print(Rainfall[9:11])        # Rainfall in the last quarter

    print(@sum(Rainfall[9:11]))  # Total rainfall in last quarter
} text {
    Or we could specify a list of indices of interest.
} prompt {} xtal_shell {
    print(Rainfall[{0, 3, 6, 9}])  # Rainfall in first month of every quarter
} text {
    When the indexing operation itself returns a column,
    the vector and folding operations available for columns can be 
    used in conjunction.
} prompt {} xtal_shell {
    print( Rainfall / 10 )      # Print rainfall in centimeters

    @sum(Rainfall[9:11])        # Total rainfall in the last quarter
}

text {
    Yet another form that indexing can take is a boolean expression.
    For example, we can list the rainfall values that lie within
    a specific range.
} prompt {} xtal_shell {
    print ( Rainfall [Rainfall > 100 && Rainfall < 200] ) 

    print ( Rainfall [@@ > 100 && @@ < 200] )  # @@ is the "current" context
} text {
    Or perhaps more usefully, list the corresponding months.
} prompt {} xtal_shell {
    print ( Months [Rainfall > 100 && Rainfall < 200] ) 
}

text {
    This form of indexing works because simple boolean expressions
    involving columns return an integer column containing the indices
    for elements which satisfy the expression. Thus, we have
} xtal {
    print(Rainfall > 100 && Rainfall < 200)
} text {
    This feature can be used in other contexts as well. So for example,
    we can use the `%` size operator to count the
    number of such months.
} prompt {} xtal_shell {
    %(Rainfall > 100 && Rainfall < 200) 
}

text {
    .Working with tables

    Having looked at basic column operations, we turn our attention
    to tables.
    As for columns, we will use a small sample table
    containing a simple employee data base for demonstration purposes:
} xtal {
    Emps = @table (
        Name string,   Salary uint,   Age uint,   Location string
    ) {
        {'Sally',      70000,      32,       'Boston'},
        {'Tom',        65000,      36,       'Boston'},
        {'Dick',       80000,      40,       'New York'},
        {'Harry',      45000,      37,       'New York'},
        {'Amanda',     48000,      35,       'Seattle'}
    }
    print(Emps)
} text {
    Tables rows can be accessed in the same manner as column elements.
} prompt {} xtal_shell {
    % Emps      # Number of employees

    print(Emps[3])     # Row 3

    print(Emps[2:4])   # Rows 2 through 4

    print(Emps[{3,1}]) # Rows 3 and 1
}

text {
    Columns within a table are accessed with the `.` operator
    and indexed as usual.
} prompt {} xtal_shell {
    print(Emps.Name)       # Column name supplied as literal

    colname = 'Salary'
    print(Emps.$colname)   # Column name supplied in a variable

    print(Emps.Salary[@@ >= 70000])           # High salaries
    
    print(Emps.Name[Emps.Salary >= 70000])    # Highly paid employees
} text {
    Table slice operators can be used extract subtables.
} prompt {} xtal_shell {
    print(Emps.(Name, Location))

    print(Emps.(Name, Location)[2:4])
}
text {
    As for columns, boolean expression can be used to query tables.
} outputlimit 0 prompt {} xtal_shell {
    print(Emps[Emps.Salary > 50000 && Emps.Location != "New York"])

    print(Emps[Emps.Salary > 50000 && Emps.Location != "New York"] . (Name, Age))
} text {
    Tables can be modified in multiple ways.
} xtal {
    Emps[% Emps] = {'Mary', 38000, 25, 'Seattle'}    # Add a row

    Emps.Salary = Emps.Salary + 2000                 # Modify entire column

    Emps.Location[Emps.Name.Sally] = "New York"      # Modify a single cell

    print(Emps)
}

text {
    .Variables and literals
    Having looked at basic operations on columns and tables,
    we will quickly go over the general purpose features of the language.
    
    The syntax of Xtal is close to the C family of languages
    than Tcl.
    Thus unquoted identifiers are variables, not strings, and do not
    need a `$` prefix as in Tcl and expressions use the usual infix form.
} xtal {
    a = 1 ; b = 2
    c = 1 + a * b
} text {
    String literals can be expressed in two forms - surrounded by
    double quotes or by single
    quotes. In the former case, variable and command substitutions
    are performed as in Tcl. In the latter case, no variable or command
    substitutions are done.

} prompt {} xtal_shell {
    puts('The value of b at time [clock seconds] is $b')

    puts("The value of b at time [clock seconds] is $b")
}

text { 
    .Mixing `Tcl` and `Xtal`
    An important feature of Xtal is that, being built on top of Tcl,
    it can be freely intermixed with it. This allows use of the syntax
    that is most suitable for the task at hand.
    
    Tcl code can be intermixed within Xtal by bracketing it with
    `<>`.
} xtal {
    now = <clock seconds>

    L = {1, 2}
    < lappend L 3 >
    puts(L)
} text {
    The Tcl fragment may also be spread across multiple lines.
} xtal {
    puts("Xtal statement")
    <
    puts "First Tcl statement"
    puts "Second Tcl statement"
    >
} text {
    Similarly, Xtal can be mixed with Tcl code with the `xtal::xtal`
    command.
} shell {
    namespace import xtal::xtal
    xtal {
        puts("puts called from Xtal")
        <
        puts "puts called from Tcl called from Xtal"
        xtal {puts("puts called from Xtal called from Tcl called from Xtal")}
        >
    }
} text {
    As we see later, we can also define procs in Xtal that are called
    from Tcl like any other Tcl command.
}

text {
    .Calling functions
    
    Commands or functions
    (we use the terms interchangeably) are called with parameters
    enclosed in parenthesis as in the C family of languages.
} xtal {
    hex = format("0x%x", 42)
}

text {
    .Working with lists
    Lists are constructed using braces but unlike in Tcl, elements
    are general expressions separated with commas.
} xtal {
    L = {0, a, b, a + b, tcl::mathfunc::rand()}
} text {
    Note that these lists are just plain Tcl lists. The above is
    equivalent to the Tcl command
} script {
    set L [list 0 $a $b [expr {$a+$b}] [tcl::mathfunc::rand]]
} text {
    Thus you can call Tcl's list related commands, like
} prompt {} xtal_shell {
    llength(L)
} text {
    Many of the operators we saw earlier with
    columns and tables can also be used with lists. This can
    be more convenient than the corresponding Tcl command.
    
    The prefix operator `%` can be used to return the length of a list.
} xtal {
    L = {'zero', 'one', 'two', 'three'}
    len = % L  # Tcl - llength $L
} text {
    Similarly, the indexing operator `[]` can be used instead
    of `lindex` and this supports the many forms we saw earlier.
} prompt {} xtal_shell {
    L[0]       # Single element. Tcl - lindex $L 0
    
    L[0:1]     # Index range. Tcl - lrange $L 0 1
    
    L[{3,1,2}] # Index list - no direct Tcl equivalent.

    L[%L] = "four" # Append. Tcl - lappend L four
} text {
    The index operations can be search expressions as well.
} prompt {} xtal_shell {
    L[L ~ ".*o$"]
} text {
   The indexing operator can be used in assignments. 
} prompt {} xtal_shell {
    L[%L-2 : %L] = {999, 1000, 1001}
    
    L[{3,2}] = {100, 101}
} text {
    Other list operations are performed by calling the corresponding
    Tcl command.
} prompt {} xtal_shell {
    lsort(L)
}

text {
    .Working with dictionaries
    
    Tcl dictionary access has a similar shorthand
    using the `.` lookup postfix operator.
} prompt {} xtal_shell {
    colors = {"red", 0xff0000, "green", 0x00ff00, "blue", 0x0000ff}
    
    colors.red

    colors.blue = 0x0000ee
}

text {
    The lookup postfix operator `.` used with dictionaries can also be used
    with columns. In this case, it returns the index of the first matching
    element.
} prompt {} xtal_shell {
    Months.Apr
}

text {
    That ends our quick tour of the basic.
    Xtal has other advanced features as well as standard programming
    language constructs such
    as control structures and built-in functions that we have left
    out in our quick tour.

    The rest of this document describes Xtal in more detail.
}

text {
    == Running Xtal 

    Xtal is implemented as the Tcl `xtal` package.
} shell {
    package require xtal
} text {
    To save some typing we will add both `xtal` and `tarray`
    to our namespace path.
} shell {
    namespace path [list xtal tarray]
} text {
    A Xtal code fragment may be run by one of several means.

    First, it can be run from within a Tcl script or a Tcl shell
    using the `xtal::xtal` command.
    This is roughly the equivalent of running a Tcl script using `eval`.
} shell {
    xtal { a = 1 }
} text {
    The `xtal` command returns the result of the last statement it
    executes.
    
    Second, you can define a Xtal procedure _from Tcl_ using `xtal::function` in
    a similar fashion as the Tcl `proc` command. It can then be invoked
    in the same manner as a Tcl procedure.
} shell {
    function add {x y} { return x + y }
    add 2 3
} text {
    Third, you can load an entire Xtal file using the
    `xtal::source` command which has syntax similar to the
    Tcl `source` command.
} syntax {
    xtal::source ?-encoding _ENCODING_? _XTALFILE_
} text {
    In all the above cases, the Xtal code is compiled to Tcl on the fly
    at runtime. A more efficient alternative for larger applications
    is to compile Xtal to Tcl
    ahead of time with the `xtal::compile` command. This has the syntax
} syntax {
    compile _XTALINPUTFILE_ _TCLOUTPUTFILE_ ?-encoding _ENCODING_?
} text {
    The input file in Xtal is translated to a Tcl script which is written
    out to _TCLOUTPUTFILE_. Only the output file needs to be shipped with
    the application and is sourced like any other Tcl script.
}

text {
    === Running interactively
    You can also type Xtal commands directly in interactive mode
    using the Xtal shell which accepts both Xtal and Tcl syntax.
    This is described in ((^ chap_xtal_shell)).
}


text {
    In this document, for ease of exposition we will simply show the
    relevant Xtal fragments without any reference to how they
    are executed.
}

text {
    ((== sect_basic_xtal_syntax "Basic syntax"))

    The basic syntax of Xtal is closer to the C family of languages
    than to Tcl.

    === Statements

    Like Tcl, a Xtal script is a sequence of statements separated
    by either a newline character or a semicolon.
} xtal {
    x = 2
    y = 3 ; z = x*y
} text {
    A statement may be an assignment as above, or simply an expression:
} xtal {10*x + y}

text {
    ==== Assignment statement
    An assignment statement in Xtal takes the form
} syntax {
    _LVALUE_ = _RAVALUE_
} text {
    where _RVALUE_ may be a Xtal expression or
    ((^ sect_xtal_tcl "Tcl fragment")).

    In the current version of Xtal, _LVALUE_ cannot be an arbitrary
    expression and must take one of the following forms:

    * an identifier as defined in ((^ sect_xtal_variables))

    * optionally followed by a ((^ sect_xtal_lookup_op "lookup")),
    ((^ sect_xtal_column_sel_ops "column selection")) or
    ((^ sect_xtal_table_slice_ops "table slicing")) operator

    * optionally followed by an ((^ sect_xtal_indexing_ops "indexing")) operator
}

text {
    ((=== sect_xtal_tcl "Mixing Tcl and Xtal"))

    Tcl and Xtal code can be intermixed. To embed Xtal within
    Tcl, use the `xtal::xtal` command as
} syntax {
    xtal _SCRIPT_
} text {
    where _SCRIPT_ is the Xtal fragment which may be spread across
    multiple lines.
} shell {
    xtal { x = 2 }
    xtal {
        y = 3
        z = x * y
    }
} text {
    Conversely, Tcl can be embedded with Xtal by placing the
    Tcl script within `<` and `>` delimiters.
} prompt {} xtal_shell {
    now = <clock seconds>
} text {
    Multi-line scripts are permitted.
} xtal {
    <
        set x 2
        set y 3
        set z [expr {$x + $y}]
    >
} text {
    The terminating `>` _must_ be followed by a Xtal statement terminator
    such as a newline or `;`, optionally with intervening whitespace.

    [NOTE]
    Embedded Tcl is not an expression and thus cannot be used as
    part of an expression.
}

text {
    === Comments

    Comments begin with `#` and extend to the end of the line.

    [NOTE]
    Unlike Tcl, `#` marks the beginning of a comment irrespective
    of where it appears outside of a quoted string and not only if
    appears at the beginning of a statement.
}

text {
    ((=== sect_xtal_variables Variables))

    As seen above, variables are syntactically different from Tcl:

    * There is no preceding `$` as in Tcl for accessing a variable's value.
    * Variable names are restricted to starting with an alphabetic
    character and may only contain alphanumeric characters, `_` and
    `:`.

    The variables themselves are standard Tcl variables and follow
    the same name resolution rules.
} shell {
    set v "This is a variable"
    xtal { v = "Modified from xtal" }
    puts $v
}

text {    
    === Literals

    Numeric literals are as in Tcl and have the same syntax as in Tcl.
    For example,
} prompt {} xtal_shell {
    r = 2.0e10
    big = 123455678987654321000000000
} text {

    String literals are delimited by single or double quotes and follow
    the backslash substitution rules as in Tcl. The difference between
    the two is that double quoted strings undergo
    variable and command substition as in Tcl whereas single quoted
    strings do not.

    Unlike in Tcl, _a plain unquoted string is treated as an identifier_ and
    not a string literal.
} errorok 1 prompt {} xtal_shell {
    s = unquoted

    s = "Sum of 2+2 is [expr 2+2]"

    s = 'Sum of 2+2 is [expr 2+2]'
} text {
    [WARNING]
    Braces have different semantics in Xtal and
    cannot be used to delimit strings.
}

text {
    === Lists

    Braces in Xtal are used to construct lists, similar to the
    `list` command in Tcl.
} xtal {
    l = {"a string", x, tcl::clock::seconds(), y+z}
} text {
    The list elements are separated using commas and an element may
    be a literal, variable, function call or general expression.
    The list elements may be spread across multiple lines but must still
    be separated by commas.
} xtal {
    l = {
        x,
        "a string",
        y+z
    }
} text {
    As an aside, we could also have invoked the Tcl `list` command
    as a function to construct a list.
} xtal {l = list(x,"a string",y+z)}

text {
    == Functions

    Functions in Xtal may refer to either Tcl commands or to functions
    implemented in Xtal through the `xtal::function` Tcl command or
    the Xtal `function` statement.
    
    === Invoking functions
    Invocation of functions/commands takes a form similar to function
    calls in C. 
    Function parameters are wrapped in parenthesis and separated by commas.

} xtal {
        hex = format("0x%x", 42)
} text {
    The above calls Tcl's built-in `format` command.
    There is no difference between invoking commands implemented in Tcl or
    in Xtal.

    [WARNING]
    ====
    There is a subtle
    point to be noted when invoking commands from Xtal as opposed to Tcl.
    In Xtal, a parameter that is not a literal is implicitly dereferenced
    when passed to a command. It is easy to forget this when calling
    Tcl commands that take variable _names_ as parameters.
    Thus 
    ----
    incr val -1
    ----
    is _not_ 
    ----
    xtal { incr(val, -1) }
    ----
    which lands up passing the _value_ of `val` to the `incr`
    command which actually expects the name `val` itself to be the argument.

    The correct equivalents are either of the following:
    ----
    xtal { incr("val", -1) }
    xtal { incr('val', -1) }
    ----
    ====
} text {
    As for list elements, the parameters for a function call may be
    spread across multiple lines.
} xtal {
    hex = format("0x%x",
                 42)
} text {
    The function called need not be an identifier; it can be supplied
    as any expression, for example a function call that returns a function
    name.
} prompt {} xtal_shell {
    < proc function_returning_function {} {return puts} >
    function_returning_function () ("Hello there!")
}

text {
    ==== Calling ensemble commands

    Ensemble commands such as `clock seconds` are called from Xtal as
} prompt {} xtal_shell {
    clock.seconds()
} text {
    Note the use of `.` as the separator between the command and its
    subcommand. Depending on how the ensemble is defined, you can
    also directly invoke it.
} prompt {} xtal_shell {
    tcl::clock::seconds()
} text {
    Finally, in the very rare case that the ensemble subcommand does
    not fit the syntax for a Xtal identifier, you can pass it as the
    first argument.
} prompt {} xtal_shell {
    clock("seconds")
}

text {
    ((==== sect_xtal_calling_methods "Calling object methods"))

    Object methods are called in a manner similar to ensemble commands.
} shell {
    oo::class create OExample { method m args {puts [join $args ,]} }
    OExample create o
    xtal {
        o.m('astring', 10)
        o.destroy()
    }
} text {
    However, there is an additional case here where the name of the
    object is not fixed and the object is accessed through a variable.
} errorok 1 shell {
    set obj [OExample new]
    xtal {obj.m('astring', 10)}
} text {
    _Function and object names, unlike variables, do not get implicitly
    dereferenced._
    In this case, the `$` operator is used for dereferencing.
} prompt {} xtal_shell {
    $obj.m('astring', 10)
    $obj.destroy()
} text {
    We will talk about the dereferencing operator
    ((^ sect_xtal_deref_op later)).
}

text {
    ==== Passing options to commands

    When passing options to commands, Xtal supports an additional
    syntax for arguments where the option name does not have to be
    quoted or separated from its value by a `,`.

    Instead of invoking the Tcl `subst` command as follows
} xtal { subst("-novariables", 'The value of val is $val') } text {
    it can be invoked as
} xtal { subst(-novariables 'The value of val is $val') } text {
    Note the option name is not quoted and there is no `,` separating
    it from its value.

    Xtal recognizes this form based on the argument being composed
    of two expressions with the first one being a token
    starting with a `-` character.
}

text {
    === Defining functions

    There are two ways to define functions that implemented in Xtal:

    * Using the `function` keyword within Xtal code
    * Using the `xtal::function` command within Tcl code

    Both offer the same functionality, differing only because of
    Tcl and Xtal syntax.
    
    ==== Defining Xtal functions with `function`
    Within Xtal, use `function` to define a Xtal function. This
    has the syntax
} syntax {
    function _NAME_ (?_PARAM_, ...?) _BODY_
} text {
    Parameters are separated by commas.
} xtal {
    function add(a, b) {return a + b}
    add(1,2)
} text {
    They can take default values where the value is
    separated from the parameter name with an `=` sign.
} xtal {
    function add(a, b = 1) {return a + b}
    add(10)
} text {
    The default value may be any expression, not necessarily a constant.
    Note however that the expressions are evaluated at the time
    the function is defined and not at the time it is invoked.
    
    If the last parameter name is `args`, it is treated in the same
    manner as in Tcl's `proc` command.
} text {
    ==== Defining Xtal functions in Tcl with `xtal::function`
    
    Unlike `function`, the `xtal::function`
    command is meant to be called from Tcl as opposed
    to being used within Xtal itself. It has the same form as
    the Tcl `proc` command except that the body of the procedure
    is Xtal instead of Tcl.
} syntax {
    xtal::function _NAME_ _PARAMS_ _BODY_
} text {
    _PARAMS_ takes the same form as in the `proc` command, including defaults
    for parameter and variable parameters using the `args` notation.
} shell {
    xtal::function add {a b} {return a + b}
}

text {
    === The `return` statement
    The Xtal `return` statement returns control to the caller
    from a function or procedure.
} syntax {
    return _EXPRESSION_
} text {
    `_EXPRESSION_` is any valid Xtal expression.
}

text {
    == Control statements

    Xtal implements control statement similar to Tcl
    but in a slightly different form.

    === The `if` statement
    The `if` statement has the general form
} syntax {
    if _EXPRESSION_ {
        _STATEMENTBLOCK_
    } elseif _EXPRESSION_ {
        _STATEMENTBLOCK_
    } else {
        _STATEMENTBLOCK_
    }         
} text {
    There may be zero or more `elseif` clauses and the
    `else` clause is optional. If present, the `else` and `elseif`
    keywords must
    be on the same logical line as the preceding statement block.

    `_EXPRESSION_` can be any Xtal expression and does not need
    to be enclosed in parenthesis.
} xtal {
    if %Emps {
        print(Emps)
    } else {
        puts("Table is empty")
    }
}

text {
    === The `while` statement
    The `while` statement has the syntax
} syntax {
    while _EXPRESSION_ { _STATEMENTBLOCK_ }
} text {
    `_EXPRESSION_` can be any Xtal expression and does not need
    to be enclosed in parenthesis.
} outputlimit 3 xtal {
    i = 0
    while i < % Emps {
        puts(Emps.Name[i])
        i = i + 1
    }
}

text {
    === The `for` statement
    The `for` statement is used to iterate over a range of integers
    with a suitable increment.
} syntax {
    for _IDENTIFIER_ _LOWEXPR_ ?: _HIGHEXPR_? ?: _INCREMENT_? _STATEMENTBLOCK_
} text {
    The loop variable `_IDENTIFIER_` is initially assigned a value of
    `_LOWEXPR_`. Thereafter, `_STATEMENTBLOCK_` is executed as long as the
    the value of the loop variable is less than or equal to `_HIGHEXPR_`. After
    each iteration, the loop variable is incremented by `_INCREMENT_` which
    defaults to `1` if unspecified.     
    The lower limit of the range is computed only once, before the loop is
    iterated. The upper limit is computed on every iteration.

} outputlimit 2 xtal {
    for i 0 : %Emps-1 {
        puts(Emps.Name[i])
    }
} text {
    If _HIGHEXPR_ is unspecified,
    the loop will not terminate unless you break out of it with
    a `return`, `break` or similar. Some examples of the various
    forms:
} xtal {
    for i 0:2 { puts(i) }
} xtal {
    limit = 5
    for i 0 : limit : 2 { puts(i) } 
} xtal {
    for i 0 {
        if i >= 2 { break }
        puts(i)
    }
} xtal {
    for i 0::2 {
        puts(i)
        if i > 3 { break }
    }
}

text {
    === The `foreach` statement
    This statement behaves similar to the
    Tcl `foreach` statement where the loop variable takes on values
    from a collection. The syntax takes one of the forms
} syntax {
    foreach  _VAR_ _COLLECTION_ _STATEMENTBLOCK_
    foreach _KEYVAR_ , _VAR_ _COLLECTION_ _STATEMENTBLOCK_
} text {
    where `_COLLECTION_` is any Xtal expression.
    
    In the first form, _STATEMENTBLOCK_ is executed for each element
    in _COLLECTION_.
    to variable named _VAR_. If _COLLECTION_ is a column, the variable
    _VAR_ takes the value of each element of the column. If _COLLECTION_
    is a table, _VAR_ is assigned each row of the table in list form.
    Otherwise, _COLLECTION_ is treated as a Tcl list and _VAR_ takes
    on the value of each element of the list.
} outputlimit 3 xtal {
    puts("Rainy months:")
    foreach month Months[Rainfall > 100] {
        puts(month)
    }
} text {
    The second form is similar in that again _STATEMENTBLOCK_ is executed
    for each element of _COLLECTION_. For columns and tables, behaviour
    is as above except that in addition to _VAR_, the variable named
    _KEYVAR_ is assigned the index of the element in the column or table.
    If _COLLECTION_ is not a column or table however, unlike the previous
    case it is assumed to be a Tcl dictionary and not a list.
    The _KEYVAR_ variable then takes on the values of the keys of the
    dictionary.
} outputlimit 3 xtal {
    foreach color, code colors {
        <puts "The code for $color is $code.">
    }
}

text {
    === The `break` statement
    The `break` statement behaves like the Tcl `break` command. It
    causes the innermost loop to stop execution and continue execution
    at the following statement.
} syntax {
    break
}

text {
    === The `continue` statement
    The `continue` statement behaves like the Tcl `continue` command. It
    aborts the current iteration of the innermost loop containing it
    without aborting the loop itself which then proceeds with its next
    iteration.
} syntax {
    continue
}

text {
    === The `try` statement
    The `try` statement closely resembles Tcl's `try` command
    differing only in that the syntax is a little different
    and the clauses are in Xtal.

    The general syntax of the command is
} syntax {
    try { _BODY_ } ?_HANDLER_ ...? ?finally { _FINALBODY_ }?
} text {
    Multiple handlers may be specified.
    Each _HANDLER_ may be one of two forms:
} syntax {
    on _EXCEPTIONCODE_ ?_VARNAME_ ...? { _HANDLERBODY_ }
    trap _ERRORPREFIX_ ?_VARNAME_ ...? { _HANDLERBODY_ }
} text {
    The statement results in the execution of `_BODY_`. The exception code
    resulting from the execution is matched against each handler in turn.
    The `_HANDLERBODY_` corresponding to the first matching handler is
    executed and propagation of the exception stops in that case. Further
    handlers are not checked.
    If no handler matches, the exception is propagated. In all cases,
    irrespective of the exception code and whether any handler matched,
    the `_FINALBODY_` script is run if present.

    In the case of the `on` handler, `_EXCEPTIONCODE_` is an integer value
    or one of the strings `ok`, `error`, `continue`, `break` or `return`.
    The handler will match if this matches the exception code resulting
    from the execution of `_BODY_`.

    The `trap` handler only matches if the exception code is `error`.
    Additionally the appropriate number of leading values from
    the `-errorcode` entry in the interpreter status dictionary
    must match the values specified in 
    `_ERRORPREFIX_` which must be of the form used for constructing lists.
    
    In both types of handlers, the handler script body may be preceded
    by zero or more variable names. If present, the first of these receives
    the result of the execution of `_BODY_`. The second variable, if present,
    receives the status dictionary.

    The following example will help clarify the working.
} xtal {
    try {
        x = nosuchvar
    } trap {'TCL', 'LOOKUP', 'VARNAME'} message status_dict {
        puts("Oops, variable does not exist")
        puts(message)
    } on error message status_dict {
        puts("Some other error")
    } finally {
        puts("Oh well, life goes on")
    }
} text {
    [WARNING]
    Make a note of how the `_ERRORPREFIX_` is specified as a list construct.
    The elements may be general expressions and hence string constants
    have to be quoted as shown in the example.
    
    A more bare-bones version of the above, with a different error this
    time, would be
} xtal {
    try {
        throw 'XTAL', 'TEST', "This is only a test"
    } trap {'TCL', 'LOOKUP', 'VARNAME'} {
        puts("Oops, variable does not exist")
    } on error message {
        puts(message)
    }
}

text {
    === The `throw` statement
    The `throw` statement raises a Tcl error in similar manner to
    Tcl's own `throw` and `error` statement. Its general syntax is
} syntax {
    throw _EXPRESSION_ ?, _EXPRESSION_ ...?
} text {
    If a single argument is given, it is taken to be the equivalent
    of the message argument to a Tcl `error` or `throw` command.
    If multiple arguments are given, the last argument is interpreted
    as the message. Moreover, all arguments are gathered into a list
    which becomes the value of the error code.
} shell {
    catch { xtal {throw "This is the error message"} } message
    puts $message
    puts $::errorCode

    catch { xtal {throw 'XTAL', 'ERROR', "This is only a test"} } message
    puts $message
    puts $::errorCode
}

text {
    == Columns and tables

    We now come to the primary reason for the existence of Xtal -
    convenient vector operations on columns and tables.

} text {
    === Creating columns

    Columns are created using the built-in operators `@boolean`,
    `@byte`, `@int`, `@uint`, `@wide`, `@double`, `@string` and `@any`.
    The syntax of the command can take two forms, the first of which is
} syntax {
    @__TYPE__ ?_INITLIST_?
} text {
    Here `_TYPE_` is one of the tarray column types and `_INITLIST_` is
    an optional initializer list. For example,
} xtal { A = @int } text {
    creates an empty column of type `int` and assigns it to `A` and
} xtal { A = @any {10, {1, 2, 3}, len} } text {
    creates a column of type `any` with 3 elements.

    The second form is that of a function, which is
} syntax {
    @__TYPE__ (?EXPR?)
} text {
    Again, here `_TYPE_` is one of the tarray column types. `_EXPR_`,
    if specified, is an expression that will be used to initialize the column.
    Thus this form can also be used to ''cast'' a column to a column of
    a different type.
} prompt {} xtal_shell {
    @int(Rainfall)
}

text {
    === Creating tables
    Tables are defined and created using the @table built-in operator.
    The syntax for the command is
} syntax {
    @table(?_COLNAME_ _TYPE_?, ...) ?_TABLEROWS_?
} text {
    where `_COLNAME_` is the name of the column and `_TYPE_` is one
    of the tarray column types. `_TABLEROWS_` may be specified
    to initialize the table and should be a list of rows as
    for the `tarray::table create` command. Here is the table
    definition from our ((^ sect_xtal_quick_tour)) section.
    
} syntax {
    Emps = @table (
        Name string,   Salary uint,   Age uint,   Location string
    ) {
        {'Sally',      70000,      32,       'Boston'},
        {'Tom',        65000,      36,       'Boston'},
        {'Dick',       80000,      40,       'New York'},
        {'Harry',      45000,      37,       'New York'},
        {'Amanda',     48000,      35,       'Seattle'}
    }
} text {
    [TIP]
    ====
    In many cases, you may find it easier to use Tcl, either directly
    or embedded, to create tables. For example, the above table
    can be created with embedded Tcl as
} xtal {
    Emps = <
      table create {
        Name string   Salary uint    Age uint    Location string
      } {
        {Sally        70000          32          Boston}
        {Tom          65000          36          Boston}
        {Dick         80000          40          "New York"}
        {Harry        45000          37          "New York"}
        {Amanda       48000          35          Seattle}
      }
    >
} text {
    ====
}

text {
    ((=== sect_xtal_column_sel_ops "The `.` table column selection operator"))
    Columns from a table can be selected using the `.` operator.
} syntax {
    _TABLE_._COLSPEC_
} text {
    The column specification `_COLSPEC_` may be
    the actual name of the column or
    specified through a variable via
    the ((^ sect_xtal_deref_op "dereferencing operator")).
} prompt {} xtal_shell {
    print(Emps.Name)
    colname = 'Location'
    print(Emps . $colname)
} text {
    These operators can be used in two contexts:

    * When used in expressions as above, they return column values
    from the table.
    * When referenced on the left side of an assignment statement,
    they select the column to be modified in a table.
    
    We will see examples later when we discuss indexing operators.
}

text {
    ((=== sect_xtal_table_slice_ops "The `.()` table slicing operator"))

    The table slicing operators `.()` operator
    return a table containing specific columns from a table.
} syntax {
    _TABLE_.(?_COLSPEC_,...?)
} text {
    Each column is specified using its name or by
    ((^ sect_xtal_deref_op "derefencing")) a variable
    containing its name.
} prompt {} xtal_shell {
    colname = "Salary"
    print(Emps.(Name, $colname))
} text {
    [NOTE]
    ====
    Note the difference between the following two expressions:
} prompt {} xtal_shell {
    Emps.Name
    Emps.(Name)
} text {
    The first returns a column. The second returns a table containing
    a single column.
    ====
    
    Like the table column selection operators,
    the table slicing operator can also be used in two contexts:

    * When used in expressions as above, it returns table slices
    * When referenced on the left side of an assignment statement,
    it assigns to the corresponding columns in the table
    
    Again, we will see examples later when we discuss indexing operators.
}

text {
    === Converting to lists and dictionaries

    Columns and tables can be converted to lists and dictionaries
    with the `@list` and `@dict` functions respectively. In the case
    of the latter, the key for the dictionary is the index of the
    value in the column or table.
} prompt {} xtal_shell {
    @list (Emps)
    
    @dict (Rainfall)
} text {
    Any expression that results in a column or table
    may be supplied as the parameter to these functions. If
    the expression does not result in a column or table, an error is
    generated.
}

text {
    == Operators

    Xtal operators fall into the following classes:

    * ((^ sect_xtal_arith_ops "Arithmetic operators"))
    are similar to those in Tcl's `expr` command
    but work on both scalars as well as columns.

    * ((^ sect_xtal_rel_ops "Relational operators")) and
    ((^ sect_xtal_logic_ops "logical operators"))
    are similar to those in `expr` when used
    with scalar operands. However, when used with column operands
    they have different semantics that provide very convenient search
    and indexing functionality.

    * ((^ sect_xtal_set_ops "Set operators"))
    are applicable only to columns and implement operations like
    union and intersection.
    
    * ((^ sect_xtal_lookup_op "The lookup operator")) that performs
    associative lookup on dictionaries and columns.

    * ((^ sect_xtal_indexing_ops "Indexing operators"))
    that combine both traditional indexing as well as search
    operations on collection data types including lists, columns
    and tables.

    * ((^ sect_xtal_misc_ops "Other miscellaneous operators")) that
    provide functionality like cardinality.
    
    Note that operator precedence follows that of Tcl.

    ((=== sect_xtal_arith_ops "Arithmetic operators"))

    ==== Unary arithmetic operators
    
    The Xtal unary operators are `-`, `+`, `~` and `!` have the
    same semantics as in Tcl for operands that are not columns or tables.

    In the case of columns, the `-` and `+` operators can
    be applied to numeric columns
    (types `byte`, `int`, `uint`, `wide` and `double`).
    The result is a column of the same type
    with each element being the result of the operator being applied
    to the corresponding element of the operand.

    The `~` operator can be applied to integral columns
    and columns of type boolean.

    For all other combinations of column type and operation, an error is
    raised.

    In the case of operands that are tables, all unary operators will
    raise an error.
    
    ==== Binary arithmetic operators
    
    The binary operators include `+`, `-`, `*`, `/`, `**`, `&`, `|`, `^`.
    
    .Rules of operation
    
    * If either operand is a table or a non-numeric column, an error is raised.

    * If neither operand is a column, they have the same
    semantics as in Tcl.

    * If an operand is not a column, it is treated as a column of the same
    size as the other operand with all elements having the operand value.

    * The result is a column each element of which is the result
    of the operation on the corresponding elements of the operands.
    In case of differing column types, types are promoted as needed.
    See the ((^ column_math "column math")) command reference for
    full details of type promotion and intermediate values.

    Here is an example of mixed operand types:
} xtal {
        I = @int {10, 20, 30, 40}
        J = @byte {1, 2, 3, 4}
        print(I + 2 * J)
} text {
    Tables do not support
    any arithmetic operators but their contained columns can be used anywhere
    that a standalone column is valid.

    For example, we can reduce everyone's salaries by 2K since times
    are tough.
} outputlimit 0 xtal {
    Emps.Salary = Emps.Salary - 2000
    print (Emps)
}

text {
    
    ((=== sect_xtal_rel_ops "Relational operators"))
    
    The relational operators include the `==`, `!=`, `<`, +<=+, `>`, `>=`
    operators that are present in Tcl.

    In addition, they include the operators related
    to string comparisons that are shown in 
    ((^ tab_xtal_match_ops)).
    
    ((.Table tab_xtal_match_ops "Xtal relational operators not in Tcl"))
    [cols="10,30,60", options="headers"]
    |===
    |Operator
    |Syntax
    |Description

    |`=^`
    |`_STRINGA_ =^ _STRINGB_`
    |Returns 1 if the two strings are equal in case-insensitive mode, else 0.

    |`!^`
    |`_STRINGA_ =^ _STRINGB_`
    |Returns 1 if the two strings are not equal in case-insensitive mode, else 0.

    |`~`
    |`_STRING ~ REGEXP_`
    |Returns 1 if the string matches the specified regular expression, else 0.

    |`~^`
    |`_STRING ~^ REGEXP_`
    |Returns 1 if the string matches the specified regular expression, else 0.
    The matching is done in case-insensitive mode.

    |`!~`
    |`_STRING !~ REGEXP_`
    |Returns 1 if the string does not match the specified regular expression,
    else 0.

    |`!~^`
    |`_STRING !~^ REGEXP_`
    |Returns 1 if the string does not match the specified regular expression,
    else 0. The matching is done in case-insensitive mode.


    |===

    Note that for the regular expression operators,
    the order of the operands is significant - the first indicates 
    the string being matched and the second is the regular
    expression.

    .Rules of operation
    
    * If either operand is a table, an error will be generated.

    * If both operands are columns, an error will be generated.

    * If neither operand is a column, the result will be a boolean
    value based on standard Tcl operators or the operators shown
    in ((^ tab_xtal_match_ops)).

    * If (exactly) one of the operands is a column, each element
    of the column is individually compared with the other operand.
    The result
    is an integer column containing the indices of those elements
    for which the specified comparison operation returns true.

    This last rule is illustrated by the example below which prints
    the indices for all months where the rainfall is less than 100mm.
} xtal {
    print(Rainfall < 100)
} text {
    The real usefulness of this will become apparent when we discuss
    ((^ sect_xtal_indexing_ops "indexing operators")).
    
    [NOTE]
    ====
    Xtal does not allow expressions of the form
} syntax {
    a < b < c
} text {
    on the basis that more often than not these are programming errors.
    This holds only for all relational operators, not arithmetic or logical
    operators. In the rare case that you need such expressions, use
    parenthesis to appropriately group the operands.
    ====
}
text {
    ((=== sect_xtal_logic_ops "Logical operators"))

    The logical operators include `&&` and `||` as in Tcl.
    _However, unlike Tcl these operators do not short-circuit the evaluation
    of their operands._

    .Rules of operation

    * If either operand is a table, an error will be generated.

    * If neither operand is a column, the result will be a boolean
    value based on standard Tcl operators.

    * If both operands are columns, the operation is treated
    as a set operation and described in ((^ sect_xtal_set_ops)).

    * If one operand is a column and the other is not, an error is
    raised.
}

text {
    ((=== sect_xtal_set_ops "Set operators"))

    The operators `&&` and `||` behave as set operators when both
    operands are columns. In this case, both operands must be of
    the same type.

    The `&&` operator returns a column of the same type as the operands
    and containing elements that are common to both.
    
    The `||` operator returns a column of the same type as the operands
    and containing elements that are present in either operand.
} tbd {
    Update docs with respect to uniqueness
}

text {
    ((=== sect_xtal_lookup_op "Lookup operator"))

    The operator `.` looks up keys in a dictionary
    or column.

    In the case of a dictionary, the operators retrieve
    the value associated with the key.

    The key operand is treated as a literal and returns
    the corresponding element from the dictionary. If the key follows
    the syntax for an identifier, it does not have to be quoted.
} prompt {} xtal_shell {
    d = <dict create one 1 two 2 three 3 4 four "number five" 5> 
    d.two                 # String key "two" does not need quoting
    d . "number five"     # Quoted string literal key
    d . three             # Note whitespace is optional
    d.4                   # Numeric literal
} text {
    To look up a key that is stored in a variable use the
    `$` ((^ sect_xtal_deref_op "dereferencing operator")).
} prompt {} xtal_shell {
    key = "number five"
    d.$key
    d . $key           # Note whitespace is optional
} text { 
    In the case of a column
    the lookup returns the index of the specified value.
} prompt {} xtal_shell {
    Emps.Name.Sally
} text {
    In the prior example, note the overloading of the `.` operator
    When applied to tables, it acts as a column selector.
    When applied to columns (selected from the table in this case)
    it acts as a lookup operator.

    [WARNING]
    If the
    value occurs multiple times in the column, any of the corresponding
    indices may be returned and may not even be the same in repeated calls.

    In all cases, an error is raised if the value being looked up
    does not exist in the dictionary or column.

    These operators can also be used on the left hand side of an
    assignment to set new values.
} prompt {} xtal_shell {
    d.c = 99

    I = @string {'zero', 'one', 'two', 'three'}
    I.one = 1
} text {
    [NOTE]
    If a variable does not already exist, the operator creates it
    as a dictionary.
}

text {
    ((=== sect_xtal_indexing_ops "Indexing and search operators"))

    Much of the convenience of Xtal in dealing with columns and tables
    stems from its variety of indexing options. Indices may be simple
    numerics, ranges, lists or selectors based on boolean expressions.

    The flexibility of index selectors also means that they are the primary
    means of searching tables and columns for elements matching desired
    criteria. Many indexing and search operators can also be used
    with lists.
}

text {
    ==== Integer indices

    In the simplest case, an index is simply a integer value, specified
    as a literal or an expression that results in a integer value. As
    the operand of the `[]` operator, it retrieves the value of the element
    at that position.
} prompt {} xtal_shell {
    Rainfall[0]          # Index a column with a constant

    i = 1
    Emps[i]              # Index a table with a variable
    
    {1, 2, 3, 4}[i+2]    # Index a list with an expression
} text {
    Note that the result is a ''scalar'', the value of the element at
    that position, not a column or table containing that element.
}

text {
    ==== Index ranges
    
    Alternatively, the index may specify an _index range_
    in the column or table using the syntax `_LOWEXPR_ : _HIGHEXPR_`.
    So, the rainfall for the first quarter can be retrieved by
} xtal {q1_rainfall = Rainfall[0:2]} text {
    In this case the index operator returns a column (or table)
    containing the specified elements. Thus notice the difference
    between
} xtal { Rainfall[0] } text {
    and
} xtal { Rainfall[0:0] } text {
    though they both specify a single element.

    The range limits may be expressions that result in integer
    values.
} xtal {
    i = 0
    print(Emps[i:%Emps-1])
} text {
    The upper limit in the range may be left unspecified in which
    it defaults to the last element. Thus the above could also be
    written as
} xtal {
    print(Emps[i:])
} text {
    Ranges may be used with lists as well.
} xtal {
    {1, 2, 3, 4}[1:2]
} text {
    We shall also see later that ranges can also be combined with
    selectors to further focus search and indexing operations.
}

text {    
    ==== Index lists

    The third form of an index is an _index list_. Here you can
    specify a list of integers or a column of type `int` that
    contain the numeric indices of interest.
} xtal {
    i = 10
    Rainfall[{9, i, 11}]
} text {
    We could have specified a column of type `int` instead.
} xtal {
    indices = @int {11, 10, 9}
    Rainfall[indices]
} text {
    Notice that an index list (or column) does not need to contain
    the indices in order and may even contain duplicate indices.
    The values returned are in the order of specified indices.

    Again, make a note of the difference with respect to a simple
    numeric index
} xtal { Rainfall[0] } text {
    which returns the element, versus
} xtal {
    Rainfall[@int {0}] 
} text {
    which returns a column containing that single element.

    [WARNING]
    ====
    However, because Tcl cannot distinguish between an integer
    and a list containing a single integer, the following
    expression returns a single element and not a column with a
    single element:
} xtal {
    Rainfall[{0}]
} text {
    Therefore it is better to supply index lists as
    integer column as opposed to a list of integers.
    ====

    Like simple indices and ranges, index lists can be used with
    lists as well.
} xtal {
    {1, 2, 3, 4}[@int{0, 2, 1, 3}]
}

text {
    ==== Selectors

    The final form an index can take is that of a _selector_ which
    is a boolean expression involving the column or table.

    .Selecting from columns
    
    As we noted in ((^ sect_xtal_rel_ops "column operators"))
    comparison of a column with a scalar value results
    in an `int` column containing the indices for which the comparison
    of the corresponding element succeeded. This implies that
    the boolean expression can be used as an expression that return
    an index list.
    
    As a simple example of a selector, consider the following expression:
} xtal { Rainfall > 100 } text {
    The return value is a column containing the indices corresponding
    to the elements which have a value greater than `100`.

    Therefore, we can use such boolean selectors as indices to 
    retrieve the actual values themselves.
} xtal { Rainfall[Rainfall > 100] } text {
    .Selecting from tables
    
    Selectors can be used for tables as well with the operand being
    a contained column. Moreover, the selector need not be a simple
    boolean expression. The following prints all employees who are
    over 35 but have an income less than `70,000`.
} outputlimit 0 xtal {
    print(Emps[Emps.Age > 35 && Emps.Salary < 70000]) 
} text {
    .Selecting from lists
    
    Although selectors may be used with lists as well, there
    are currently some limitations. Only the operators
    `==`, `!=`, `~` and `!~` can be used in list selectors.
    Moreover, because Tcl cannot be distinguished from plain
    strings, even these operators behave as selectors
    (as opposed to plain comparison operators) only when the
    operand is the same identifier as list being indexed.
    It is best to use the ((^ sect_xtal_current_context "@@ context")),
    discussed later, when indexing lists.
}
    

text {
    ===== Ranges in selectors

    Selectors can include ranges as well.
    For example, the rainfall in the last quarter that
    exceeds 50mm is given by
} xtal { Rainfall[9:11 && Rainfall > 50] } text {
    [WARNING]
    A selector can include function calls as well. However, note
    that the function is called just once, not once per element
    of the column or table.

    Because of their flexibility, selectors are the mechanism
    for doing searches in columns and tables.
}

text {
    ((===== sect_xtal_current_context "The `@@` selector context"))

    In previous examples, we supplied the variable containing the table
    or column, for example `Emps`, to the selector expression. In some
    cases, the table or column may not stored in a variable, for example
    when it is a function return value or when it is generated through
    an expression. In this case the `@@` special token may be used to
    reference the table instead of storing the generated value in
    a temporary for naming purposes. This is illustrated in the
    following example.
} shell {
    proc get_table {} { return $::Emps }
    xtal { print( get_table() [@@.Age > 35 && @@.Salary < 70000]) }
}

text {
    ==== Using indices in assignments
    The various forms of indexing can also be
    used in the left side of assignments. We have already seen some
    examples earlier. Below are some slightly more involved examples.
} tbd {
    To move everyone to Boston, fill the entire range with one value.
} tbd {
    Emps.Location[0 : %Emps - 1] = 'Boston'
} text {
    To give an increment only to low-paid
    employees make use of selectors.
} outputlimit 0 xtal {
    Emps.Salary[Emps.Salary < 50000] = Emps.Salary[Emps.Salary < 50000] + 2000;
    print (Emps)
} text {
    To modify a subset of the fields for a specific row,
    index a slice of the table. So to relocate Sally with a raise
} outputlimit 0 xtal {
    Emps.(Salary, Location)[Emps.Name.Sally]  = {70000, 'Seattle'}
    print (Emps[Emps.Name == 'Sally'])
} text {
    Use of indices in assignments is not limited to columns and rows.
    List elements can be assigned in the same manner.
} prompt {} xtal_shell {
    l = {1, 2, 3}
    l[0] = 101
    l[{3,4}] = {1000, 1001}
}

text {
    ((=== sect_xtal_misc_ops "Miscellaneous operators"))
}

text {
    ==== The `%` size operator

    The unary operator `%` returns the size
    of its operand which must be a list, column or table.
} prompt {} xtal_shell {
    len = % {1,2,3,4}   # Length of a list
    % Rainfall          # Size of a column
    % (Rainfall > 100)  # Size of a column returned by an expression
    nemps = % Emps      # Size of a table
}

text {
    ((==== sect_xtal_deref_op "The `$` dereferencing operator"))

    The operator `$` is a unary operator that dereferences
    the value of its operand. We have already seen an example of its use
    earlier.

    The operator can only be applied to an identifier or a string literal
    and not to an arbitrary expression. In both cases, it returns the
    value of the variable whose name is given by the operand value.
    
    The operator is useful in a couple of different situations. One is
    when you need to reference a variable that does not follow Xtal
    identifier syntax, e.g. one with spaces in it, as shown in the
    Tcl code below. 
} shell {
    set "variable with spaces in name" "value of variable with spaces"
    set varname "variable with spaces in name"
} text {
    Then the equivalent of the Tcl code
} shell {
    puts ${variable with spaces in name}
    puts [set $varname]
} text {
    would be the following in Xtal
} prompt {} xtal_shell {
    puts($"variable with spaces in name")
    puts($varname)
} text {
    The other use of the dereferencing operator is when Xtal expects
    a symbol such as function or object name, a lookup operand,
    a table column name etc. and you wish to supply it through a variable.
    We saw examples of this earlier which are repeated below.
} prompt {} xtal_shell {
    obj = OExample.new()
    $obj.destroy()            # Indirect object reference

    d.$key                    # Indirect dictionary lookup

    name = "Sally"
    Emps.Name.$name           # Indirect column lookup

    colname = 'Location'
    print(Emps . $colname)    # Indirect table column reference
} text {
    [NOTE]
    Dereferencing operators cannot be used on the left hand side
    of an assignment statement.
}

text {
    == Built-in functions

    A number of `tarray` commands that are not implemented as operators,
    or for which only a subset of functionality is available through operators,
    are available as built-in functions. These built-in functions can
    always be invoked through the normal function call mechanism using
    their qualified name (for example, `column.reverse`). However, invoking
    them as built-ins has some convenience like polymorphism and slightly
    shorter syntax.

    [NOTE]
    The documentation provides a summary of the built-in functions.
    For full details you can refer to the documentation for
    the corresponding `tarray` command.
}

text {
    === The `@delete` function
    The `@delete` deletes elements from a column or table.
    It has one of two forms:
} syntax {
    @delete(__COLUMN_OR_TABLE__, _FIRST_ : _LAST_)
    @delete(__COLUMN_OR_TABLE__, _INDICES_)
} text {
    The first form deletes all elements in the index range from `_FIRST_`
    to `_LAST_`. The second form deletes the elements whose indices are
    specified by `_INDICES_` which may be a single index, an index column
    or a list of indices.

    So for instance we could get rid of all our high-priced employees.
} outputlimit 0 xtal {
    Emps = @delete(Emps, Emps.Salary > 75000)
    print(Emps)
}

text {
    === The `@fill` function
    The `@fill` fills elements from a column or table with a fixed value.
    It has one of two forms:
} syntax {
    @fill(__COLUMN_OR_TABLE__, _VALUE_, _FIRST_ : _LAST_)
    @fill(__COLUMN_OR_TABLE__, _VALUE, _INDICES_)
} text {
    The first form sets all elements in the index range from `_FIRST_`
    to `_LAST_` to _VALUE_. The second form fills the elements whose indices are
    specified by `_INDICES_` which may be a single index, an index column
    or a list of indices.

    We can raise all low paid employees to a minimum salary level.
} outputlimit 0 xtal {
    Emps.Salary = @fill(Emps.Salary, 50000, Emps.Salary < 50000)
    print(Emps)
} text {
    The function can also be used to initialize a column or table
    with a fixed value.
} outputlimit 0 xtal {
    Col = @fill(@int, 0, 0:9)
}

text {
    === The `@inject` function
    The assignment operators in Xtal cannot be used to insert elements
    between two elements in a column or rows in a table. The `@inject`
    and `@insert` functions are provided instead for that purpose. The
    `@inject` command inserts the contents of a list or column (table)
    into another and returns the result. The syntax is
} syntax {
    @inject(__COLUMN_OR_TABLE__, _SOURCE_, _START_)
} text {
    where `_SOURCE_` is a list or column (table) to be inserted at position
    `_START_` in `__COLUMN_OR_TABLE__`. For example, we can add a couple
    of low priced lackeys to replace the ones we layed off.
} outputlimit 0 xtal {
    Emps = @inject(Emps, {
        {'Tom',      30000,      38,       'Boston'},
        {'Peyton',   30000,      38,       'Denver'}
    }, 0)
    print(Emps)
} text {
    We supplied a list of rows to be added above but we could also have
    specified a compatible table instead.
}

text {
    === The `@insert` function
    The `@insert` function is similar to `@inject` but inserts a _single_
    repeated value  or row into a column or table. It has the syntax
} syntax {
    @insert(__COLUMN_OR_TABLE__, _VALUE_, _START_ ?, _COUNT_?)
} text {
    The function inserts `_COUNT_` instances of _VALUE_ at the index position
    `_START_`. `_COUNT_` defaults to 1 if unspecified.
} prompt {} xtal_shell {
    @insert (@int {1,2,3}, 99, 0)

    @insert (@int {1,2,3}, 100, 1, 2)
}

text {
    === The `@lookup` function

    The function returns the index of an element in a column which
    must be of type `string`. It has the syntax
} syntax {
    @lookup(_STRINGCOLUMN_ ?, _KEY_?)
} text {
    The command returns the index of an element in `_STRINGCOLUMN_` that exactly
    matches `_LOOKUPKEY_` or -1 if not found. If `_KEY_` is not specified,
    command builds an internal dictionary (see below) and the return value
    is an empty string.

    Unlike the `@search`
    command, the returned index is not necessarily that of the first
    occurence in cases where `_KEY_` occurs multiple times in the column.

    The primary purpose of this function is to provide fast 
    access to columns that are used as an index.
    For more details, see the documentation for the
    ((^ column_lookup "column lookup")) command.
}

text {
    === The `@reverse` function
    The `@reverse` function reverses columns and tables.
} xtal {
    @reverse (@int {1,2,3})
} 

text {
    === The `@search` command
     
    The `@search` command searches a specified column and returns
    matching elements or the corresponding indices.
    Unlike most of the other built-ins, `@search` is called as a command
    and does not use the standard function call notation. It can
    take one of two forms. In the first form, the search target is specified
    directly:
} syntax {
    @search _COLUMNEXPR_ _RELOP_ _EXPRESSION_ ?_SEARCHOPTIONS_?
} text {
    In this form, `_COLUMNEXPR_` can be any expression that results in
    a column value. `_RELOP_` is any
    ((^ sect_xtal_rel_ops "relational operator")). Without any options
    specified, the command returns the index of the first element
    of the column that matches `_EXPRESSION_`.
    `_SEARCHOPTIONS_` is a space-separated
    list of options that modify this behaviour. The possible
    option values are shown in ((^ tab_xtal_search_options)).

    ((.Table tab_xtal_search_options "@search options"))
    [cols="20,80", options="header"]
    |===
    |Option
    |Description

    |all
    |If specified, a column containing _all_ matching elements
    are returned as opposed to just the first match. The type of the column
    is `int` if the `inline` option is not specified. Otherwise it
    is the type of the search target.

    |inline
    |If specified, the command returns the value, or values if the `all`
    option is specified, of the matching element, or elements, as opposed
    to their indices.
    
    |===

    The following examples illustrate the various combinations.
} prompt {} xtal_shell {
    @search Emps.Salary > 40000
    
    @search Emps.Salary > 40000 all
    
    @search Emps.Salary > 40000 inline
    
    @search Emps.Salary > 40000 inline all
} text {
} text {
    The second form that `@search` takes is
} syntax {
    @search _INDEXCOLUMN_ -> _COLUMNEXPR_ _ _RELOP_ _EXPRESSION_ ?_SEARCHOPTIONS_?
} text {
    In this case, `_INDEXCOLUMN_` is expected to contain indices into
    the column `_COLUMNEXPR_` and the search only examines the corresponding
    elements for a match. In all other respects, this form of the command
    behaves the same as the first form. See the next section for an
    example.
} text {
    .Search versus selectors
    Given that selectors perform a similar function to `@search`, when might
    one be preferred to the other?

    The selector form is more succint, convenient and not
    limited in its expressive power related to conditions. However,
    the search command in the current implemenation has some
    performance advantages illustrated in the example below.
    
    Suppose we want to list the salaries of 
    all employees in Boston who make more than 45000/year. We could write this
    using selectors.
} xtal {
    print (Emps.Name[Emps.Salary > 45000 && Emps.Location == 'Boston'])
} text {
    Alternatively, using `@search`,
} xtal {
    indices = @search (Emps.Salary > 45000) -> Emps.Location == 'Boston' all
    print (Emps.Name[indices])
} text {
    In the first case, Xtal searches the appropriate columns for
    salaries greater than the specified amount and then again for the
    specified location. Finally, it returns the intersection of the two
    and retrieves those names from the `Name` column of the table.

    In the second case, the list of indices where the salary is greater
    than the specified amount is retrieved. Then _only those elements_
    are searched for the location. Consequently, this method is significantly
    faster for large data sets.

    [NOTE]
    This performance benefit is only true because the current
    Xtal optimizer is extremely rudimentary and not capable of
    recognising and transforming the selector into the more efficient
    form. It is hoped future releases will improve on this.
}

text {
    === The `@sort` command
    The `@sort` command provides a flexible mechanism for sorting columns.
    Like `@search` and unlike most of the other built-ins,
    `@sort` is called as a command
    and does not use the standard function call notation. It can
    take one of two forms. In the first form, the sort target is specified
    directly:
} syntax {
    @sort _COLUMNEXPR_ ?_SORTOPTIONS_?
} text {
    In this form, `_COLUMNEXPR_` can be any expression that results in
    a column value. The command then returns a column of the same type
    sorted based on the specified options. `_SORTOPTIONS_` is a space-separated
    list of options that control the sorting operations. The possible
    option values are shown in ((^ tab_xtal_sort_options)).

    ((.Table tab_xtal_sort_options "@sort options"))
    [cols="20,80", options="header"]
    |===
    |Option
    |Description

    |decreasing
    |Sorts in order of decreasing value

    |increasing
    |Sorts in order of increasing value
    
    |indices
    |Specifies that the command should return the indices of the sorted
    values instead of the values themselves.

    |nocase
    |Specifies that sorting should be done in case-insensitive manner
    if the column is of type `string` or `any`. The default is
    a case-sensitive sort.
    
    |===

    So we might want to get the rainfall in sorted order.
}  xtal_shell {
    print (Rainfall)
    
    print (@sort Rainfall)
} text {
    But what is probably more interesting is the order of months so
    we might instead do the following
    (this time choosing a decreasing sort order).
} xtal_shell {
    print (@sort Rainfall decreasing indices)
} text {
    This returns a column of type `int` containing the indices of
    the sorted values.

    The sorted indices are useful in many circumstances. For example,
    we might display the employee database in multiple windows,
    one sorted by age, the other by salary. Instead of keeping
    two copies of the table sorted differently, it is cheaper in
    terms of memory to keep indices sorted differently. For example,
} xtal_shell {
    EmpsByAge    = @sort Emps.Age    indices
    EmpsBySalary = @sort Emps.Salary indices decreasing

    print (Emps[EmpsByAge])

    print (Emps[EmpsBySalary])
} text {
    The second form that `@sort` takes is
} syntax {
    @sort _INDEXCOLUMN_ -> _COLUMNEXPR_ ?_SORTOPTIONS_?
} text {
    Here the sorting is done indirectly. `_INDEXCOLUMN_` is an
    integer index column as the ones we computed above. This is
    treated as containing indices into the column `_COLUMNEXPR_`.
    The return value is `_INDEXCOLUMN_` sorted by
    comparing the corresponding values from the column
    `_COLUMNEXPR_`.

    There are a couple of scenarios where this is useful. One is
    in keeping a stable sort order when sorting successively on
    multiple keys. This is discussed in detail in
    ((^ sect_guide_sort_stability)) in the ((^ chap_guide)).

    The other example is when only a subset of a column or
    table is to be sorted. If we wanted to list salaries in
    sorted order but only for employees older than 35, we
    could do the following:
} prompt {} xtal_shell {
    OlderEmployees = Emps.Age > 35
    
    print (Emps[@sort OlderEmployees -> Emps.Salary])
} text {
    Or if you want to save on lines,
} prompt {} xtal_shell {
    print (Emps[@sort (Emps.Age > 35) -> Emps.Salary])
} text {
    This method is a lot cheaper than working directly with the table.
}

text {
    === The `@sum` function

    The `@sum` function returns the sum of the elements in a column.
} syntax {
    @sum(__NUMERIC_COLUMNEXPR__)
} text {
    So to get our annual salary expenditure,
} xtal {
    @sum(Emps.Salary)
}

text {
    == Futures
    
    Xtal is still under development. Syntactic and functional changes
    are likely. The runtime is currently scripted in Tcl
    for ease of development and therefore performance on
    _scalar_ operation (as opposed to columns and tables)
    will lag that of Tcl. It will be reimplemented using Tcl's C API
    before final release.
}

tbd {
    Ambiguity L[{0,1}] = {100,200} when L is a list - fill or put?
    Similar may also arise for columns and tables when RHS is not
    a column

    - see tarray_assign implementation
}
