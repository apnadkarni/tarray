text {
    ((= chap_guide "Programmer's guide"))
    Version {taversion}
    include::header.ad[]

    ((author "Ashok P. Nadkarni"))
}

text {

    This document is a programmer's guide for installing and using the `tarray`
    extension which implements two data types -- ((^ chap_column_ref _columns_))
    and ((^ chap_table_ref _tables_)). It does not list or detail
    every option or command implemented by the extension. See the command
    reference pages accessible from the 
    link:index.html[Main Table of Contents] for that information. Also see
    link:introduction.html[Introduction] for an overview of all the
    package components and documentation.

    [IMPORTANT]
    Typed arrays can also be manipulated using Xtal, a language embeddable
    in Tcl that is geared towards operating on typed arrays with a more
    succint syntax. However, Xtal is for the most part not described
    in this guide. See ((^ chap_xtal_lang)) for details on its use.
}

text {
    
    ((== * Motivation))

    Although Tcl provides for collections in the form of lists
    these have limitations when dealing with large
    amounts of data. These limitations, both in memory usage as well
    as performance, are a result of how values are internally stored in 
    Tcl. The `tarray` extension implements collections as native data
    types with parallelized operations resulting in orders of
    magnitude improvement in these performance 
    metrics when operating on numeric data (although with only marginal
    benefits for strings).

    In addition to performance, the extension also offers more
    convenience in terms of more flexible indexing as well as a wider and
    more powerful set of operations on collections.
}

text {
    ((== * "Installation and loading"))

    include::download.ad[]
    
} shell {
    package require tarray
} text {
    The extension places its commands in the `tarray` namespace.
    The primary commands implemented by the extension
    are ((^` chap_column_ref column)) and
    ((^` chap_table_ref table)), each being
    an ensemble of subcommands that operate on columns and
    table respectively.

    Other commands provide functionality like iteration and formatting
    that are independent of the data type.

    The examples in this guide assume the commands have
    been imported into the calling namespace
    or are included in its namespace path as shown below.
} shell {
    namespace path tarray
} text {    
    
    If in addition you want to use the Xtal language, you need to
    load its package as well.
} shell {
    package require xtal
    namespace import xtal::xtal
}

text {
    ((== sect_guide_concepts Concepts))

    ((=== * Columns))

    A _column_ is an ordered sequence of values of a single
    ((^ sect_guide_types _type_))
    that is specified when the column is created. The command
    ((^` chap_column_ref tarray::column))
    can be used to create and manipulate typed columns.

    ((=== * Tables))
    
    A _table_ is an ordered sequence of named columns of equal
    size. It can be also be viewed as an array of records where the
    record fields happen to use column-wise storage. The corresponding
    ((^` chap_table_ref tarray::table)) command operates on
    tables. Columns in a table can be referenced using either their
    name or their position in the ordered sequence.

}

text {
    ((=== sect_guide_types Types))

    include::types.ad[]
}

text {
    ((=== sect_guide_indices Indices))

    include::indices.ad[]

    The various forms for indexing are illustrated below using the
    `fill` command which stores a value at all specified locations.
} shell {
    set col [column create double {}];  # Creates a new column
    set col [column fill $col 1.0 0 9]; # Indices specified as range 0 to 9
    set col [column fill $col 2.0 3];   # Single index 3
    set col [column fill $col 2.0 end-2 end]; # Range relative to end
    set col [column fill $col 3.0 {2 7}];     # Indices specified as a list
    set col [column fill $col 3.0 [column create int {2 7}]]; # Indices specified as an `int` column
} text {
    The last form, an integer column, is useful because some commands
    return indices in that form. For example, the following will
    replace all elements greater than `2.0` with `0.0`.
} shell {
    set col [column fill $col 0.0 [column search -all -gt $col 2.0]]
}

text {
    ((=== * "Values and variables"))

    Many commands that modify columns and tables come in two flavors:

    * Commands that operate on column and table values and return the modified
    column or table as a result (for example `fill`), and

    * Commands that modify a Tcl *variable* containing the column or table
    (for example `vfill`).

    The difference is similar to how different Tcl list commands behave, e.g.
    `linsert` and lreplace versus lset and lappend.

    The examples above used the value-oriented form of the commands
    where the `fill` modifies a copy of the contents of the and returns
    the modified copy which is then stored back into . For large typed
    arrays, this is inefficient and the above would be better written
    as
} shell {
    set col [column create double {}]
    column vfill col 1.0 0 9
    column vfill col 2.0 3
    column vfill col 3.0 {2 7}
    column vfill col 3.0 [column create int {2 7}]
} text {
    Here the `vfill` command is directly modifying the variable and assuming the
    content is not shared, no copy needs to be made.

    **This guide does not necessarily illustrate both forms of every command.**
}
text {
    ((== sect_guide_col_opers "Operating on columns"))
    
    The `column` command is used to operate on columns.
    
    ((=== sect_guide_col_create "Creating columns"))

    The ((^` column_create "column create")) command creates columns
    of a specified type.
} shell {
    column create int
} text {
    The above creates a column that can hold elements of the `int` type. 
    Note that the command returns a _value_ that would normally be assigned
    to a variable.

    ((==== * "Creating initialized columns"))
    A column can be initialized at creation time. Let us create
    some columns we will use as examples throughout this guide that
    tracks weather through the year.
} shell {
    set months [column create string {
        Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec
    }]
    set temperatures [column create int {
        12  14  23  28  34  30  26  25  26  22  18  15
    }]
    set rainfall [column create double {
        11.0 23.3 18.4 14.7 70.3 180.5 210.2 205.8 126.4 64.9 33.1 19.2
    }]
} text {


    [WARNING]
    ====
    Applications should not depend on the exact string representation of a column
    or table as that is liable to change. Use only the `tarray` package
    commands to create and manipulated columns and tables. So do not create
    the columns above as either of the following
} syntax  {
    set rainfall {tarray_column double {11.0 23.3 ...}}
    set rainfall [list tarray_column double [list 11.0 23.3 ...]]
}  text {
    ====

    The above examples use a Tcl list for initialization. Alternatively, a
    column could also be used instead. For example,
} shell {
    set first_quarter [column create any [column range $months 0 2]]
} text {
    Notice the initialization column type need not be the same as long
    as the values are compatible.

    A related command is ((^` column_cast "column cast")) which
    differs in that it is less strict in terms of converting
    values. For example,
} errorok 1 shell {
    set I [column create int {255 256 257}]
    set B [column create byte $I]; # Error because values do not fit in a byte
    set B [column cast byte $I]; # No error, high order bits discarded
    
} text {
    Columns are resized as needed but as an optimization, preallocation
    may be requested.
} shell {
    column create int {0 1 2 3} 1000
} text {
    This preallocates space for a thousand elements with the first
    four being initialized.

    For the commonly useful cases of columns initialized with ones and zeroes
    respectively, the ((^` column_ones "column ones")) and
    ((^` column_zeroes "column zeroes")) commands.
} shell {
    column ones 5
    column zeroes 3 double
}

text {
    ((==== * "Creating numeric series"))
    Columns containing equally spaced values can be created
    with the ((^` column_series "column series")) and
    ((^` column_linspace "column linspace")) commands.
} shell {
    column series 10;           # 0 (default) to 10 with step 1 (default)
    column series 5 -5 -2;      # Decreasing from 5 to -5 with step -2
    column series 10.0;         # Series of doubles instead of integer
} text {
    While the `column series` command accepts a step size, the
    `column linspace` command accepts a interval count.
} shell {
    column linspace 0 20 5;     # Defaults to closed interval and type double
    column linspace 20 0 4 -type int -open true; # Open interval of descending ints
}

text {

    ((==== * "Creating columns with random values"))

    The ((^` column_random "column random")) command creates and
    initializes column with random values.
} shell {
    column random boolean 16;   # Array of 16 randomly generated booleans
    column random int 5 -100 100; # Array of 5 random integers in a range
} text {
    For some uses, such as testing, it is useful to be able to generate
    the same sequence of random numbers on every run. The `randseed`
    command can be used to set or reset the initial seeds used for
    random number generation.
} shell1 {
    randseed 100 200;           # Set the initial seeds for random number generation
    column random byte 10
    column random byte 10
    randseed 100 200;           # Set the *same* seeds again
    column random byte 10;      # Notice same values generated
    randseed;                   # Reset to use random initial seeds
    column random byte 10;      # Now again non-deterministic values are generated
}

text {
    ((==== * "Creating bit maps"))

    As a convenience, boolean columns which have all bits set to `0`
    or to `1` can be created with ((^` column_bitmap0 "column bitmap0"))
    and ((^` column_bitmap1 "column bitmap1")) respectively.
} shell {
    set zerobits [column bitmap0 8]
    set onebits  [column bitmap1 8]
} text {
    Further, specific bits can be initialized to the complement.
} shell {
    set bits [column bitmap0 8 {0 7}]
}                  


text {
    ((=== * "Storing elements"))

    A column may be modified by either storing a **single**
    value at multiple target locations or a different value at each
    target location. Further, the locations may be a contiguous range
    or an arbitrary set of indices. Depending on the command, the
    values may overwrite existing values or inserted.

    ((==== * "Storing one value in multiple locations"))

    The ((^` column_fill "column fill")) and
    ((^` column_vfill "column vfill")) commands store a **single** value
    at one or more locations, either contiguous or noncontiguous.
} shell {
    set I [column series 10]
    column fill $I 99 end; # Store a single element
    column fill $I 99 1 8; # Store into a contiguous range
    column fill $I 99 [column series 10 2]; # Store in every other position
}

text {

    ((==== * "Storing multiple values in arbitrary locations"))

    The ((^` column_place "column place")) and
    ((^` column_vplace "column vplace")) commands store each value
    from a sequence of 
    values at one or more locations in a specified order
    (not necessarily sequential).
} shell {
    column place $I {101 102 103} [column create int {3 2 5}]; # Stores list of values at an index column
    column place $I [column create int {101 102 103}] {3 2 5}; # Stores a column of values at an index list
} text {
    Note from the above how both values as well as indices can be
    specified as a Tcl list or as a column. This is true for most commands.
}

text {
    ((==== * "Storing multiple values in contiguous locations"))

    The ((^` column_put "column put")) and
    ((^` column_vput "column vput")) commands store each value from a
    sequence of values in **contiguous** locations starting at a
    specified index.
} shell {
    column vput I {60 70 80} 6; # Stores values consecutively starting at index 6
    column vput I $I; # Appends to itself unspecified starting index defaults to end
}

text {
    ((==== * "Inserting one value in multiple locations"))

    The ((^` column_insert "column insert")) and
    ((^` column_vinsert "column vinsert")) commands
    store a single repeated value a specified number of times starting
    at a given index. The following command inserts the value 99
    three times at index 1.
    
} shell {
    set I [column series 5]
    column insert $I 99 1 3
}

text {
    ((==== * "Inserting multiple values"))

    The ((^` column_inject "column inject")) and
    ((^` column_vinject "column vinject")) commands insert
    multiple values passed as a list or a column into contiguous
    locations starting at a specified index.
} shell {
    set I [column series 5]
    column inject $I {10 20 30} 2; # Inserts 10, 20, 30 at index 2
    column inject $I $I 2; # Inserts itself at position 2
}

text {
    ((=== * "Deleting elements"))
    
    Elements in a column can be deleted with the
    ((^` column_delete "column delete")) and
    ((^` column_vdelete "column vdelete")) commands.
    Succeeding elements are moved up to occupy the deleted
    slots. Like the `fill` command, the indices of the elements to be
    deleted may be specified as a single index, a range, a list of
    indices or a index column.
} shell {
    set I [column random int 10 -100 100]
    column delete $I end;       # Delete last
    column delete $I 3 6;       # Delete third through sixth
    column delete $I {0 7 2};   # Delete specified list
    column delete $col [column search -all -lt $col 0]; # Delete all negative values
}


text {
    ((=== * "Retrieving elements"))

    As for storing elements, there are multiple commands for
    retrieving elements depending on whether multiple elements are to
    be retrieved and whether they are contiguous or not.
    In cases where multiple values are retrieved, they are
    returned as a column by default but can be returned as a list or
    dictionary (keyed by index) with the use of the `-list` and
    `-dict` options.
}

text {
    ((==== * "Retrieving a single element"))

    In the simplest case, the
    ((^` column_index "column index")) command can be used to
    retrieve a single element.
} shell {
    column index $months 4
}

text {
    ((==== * "Retrieving all elements"))

    The command ((^` column_values "column values")) returns
    all elements of a column as a Tcl list.
} shell {
    column values $months
}


text {
    ((==== * "Retrieving a range of elements"))

    The command ((^` column_range "column range")) returns
    multiple contiguously located elements.
} shell {
    column range $months 0 2
    column range -list $months 0 2
    column range -dict $months 0 2
}

text {
    ((==== * "Retrieving an arbitrary list of elements"))

    Multiple elements at arbitrary indices can be retrieved with the
    ((^` column_get "column get")) command which accepts either a
    index list or a index column.
} shell {
    column get $months {10 7 4 7}
    column get $months [column create int {10 7 4 7}]
    column get -list $months [column create int {10 7 4 7}]
} text {
    As seen, indices may be repeated and values are returned in order
    of specified indices.

    Boolean index columns are treated differently in that an element
    is included if the corresponding bit is set in the index column.
} shell {
    column get $months [column create int {1 0 1}]
    column get $months [column create boolean {1 0 1}]
} text {
    Note the difference between the two results above.
}

text {
    ((=== * "Searching and filtering"))

    ((==== * "Linear search"))

    The ((^` column_search "column search")) command works similarly
    to Tcl's `lsearch`. It returns the indices or the values
    of matching elements in a column. Like `lsearch`, by default
    `column search` stops on the first match and returns the matching index.
} shell {
    set col [column create int {-10 10 0 20 0 -5 5}]
    column search $col 0
    column search $col 21;      # Not found
} text {
    The above command returns the index of
    the first element that is 0 using the default matching
    operator that tests for equality. On the other hand, if the `-inline`
    option is specified,
} shell {
    column search -inline -gt $col 0
} text {
    the command returns the value of the first positive element instead
    of its index (using the `-gt` "greater than" operator).

    The `-all` option requests all matching elements to be returned
    instead of the just the first. Thus
} shell {
    column search -all -gt $col 0
} text {
    returns an `int` column containging the indices of all positive elements.
    This is often useful to extract corresponding elements from
    another column.
} shell {
    column get $months [column search -all -gt $rainfall 100]
} text {
    
    When results are further used in logical operations, it is
    useful to specify the `-bitmap` option. This causes the results to
    be returned as a boolean vector where the matching indices are set
    to 1. That further allows for easy logical operations.
} shell {
    set not_wet [column search -bitmap -lt $rainfall 150]; # The `-bitmap` option implies `-all`
    set not_dry [column search -bitmap -gt $rainfall 50]
    set moderate_months [column get $months [column && $not_wet $not_dry]]
} text {
    [TIP]
    ====
    Queries like this are easier to do using ((^ chap_xtal_lang Xtal))
    expressions.
} shell {
    xtal::xtal { months[rainfall > 50 && rainfall < 150] }
} text {
    ====

    You can of course use `-inline` with `-all` to retrieve the
    values instead of indices. Using the `-pat` pattern matching operator
    as an example,
} shell {
    set exes [column create string {tclsh.exe tclsh.man wish.exe}]
    column search -all -inline -nocase -pat $exes *.exe
} text {
    returns the values of all elements that match **.exe* using case-insensitive
    matching as in Tcl's `string match -nocase`.

    The search can be restricted to only look at specific elements using a
    combination of `-range` and `-among` options. For example, find
    all summer months with limited rainfall.
} shell {
    column get $months [column search -all -range {4 7} -lt $rainfall 150]
} text {
    Similarly, using the `-among` option, only search the specified elements.
} shell {
    column get $months [column search -all -among {4 5 6 7} -lt $rainfall 150]
} text {
    The option `-among` is particularly useful in combining
    multiple searches where it can be used to constrain each search to
    the results of the prior search. We will see an example of this later.

    The `column search` command supports several matching operators
    like `-lt`, `-gt` etc. See the
    ((^` column_search "command reference")) for a full list.

    [TIP]
    The ((^` column_intersect3 "column intersect3"))
    command offers another way to combine searches across
    multiple columns as described
    ((^ sect_guide_set_operations later)).
    
}

text {
    ((==== * "Keyed lookup"))

    Fore columns of type `string` **only**, the
    ((^` column_lookup "column lookup")) command
    provides for faster, dictionary based
    retrieval. This may be beneficial for columns
    used as keys in a table.

    The command returns the index of matching element in the column.
} errorok 1 shell {
    column lookup months Jun
    column lookup months xxx;   # Returns -1 if not present
}

text {
    ((=== * "Ordering elements"))

    Several commands offer rearranging of the elements in a column.

    ((==== * "Sorting"))

    The most common rearrangement operation is sorting. Columns are sorted
    using ((^` column_sort "column sort")) command or its
    variable targeting analogue
    ((^` column_vsort "column vsort")). The commands take the
    `-increasing` and `-decreasing` options to determine the sort order.
} shell {
    column sort $rainfall;   # Default order is `-increasing`
    column sort -decreasing $rainfall
} text {
    The `-indices` option will return indices instead of the sorted
    values themselves. So to print months in order of increasing rainfall
} shell {
    column get -list $months [column sort -indices $rainfall]
} text {
    
    The command also supports the option `-indirect` where the operand
    is a column whose values are indices into the column whose values
    are to be sorted. 
} shell {
    set rain_indices [column series 12]
    column sort -indirect $rainfall $rain_indices
} text {
    Notice the `rain_indices` column is sorted in order of
    the corresponding values in the `rainfall` column. In this
    illustrative example, the indices are ordered before sorting but
    that does not have to be the case.

    One example of how this option is useful is illustrated later
    when we discuss ((^ sect_guide_sort_stability "sort stability")).
}

text { 
    ((==== * "Reversing"))

    A simple reordering transform is reversing the order of elements.
    The ((^` column_reverse "column reverse")) and
    ((^` column_vreverse "column vreverse")) commands can be used for
    this purpose.
} shell {
    column reverse $months
}

text {
    ((==== * "Shuffling"))

    The ((^` column_shuffle "column shuffle")) command returns the elements of a column
    in random order.
} shell {
    set I [column series 9]
    column shuffle $I
    column shuffle $I
}

text {
    ((=== * "Arithmetic and logical operations"))

    ((==== * "Comparing columns"))

    The ((^` column_identical "column identical")) and
    ((^` column_equal "column equal")) commands compare two columns in
    their entirety. The difference is that the former returns `1` if
    the columns have the same type in addition to elements being
    equal and `0` otherwise. The latter applies a looser definition in
    that the columns may be of different types.
} shell {
    set I [column create int {1 2 3}]
    set S [column create string {1 2 3}]
    column identical $I $S
    column equal $I $S
}

text { 
    ((==== * "Arithmetic operations between columns"))

    The ((^` column_math "column math")) command can be used
    to perform arithmetic and logical operations on columns on
    a per-element basic.
    The command takes multiple arguments each of which may be a column
    or a scalar numeric value. For example,
} shell {
    set I [column create int {10 20 30}]
    set J [column create double {10.1 19.9 30}]
    column math + $I $J 1000
    column math < $I $J
} text {
    As a convenience, the above command can also be issued as
} shell {
    column + $I $J 1000
    column < $I $J
} text {
    Logical operators work similarly but are generally
    used with boolean columns.
} shell {
    set bita [column bitmap0 5 {0 4}]
    set bitb [column bitmap0 5 {2}]
    column || $bita $bitb
} text {
    See the description of `column math` for all the available
    operators.
}

text {
    ((==== * "Arithmetic operations on a column"))

    In contrast to arithmetic commands that operate on a per-element basis,
    some commands operate on all elements of a single entire column.

    The ((^` column_sum "column sum")) command sums all the elements in
    a column.
} shell {
    column sum $J
} text {
    
    The ((^` column_minmax "column minmax"))
    command returns a pair containing the minimum
    and maximum values in a column.
} shell {
    column minmax $J
} text {
    Note that this command is not restricted to numeric columns
    and will work for other types as well.

    You can use the `-indices` option to get the indices of the minimum and
    maximum values instead of the values themselves.
} shell {
    column minmax -indices $J
}

text {
    ((==== sect_guide_set_operations "Set operations"))

    The ((^` column_intersect3 "column intersect3"))
    command returns a list containing the differences between two
    columns, the first element being the intersection, the second
    containing elements of the first that are not present in the
    second, and the third containing elements from the second that are
    not present in the first.
} shell {
    set hot [column search -all -gt $temperatures 25]
    set wet [column search -all -gt $rainfall 150]
    lassign [column intersect3 $hot $wet] hot_and_wet hot_and_dry cool_and_wet
    column get $months $hot_and_wet
} text {
    [TIP]
    An `intersect3` operation on search results is very fast, of order O(n).
    The fact that an index column returned by a search is in sorted order
    is internally noted by the implementation and made use of by a subsequent
    `intersect3`.
}

text {
    ((=== * "Counting elements"))

    The ((^` column_size "column size")) returns the number of
    elements in a column.
} shell {
    column size $rainfall
} text {
    If you are only interested in the count for elements that match
    specific criteria, you can use the 
    ((^` column_count "column count")) command instead. Thus
} shell {
    column count -gt $rainfall 150
} text {
    returns the number of months with heavy rainfall.
}


text {
    ((=== * "Introspecting columns"))

    The type of a column can be retrieved with the `column type` command.
} shell {
    column type $months
    column type $rainfall
}


text {
    ((== sect_guide_tab_opers "Operating on tables"))

    Wherever it makes sense, commands that operate on columns have
    counterparts that operate on tables. For example,
    `column fill` and `table fill`, `column range` and `table range`,
    and so on. Certain commands, like math operations, do not have
    equivalents for obvious reasons. Conversely, tables have
    additional commands like `join` that are not applicable to
    columns.

    Also like the column commands, table commands have variants that
    operate on values and variables respectively, e.g.
    `table put` and `table vput`. We will not always mention both
    variants here; see the reference pages instead for availability
    of a particular variant.
    
    ((=== sect_guide_tab_create "Creating tables"))

    Tables may be created from Tcl lists or from existing columns.

    ((==== * "Creating tables from list of row values"))

    The ((^` table_create "table create")) command
    constructs a table from a list of rows each
    of which is also a list. The first argument to the command defines
    the names and types of each column.
} shell {
    set countries [table create {
        Country string Population wide Area double
    } {
        {China        1350000000       9330000}
        {Vatican      850              0.44}
    }]
} text {
    ((==== * "Creating tables from columns"))

    The ((^` table_create2 "table create2")) command
    constructs a table from a sequence of existing columns, all of
    which must be the same length. Since columns are already typed,
    only the column names have to be supplied.
} shell {
    set monthly_temps [table create2 {
        Month Temperature
    } [list $months $temperatures]]
    set monthly_rainfall [table create2 {
        Month Rainfall
    } [list $months $rainfall]]
}

text {
    ((=== * "Operating on table columns"))

    ((==== * "Retrieving table columns"))

    The ((^` table_column "table column")) command returns a single
    column from a table.
    The ((^` table_columns "table columns")) command returns a list
    containing one or more columns from a table.
} shell {
    table column $countries Country
    table columns $countries {Country 1} ; # Columns may be specified by name or index
    table columns $countries ; # Defaults to returning all columns
}

text {
    ((==== * "Extracting a subtable"))

    The ((^` table_slice "table slice")) command returns a new table
    containing one or more columns from a table.
} shell {
    table slice $countries {Country Area}
}

text {

    ((==== * "Subsetting columns in commands"))

    While closely paralleling the commands that store values in
    columns, commands storing rows in tables have an additional
    consideration that is not applicable to columns.
    A table row consists of an ordered sequence of values from
    multiple columns. When reading or storing data, it is
    often convenient to operate only on a subset of these, and
    moreover to retrieve or provide the values in a different order
    than the column order of the table.

    Many table commands accept the `-columns` option for this
    purpose. Commands that retrieve data will only return the cells
    for those specified columns and in that specific order.
}

text {
    ((=== * "Storing rows"))

    ((==== * "Storing a single row in multiple locations"))

    The ((^` table_fill "table fill")) and
    ((^` table_vfill "table vfill")) commands store a **single** row
    in one or more locations. Like `column fill`, the destination may
    be a single row, a range of rows or at specified row indices.
} shell {
    table vfill countries {Russia 143967000 16.38e6} end+1; # Note use of `end+1` notation
}

text {
    ((==== * "Storing rows in arbitrary locations"))

    The ((^` table_place "table place")) and ((^` table_vplace "table vplace"))
    commands store one or more source rows at one or more locations in
    the table in a specified order.

    Assuming the Vatican City and China both experiences some population growth.
} shell {
    table vplace -columns {Population} countries {
        {1000}
        {1370000000}
    } {1 0}
} text {
    Notice this example makes use of the `-columns` option to update
    only a single column. Also note the supplied indices need not be
    in order.

    [NOTE]
    The `columns` option value and the row values are placed in braces
    though not really required here because they are actually lists of
    single elements. You would need braces if updating multiple columns.
}

text {
    ((==== * "Storing rows in contiguous locations"))

    The ((^` table_put "table put")) and ((^` table_vput "table vput"))
    commands store one or more source rows in a contiguous range of
    locations in the table. 

} shell {
    table vput -columns {Population Country Area} countries {
        {320000000 USA     9.16e6}
        { 82500000 Germany 349000}
    };                          # Note use of the `-columns` option as we are providing row fields in a different order
} text {
    Although the above examples supplied the rows in the form of a
    nested list, the command will also accept a table of the same shape
    as the destination.
}

text {
    ((==== * "Inserting one row in multiple locations"))

    The ((^` table_insert "table insert")) and
    ((^` table_vinsert "table vinsert")) commands
    store a single row value a specified number of times starting at a
    given index,
    pushing existing rows further to the end of the table.
} shell {
    table vinsert countries {Brazil 201000000 8358000} 2; # Inserts at index 2, (just once because no count specified)
}

text {
    ((==== * "Inserting multiple rows"))

    The
    ((^` table_inject "table inject")) and
    ((^` table_vinject "table vinject")) commands insert
    multiple rows, passed as a list or a compatible table, at a
    specified index in a table.
} shell {
    table vinject countries {
        {Ghana 28000000   227533}
        {India 1320000000 2973000}
    } 0;                        # Insert at beginning of table
}

text {
    ((=== * "Deleting rows"))
    
    Rows in a table can be deleted with the
    ((^` table_delete "table delete")) and
    ((^` table_vdelete "table vdelete")) commands.
    Succeeding rows are moved up to occupy the deleted
    slots. The indices of the rows to be
    deleted may be specified as a single index, a range, a list of
    indices or a index column.
} shell {
    set small_countries [column search -all -lt [table column $countries Population] 100000]
    table vdelete countries $small_countries
}

text {

    ((=== * "Retrieving rows"))

    As for columns, there are multiple commands for retrieving rows
    from a table and again as for columns, for multiple row retrieval
    they all support the `-list` or `-dict` option return the rows as
    a list or dictionary instead of the default table format.

    ((==== * "Retrieving a single row"))

    In the simplest cast, the ((^` table_index "table index"))
    command can be used to retrieve a single element.
} shell {
    table index $countries end
}

text {
    ((=== * "Retrieving all rows"))

    The ((^` table_rows "table rows")) command returns all rows in a table as a list.
} shell {
    table rows $countries
}

text {
    ((==== * "Retrieving a range of rows"))

    The command ((^` table_range "table range")) returns
    multiple contiguously located rows.
} shell {
    table range $countries 0 2
    table range -list $countries 0 2
    table range -dict $countries 0 2
}

text {
    ((==== * "Retrieving an arbitrary list of rows"))
    
    The get command retrieves rows at 
    noncontiguous indices specified as a Tcl list or column:
} shell {
    table get -columns {Country Population} $countries [column search -all -lt [table column $countries Area] 1000000]
} text {
    Note the use of the `-columns` option to retrieve only a subset of the
    table columns.
}

text {
    ((==== * "Comparing table"))

    The ((^` table_identical "table identical")) and
    ((^` table_equal "table equal")) commands compare two tables in
    their entirety. The difference is that the former returns `1` if
    the tables have the same column names and the
    `column identical` command returns true for every corresponding
    pair of columns, 
    and `0` otherwise. The latter applies a looser definition in
    that the `column equal` is used to compare columns and the column
    names may differ.
}

text {
    ((=== * "Searching tables"))

    To search tables, use the search on individual columns. For
    example, the fragment below returns names of countries that are
    populous and large in area. Note how the outer search is limited
    to specific indices using the `-among` option.

} shell {
    set pop_col  [table column $countries Population]
    set area_col [table column $countries Area]
    table get -list -columns {Country} $countries [column search -all -among [column search -all -gt $pop_col 250000000] -gt $area_col 5e6]
} text {

    [TIP]
    ====
    Note again that for more complex queries, it is more convenient to use the
    ((^ chap_xtal_lang "Xtal")) extension instead of some combination
    of `search` and `intersect3`. 
} shell {
    xtal::xtal {
        countries.Country[countries.Population > 250000000 &&  \
                          countries.Area > 5000000]
    }
} text {
    ====

}

text {
    ((=== * "Ordering rows"))

    ((==== * "Sorting tables"))

    Tables are sorted using the ((^` table_sort "table sort"))
    command. This is a thin wrapper around the `column sort` command
    and thus takes many of the same options.
} outputlimit 8 shell {
    print [table sort -columns {Country Population} -nocase $countries Country]
} text {
    The above prints a table slice sorted based on country name.
}

text {
    ((==== sect_guide_sort_stability "Nested sorts and sort stability"))
    
    When sorting tables, for display purposes for example, it is often
    necessary to display elements that have the same value in the sort
    column in the same order that they were previously
    displayed. Although, individual column sorts are stable, this is
    not enough when sorting across multiple columns. In such cases,
    the -indirect option to the sort command provides a
    solution. Using this option allows sorting where the "initial"
    ordering of elements is different from the actual order of
    elements in the column. An example will clarify this.

    Consider a table that stores heights and weights.
} shell {
    set tab [table create {name string height int weight int} {
        {Jeff 180 80}
        {John 175 80}
        {Jim 170 75} }]
} text {

    The user may choose to sort the table by height which boils down to the
    following code:
} shell {
    table get -list $tab [column sort -indices [table column $tab height]]
} text {
    This results in the table being displayed in the order `Jim`, `John`, `Jeff`.
    The user may then choose to sort by weight.
} shell {
    table get -list $tab [column sort -indices [table column $tab weight]]
} text {

    resulting in a display in order `Jim`, `Jeff`, `John`. Since they
    actually have the same value in the new sort column, this
    interchange of positions between `Jeff` and `John` is
    disconcerting to the user. Use of the `-indirect` option overcomes
    this problem.
} shell {
    set indices [column sort -indices [table column $tab height]]
    table get -list $tab $indices
} text {
    Now use previous order of indices to order elements
    when their values in the weight column are equal
} shell {
    table get -list $tab [column sort -indirect [table column $tab weight] $indices]
} text {
    In this last statement, the sort is done indirectly using values
    from table but the positioning of elements when these values
    compare equal is based on the order in the original table.
}

text {

    ((==== * "Reversing tables"))

    The order of rows in a table can be reversed with the
    ((^` table_reverse "table reverse")) or
    ((^` table_vreverse "table vreverse")) commands.
} shell {
    print [table reverse $countries]
}

text {
    ((=== * "Joining tables"))

    The ((^` table_join "table join")) command implements basic
    database-type join functionality between tables.
} outputlimit 6 shell {
    print [table join $monthly_rainfall $monthly_temps]
} text {
    By default, the join is done on the first column name that is
    common between the tables. The `-on` option can be used to change
    that. The result table includes all columns with duplicate columns
    being renamed as shown above. The `-t0cols` and `-t1cols` options
    can be used to control which columns are included from each table.
} outputlimit 6 shell {
    print [table join -t1cols Temperature $monthly_rainfall $monthly_temps]
}

text {
    ((=== * "Counting rows"))

    The ((^` table_size "table size")) command returns the number of
    rows in a table.
} shell {
    table size $countries
}

text {
    ((=== * "Introspecting tables"))

    Several commands return information about the definition of a table.

    The ((^` table_cnames "table cnames"))
    command returns a
    list containing the names of the columns in a table.
} shell {
    table cnames $countries
} text {
    The ((^` table_ctype "table ctype")) command returns the type of a
    column.
} shell {
    table ctype $countries Area
} text {
    If the full table definition is desired, it can be retrieved with
    ((^` table_definition "table definition")).
    The returned string is in a form that can be
    used with ((^` table_create "table create")).
} shell {
    table definition $countries
}

text {
    ((== * "Looping"))

    The ((^` tarray_loop loop)) command iterates over a column or
    table executing a script for every element or row.
} outputlimit 3 shell {
    loop row $countries {
        puts $row
    }                             
} text {    
    A variation includes the element or row index as an iteration
    variable.
} outputlimit 3 shell {
    loop rowindex row $countries {
        puts "Row $rowindex: $row"
    }
} text {
    The command can be used within a coroutine context to yield
    values.
} script {
    proc loopy col {
        yield;
        tarray::loop elem $col {
            yield $elem
        }
    }
    coroutine next_month loopy $months
} text {
    We can next retrieve each element using the iterator.
} shell {
    next_month
    next_month
}

text {
    ((== * "Grouping operations"))

    Several commands are targeted towards making grouping of data
    and summarization of columns and tables easier and more convenient.

    ((=== sect_guide_column_histogram "Computing histograms"))

    For example, suppose we want to classify monthly rainfall into
    four categories -- scanty, light, moderate and heavy -- and find
    how many months fall into each category. We can use the
    ((^` column_histogram "column histogram")) command for the purpose.
} outputlimit 0 shell {
    print $rainfall stdout -full 1
    print [column histogram -cnames {Rainfall NumMonths} $rainfall 4]
} text {
    The above divies up the range of values in the column into 4 equal
    intervals and counts the number of values that falls in each.
    The result is a table of two columns, the first being the lower
    bound of each interval and the second being the number of values
    that fall into that interval.

    The above looks even more crude than usual, so we can use the
    `-min` and `-max` options to control the limits.
} outputlimit 0 shell {
    print [column histogram -cnames {Rainfall NumMonths} -min 0 -max 240 $rainfall 4]
} text {
    Note that when either option is used, any values that do not fall
    within those limits are ignored.
    
    By default the command applies the counting function to each grouping
    as seen above. For other possibilities, refer to the command
    documentation.
    
    ((=== sect_guide_column_categorize "Grouping into categories"))

    Histograms are a special case of grouping that applies to
    numerical columns where values are grouped by range.
    A more general form is the ((^` column_categorize "column categorize"))
    command.

    Suppose we want to categorize the months by
    their first letters and print how many months start with each
    letter (why? To which I say, why not?).
} outputlimit 0 script {    
    proc first_letter {elem_index elem_value} {
        return [string toupper [string index $elem_value 0]]
    }
    print [column categorize -cnames {Letter Months} -values -categorizer first_letter $months]
} text {
    Notice that the associated value for each category is itself a
    column containing the actual values. The `column summarize`
    command discussed in the next section provides a mean to further
    process this by aggregating the nested columns elements.

    [NOTE]
    Although we do not show an example here, by default the
    `categorize` command returns the _indices_ of the elements
    belonging to that category, not their values. Hence the use of the
    `-values` option.

    Although slower than the `histogram` command, the `categorize` command 
    is more general and is useful for numerical values as well, for example if
    we do not want the intervals to be equal. The code fragment below
    classifies rainfall in a month as `scant`, `moderate` or `heavy`
    in a similar fashion to our earlier example except that here
    the intervals are not the same size.

} outputlimit 0 script {
    proc rain_class {elem_index elem_value} {
        if {$elem_value < 50} {
            return scant
        } elseif {$elem_value < 200} {
            return moderate
        } else {
            return heavy
        }
    }
    print [column categorize -cnames {Category Rainfall} -categorizer rain_class -values $rainfall]

} text {
    ((=== sect_guide_table_summarize "Summarizing categorized data"))

    Placing values into categories is only the first step. The next step
    is to process the categorized data to provide some useful information.
    The ((^` column_summarize "column summarize")) command is intended
    for this purpose. It takes a column of the form returned by the
    `categorize` (or `histogram` with appropriate options) and
    aggregates the values associated with each category with some
    prescribed function.

    For example, to print the number of months in each rainfall
    category as we did in our previous example, we could have also
    taken this route.
} outputlimit 0 script {
    set rain_by_category [column categorize -cnames {Category Rainfall} -categorizer rain_class -values $rainfall]; # Collect values in each category
    print [table summarize -cname NumMonths $rain_by_category]
} text {
    The above takes an additional step compared to what we saw
    earlier, but once we have categorized the original data, it makes
    it easier to summarize using a different, even custom, aggregation
    function. For example, to print the average,
} outputlimit 0 script {
    proc average {cat_index cat_col} {
        set n [column size $cat_col]
        if {$n == 0} {return "-"}
        return [expr {[column sum $cat_col] / $n}]
    }
    print [table summarize -summarizer average -cname AveRainfall $rain_by_category]
}

text {
    ((== * "Formatting output"))
    
    The Tcl `puts` command is not always suitable for printing
    the values for several reasons. The output
    is not formatted and hence difficult to read as you have probably
    noted from some of the previous output. The
    ((^` tarray_print print)) command
    provides an alternative that outputs a more readable format.
} outputlimit 0 shell {
    print [table column $countries Population] -head 1 -tail 1
    print $countries
} text {
    By default the command only prints the first few and last few
    elements although this can be controlled by various options.

    The ((^` tarray_prettify prettify)) command is similar except that it
    returns the formatted string instead of printing it to a channel.
} text {
    Another command that helps with formatting data is the
    ((^` column_width "column width")) command. This returns the
    maximum number of characters required to display elements
    of the column in a given format.
} shell {
    set col [column create int {-1000 10 100}]
    column width $col;          # Use default format string
    column width $col %x;       # Specify the format string
    column width $col "The number is %d."; # A generalized format string
}

text {
    ((== * "Export and import"))

    ((=== * "Importing from a database"))

    The result set from a TDBC database query can be imported into tarray tables
    with the ((^` table_dbimport_resultset "table dbimport resultset")) command.
    Naturally, the number of table columns and types have to match those of
    the result set.

} outputlimit 7 shell {
    package require tdbc::sqlite3
    tdbc::sqlite3::connection create db ../data/northwind_small.sqlite
    set stmt [db prepare {
        SELECT CompanyName,OrderCount
        FROM Customer
        INNER JOIN (SELECT `Order`.CustomerId AS CID, COUNT(*) AS OrderCount
                    FROM `Order`
                    GROUP BY `Order`.CustomerId)
        WHERE Customer.id=CID
    }]
    set rs [$stmt execute]
    set order_table [table create {Company any Orders int}]
    table dbimport resultset $rs order_table
    table print $order_table
} text {
    Alternatively, an entire table, or a subset of its columns, can be read
    with the ((^` table_dbimport_table "table dbimport table")) command. In this case,
    a new tarray table is returned with the column names matching the column
    names of the database table as returned by TDBC.
} outputlimit 7 shell {
    table print [table dbimport table db Customer {CompanyName ContactName ContactTitle}]
}

text {

    ((=== * "CSV export and import"))

    Tables can be exported to, and imported from, CSV format with
    ((^` table_csvexport "table csvexport")) and
    ((^` table_csvimport "table csvimport")) respectively.
} shell {
    table print [table csvimport -sniff ../data/college.csv]
} text {
    The commands support a number of options for distinguishing CSV dialects.
    A related widget, described later, implements a configuration wizard for
    dialects.
}

text {
    ((== * "Tk widgets"))

    The `tarray_ui` package provides several widgets for
    displaying and plotting column and table data.

}

text {
    ((=== * "Displaying tables"))

    The ((^ ui_tableview tarray::ui::tableview))
    widget makes it simple to display data in tables. For example,
    the snippet below will show the result of the database query we did earlier in
    with sorting and filtering capability.
} uiscript {
    package require tarray_ui
    toplevel .customers
    tarray::ui::tableview .customers.orders $order_table -showfilter true
    pack .customers.orders -fill both -expand yes
} text {
    The corresponding display table looks like

    image::customer_orders.png[Customer orders]

    The widget supports many capabilities such as sorting, display highlighting based
    on cell content, filtering and automatic scrollbars. Another example is shown below.

    image::cities_visual.png[City data]
}

text {
    ((=== * "Displaying graphs"))
    An alternate means of displaying table data that is numeric is through graphs.
    The ((^ ui_rbcchart ::tarray::ui::rbcchart)) widget wraps the RBC Tk extension
    to simplify the graphing of table data. An example is shown below.

    image::rain.png[Rain chart]

    See the ((^ ui_rbcchart reference)) for the corresponding code.
}

text {
    ((=== * "CSV import configuration wizard"))

    The ((^ ui_csvreader ::tarray::ui::csvreader)) widget is an interactive wizard
    for importing data from CSV files into tables. The widget, pictured below,
    can be used to interactively select the various CSV formatting conventions for
    reading CSV files into tables.

    image::csvreader.png[CSV configuration widget]
}

text {
    ((== * "Random numbers"))

    We saw earlier the construction of columns containing randomly generated
    values. Random numbers can also be directly generated using the
    `tarray::rng` command. This returns a command object which can then
    be invoked to generate values of the appropriate type.
} shell {
    rng create myrng int;       # Create a random number generator for integers
    myrng get;                  # Gets a random integer
    myrng get 5;                # Get 5 random integers
    myrng destroy;              # Release resources when no longer needed
} text {
    The `rng new` command behaves similarly except a command name need
    not be specified. Moreover, both forms take an optional argument
    to generate random numbers within a specified range.
} shell {
    set r [rng new double 1.0 2.0]; # Generate real numbers between 1.0 and 2.0
    $r get 3
    $r destroy
} text {
    For testing purposes, the generator can be initialized with a specific
    seed to reproduce the same sequence everytime.
} shell {
    rng create myrng byte 10 20
    myrng seed 1000 2000;         # Any 64-bit seed values
    myrng get 5
    myrng get 5
    myrng seed 1000 2000;         # Reset seeds
    myrng get 5
    myrng get 5
    myrng destroy
} text {
    As seen, the same sequence is reproduced by initializing the seed
    with specific values.
}

text {
    ((== * "Usage Hints"))

    .Specifying multiple indices
    When specifying indices to commands, Tcl lists of integers and columns of
    type `int` are usually interchangeable. Similarly, when passing multiple
    values to a command, either a Tcl list or a column of the appropriate type
    can be used. Note there is an ambiguity in the specific case where the
    target of the command is a column of type `any` and the passed operand is a
    string of the form `tarray any {...}`
    where the operand can be interpreted either as a column or a Tcl list with
    three elements `tarray`, `any` and the `{...}`. In this case the operand
    gets interpreted as a column.

    .Copy-on-write efficiency
    Given that the `tarray` extension is meant for dealing with
    large amounts of data, it is useful to keep in mind Tcl's
    object reference counting and copy-on-write
    implementation. Modifying a typed array that is shared will
    result in a copy being made, which can be expensive if the
    array is large.  So, to modify a variable that contains a
    typed array, the command
} shell {
    column vput I [list 100 200]
} text {
    is far more efficient than
} shell {
    set I [column put $I [list 100 200]]
} text {
    assuming the value in is not itself shared. This is similar to use of Tcl's
    `lset` command to modify lists.

    .Memory efficiency
    As arrays get large `tarray` prioritizes memory usage over efficiency. As
    arrays grow, the additional extra memory is conservatively allocated
    (unlike Tcl which aggressively allocates extra memory).
    If the size of a typed array
    can be estimated in advance, for example, reading records from a database,
    the memory can be preallocated.
} shell {
    column create int {} 1000000
} text {
    preallocates space for a million elements.

    Typed arrays are by design implemented as consecutive elements
    in contiguous memory. Certain operations, such as insertion and
    deletion, will not be efficient when arrays get very large. For
    applications where such operations are common, other structures
    should be built on top using typed arrays as the lower level
    building blocks. Such higher level structures can be scripted and
    customized for specific usage patterns easily as they can be
    implemented at the script level using the low level typed array
    operations for efficiency. Whether this is required or not should
    be determined based on application benchmarks.

    .List and column differences
    Both lists and columns have some differences in terms of
    functionality.  Columns do not have the -stride option but the
    same functionality can be implemented through tables. List
    indexing offers nesting while although columns can be nested, the
    nested columns have to be explicitly accessed. On the other hand,
    columns offer some additional functions such as intersect3 and
    indexing operations (eg. extraction or storing of multiple
    elements through index lists).

    .Considerations for columns of type `any`
    Columns of type `any` are stored as Tcl_Obj objects internally
    and thus are very similar to Tcl lists. Any advantage of an `any`
    typed array over using a simple Tcl list in terms of the memory
    footprint comes only from conservative memory overallocation, not
    from reduced memory size of individual elements. It is therefore
    not as big a benefit as for other types. Thus columns of type
    `any` are mostly beneficial when used in conjunction with other
    column types, for example in a table.

    Note that columns of type `string` are more efficient than type
    `any` for storing small strings.

    .Nesting typed arrays
    The type `any` can be any Tcl value, including typed
    arrays. Typed arrays can therefore be nested (tables are currently
    implemented as nested columns). However, unlike some of the Tcl
    list commands, `tarray` does not have commands that implicitly
    support nesting. Nested typed arrays have to be explicitly
    accessed as such.
} syntax {
    column index [column index $outer_column 4] 0
} text {
    .Sort optimization
    The package internally keeps track of the sorting state of a column. A
    column is internally marked after certain operations where the result is
    known to be sorted. An obvious example is the column sort command. A less
    obvious case is an index column returned from certain search operations.
    Several commands make use of this for more efficient operation. For example,
    the column intersect3 command is much faster when columns are known to be
    sorted. Thus finding the intersection of two index columns resulting from
    searches is an O(n) operation.
}

