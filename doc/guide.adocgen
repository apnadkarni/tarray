text {
    ((= chap_guide "Programmer's guide"))
    Version {taversion}
    include::header.ad[]

    ((author "Ashok P. Nadkarni"))
}

text {

    This document is a programmer's guide for installing and using the `tarray`
    extension which implements two data types -- ((^ chap_column_ref _columns_))
    and ((^ chap_table_ref _tables_)). It does not list or detail
    every option or command implemented by the extension. See the command
    reference pages accessible from the 
    link:index.html[Main Table of Contents] for that information. Also see
    link:introduction.html[Introduction] for an overview of all the
    package components and documentation.

    [IMPORTANT]
    Typed arrays can also be manipulated using Xtal, a language embeddable
    in Tcl that is geared towards operating on typed arrays with a more
    succint syntax. However, Xtal is for the most part not described
    in this guide. See ((^ chap_xtal_lang)) for details on its use.
}

text {
    
    == Motivation

    Although Tcl provides for collections in the form of lists
    these have limitations when dealing with large
    amounts of data. These limitations, both in memory usage as well
    as performance, are a result of how values are internally stored in 
    Tcl. The `tarray` extension implements collections as native data
    types with parallelized operations resulting in orders of
    magnitude improvement in these performance 
    metrics when operating on numeric data (although with only marginal
    benefits for strings).

    In addition to performance, the extension also offers more
    convenience in terms of more flexible indexing as well as a wider and
    more powerful set of operations on collections.
}

text {
    == Installation and loading

    include::download.ad[]
    
} shell {
    package require tarray
} text {
    The extension places its commands in the `tarray` namespace.
    The primary commands implemented by the extension
    are ((^` chap_column_ref column)) and
    ((^` chap_table_ref table)), each being
    an ensemble of subcommands that operate on columns and
    table respectively.

    Other commands provide functionality like iteration and formatting
    that are independent of the data type.

    The examples in this guide assume the commands have
    been imported into the calling namespace
    or are included in its namespace path as shown below.
} shell {
    namespace path tarray
} text {    
    
    If in addition you want to use the Xtal language, you need to
    load its package as well.
} shell {
    package require xtal
    namespace import xtal::xtal
}

text {
    ((== sect_guide_concepts Concepts))

    === Columns

    A _column_ is an ordered sequence of values of a single
    ((^ sect_guide_types _type_))
    that is specified when the column is created. The command
    ((^` chap_column_ref tarray::column))
    can be used to create and manipulate typed columns.

    === Tables
    
    A _table_ is an ordered sequence of named columns of equal
    size. It can be also be viewed as an array of records where the
    record fields happen to use column-wise storage. The corresponding
    ((^` chap_table_ref tarray::table)) command operates on
    tables. Columns in a table can be referenced using either their
    name or their position in the ordered sequence.

}

text {
    ((=== sect_guide_types Types))

    include::types.ad[]
}

text {
    ((=== sect_guide_indices Indices))

    include::indices.ad[]

    The various forms for indexing are illustrated below using the
    `fill` command which stores a value at all specified locations.
} shell {
    set col [column create double {}];  # Creates a new column
    set col [column fill $col 1.0 0 9]; # Indices specified as range 0 to 9
    set col [column fill $col 2.0 3];   # Single index 3
    set col [column fill $col 2.0 end-2 end]; # Range relative to end
    set col [column fill $col 3.0 {2 7}];     # Indices specified as a list
    set col [column fill $col 3.0 [column create int {2 7}]]; # Indices specified as an `int` column
} text {
    The last form, an integer column, is useful because some commands
    return indices in that form. For example, the following will
    replace all elements greater than `2.0` with `0.0`.
} shell {
    set col [column fill $col 0.0 [column search -all -gt $col 2.0]]
}

text {
    ((=== * "Values and variables"))

    Many commands that modify columns and tables come in two flavors:

    * Commands that operate on column and table values and return the modified
    column or table as a result (for example `fill`), and

    * Commands that modify a Tcl *variable* containing the column or table
    (for example `vfill`).

    The difference is similar to how different Tcl list commands behave, e.g.
    `linsert` and lreplace versus lset and lappend.

    The examples above used the value-oriented form of the commands
    where the `fill` modifies a copy of the contents of the and returns
    the modified copy which is then stored back into . For large typed
    arrays, this is inefficient and the above would be better written
    as
} shell {
    set col [column create double {}]
    column vfill col 1.0 0 9
    column vfill col 2.0 3
    column vfill col 3.0 {2 7}
    column vfill col 3.0 [column create int {2 7}]
} text {
    Here the `vfill` command is directly modifying the variable and assuming the
    content is not shared, no copy needs to be made.

    **This guide does not necessarily illustrate both forms of every command.**
}
text {
    ((== sect_guide_col_opers "Operating on columns"))
    
    The `column` command is used to operate on columns.
    
    ((=== sect_guide_col_create "Creating columns"))

    The ((^` column_create "column create")) command creates columns
    of a specified type.
} shell {
    column create int
} text {
    The above creates a column that can hold elements of the `int` type. 
    Note that the command returns a _value_ that would normally be assigned
    to a variable.

    ((==== * "Creating initialized columns"))
    A column can be initialized at creation time. Let us create
    some columns we will use as examples throughout this guide that
    tracks weather through the year.
} shell {
    set months [column create string {
        Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec
    }]
    set temperatures [column create int {
        12  14  23  28  34  30  26  25  26  22  18  15
    }]
    set rainfall [column create double {
        11.0 23.3 18.4 14.7 70.3 180.5 210.2 205.8 126.4 64.9 33.1 19.2
    }]
} text {

    [WARNING]
    ====
    Applications should not depend on the exact string representation of a column
    or table as that is liable to change. Use only the `tarray` package
    commands to create and manipulated columns and tables. So do not create
    the columns above as either of the following
} syntax  {
    set rainfall {tarray_column double {11.0 23.3 ...}}
    set rainfall [list tarray_column double [list 11.0 23.3 ...]]
}  text {
    ====

    Columns are resized as needed but as an optimization, preallocation
    may be requested.
} shell {
    column create int {0 1 2 3} 1000
} text {
    This preallocates space for a thousand elements with the first
    four being initialized.

}

text {
    ((==== * "Creating numeric series"))
    Columns containing equally spaced values can be created
    with the ((^` column_series "column series")) command.
} shell {
    column series 10;           # 0 (default) to 10 with step 1 (default)
    column series 5 -5 -2;      # Decreasing from 5 to -5 with step -2
    column series 10.0;         # Series of doubles instead of integer
}

text {

    ((==== * "Creating columns with random values"))

    The ((^` column_random "column random")) command creates and
    initializes column with random values.
} shell {
    column random boolean 16;   # Array of 16 randomly generated booleans
    column random int 5 -100 100; # Array of 5 random integers in a range
} text {
    For some uses, such as testing, it is useful to be able to generate
    the same sequence of random numbers on every run. The `randseed`
    command can be used to set or reset the initial seeds used for
    random number generation.
} shell1 {
    randseed 100 200;           # Set the initial seeds for random number generation
    column random byte 10
    column random byte 10
    randseed 100 200;           # Set the *same* seeds again
    column random byte 10;      # Notice same values generated
    randseed;                   # Reset to use random initial seeds
    column random byte 10;      # Now again non-deterministic values are generated
}

text {
    ((==== * "Creating bit maps"))

    As a convenience, boolean columns which have all bits set to `0`
    or to `1` can be created with ((^` column_bitmap0 "column bitmap0"))
    and ((^` column_bitmap1 "column bitmap1")) respectively.
} shell {
    set zerobits [column bitmap0 8]
    set onebits  [column bitmap1 8]
} text {
    Further, specific bits can be initialized to the complement.
} shell {
    set bits [column bitmap0 8 {0 7}]
}                  


text {
    ((=== * "Storing elements"))

    A column may be modified by either storing a **single**
    value at multiple target locations or a different value at each
    target location. Further, the locations may be a contiguous range
    or an arbitrary set of indices. Depending on the command, the
    values may overwrite existing values or inserted.

    ((==== * "Storing a single value in multiple locations"))

    The ((^` column_fill "column fill")) and
    ((^` column_vfill "column vfill")) commands store a **single** value
    at one or more locations, either contiguous or noncontiguous.
} shell {
    set I [column series 10]
    column fill $I 99 end; # Store a single element
    column fill $I 99 1 8; # Store into a contiguous range
    column fill $I 99 [column series 10 2]; # Store in every other position
}

text {

    ((==== * "Storing values in arbitrary locations"))

    The ((^` column_place "column place")) and
    ((^` column_vplace "column vplace")) commands store each value
    from a sequence of 
    values at one or more locations in a specified order
    (not necessarily sequential).
} shell {
    column place $I {101 102 103} [column create int {3 2 5}]; # Stores list of values at an index column
    column place $I [column create int {101 102 103}] {3 2 5}; # Stores a column of values at an index list
} text {
    Note from the above how both values as well as indices can be
    specified as a Tcl list or as a column. This is true for most commands.
}

text {
    ((==== * "Storing values in contiguous locations"))

    The ((^` column_put "column put")) and
    ((^` column_vput "column vput")) commands store each value from a
    sequence of values in **contiguous** locations starting at a
    specified index.
} shell {
    column vput I {60 70 80} 6; # Stores values consecutively starting at index 6
    column vput I $I; # Appends to itself unspecified starting index defaults to end
}

text {
    ((==== * "Extending columns"))
    
    A point to be noted about all the above commands is that they may
    extend the size of the array if necessary. However, 
    where an index list or index column is specified, there must not be
    any gaps in indices that extend the array.

    For example,
} errorok 1 shell {
    set I [column series 5]
    column place $I {106 105 107 104} {6 5 7 4}; # Ok: Indices not in order but no gaps
    column place $I {106 107} {6 7}; # Error: no value specified for non-existing index 5
}

text {
    ((==== * "Inserting a single value in multiple locations"))

    The ((^` column_insert "column insert")) and
    ((^` column_vinsert "column vinsert")) commands
    store a single repeated value a specified number of times starting
    at a given index. The following command inserts the value 99
    three times at index 1.
    
} shell {
    set I [column series 5]
    column insert $I 99 1 3
}

text {
    ((==== * "Inserting multiple values"))

    The ((^` column_inject "column inject")) and
    ((^` column_vinject "column vinject")) commands insert
    multiple values passed as a list or a column.
} shell {
    set I [column series 5]
    column inject $I {10 20 30} 2; # Inserts 10, 20, 30 at index 2
    column inject $I $I 2; # Inserts itself at position 2
}

text {
    ((=== * "Deleting elements"))
    
    Elements in a typed array can be deleted with the
    ((^` column_delete "column delete")) and
    ((^` column_vdelete "column vdelete")) commands.
    Succeeding elements are moved up to occupy the deleted
    slots. Like the `fill` command, the indices of the elements to be
    deleted may be specified as a single index, a range, a list of
    indices or a index column.
} shell {
    set I [column random int 10 -100 100]
    column delete $I end;       # Delete last
    column delete $I 3 6;       # Delete third through sixth
    column delete $I {0 7 2};   # Delete specified list
    column delete $col [column search -all -lt $col 0]; # Delete all negative values
}


text {
    ((=== * "Retrieving elements"))

    As for storing elements, there are multiple commands for
    retrieving elements depending on whether multiple elements are to
    be retrieved and whether they are contiguous or not.
    In cases where multiple values are retrieved, they are
    returned as a column by default but can be returned as a list or
    dictionary (keyed by index) with the use of the `-list` and
    `-dict` options.
}

text {
    ((==== * "Retrieving a single element"))

    In the simplest cast, the
    ((^` column_index "column index")) command can be used to
    retrieve a single element.
} shell {
    column index $months 4
}

text {
    ((==== * "Retrieving a range of elements"))

    The command ((^` column_range "column range")) returns
    multiple contiguously located elements.
} shell {
    column range $months 0 2
    column range -list $months 0 2
    column range -dict $months 0 2
}

text {
    ((==== * "Retrieving an arbitrary list of elements"))

    Multiple elements at arbitrary indices can be retrieved with the
    ((^` column_get "column get")) command which accepts either a
    index list or a index column.
} shell {
    column get $months {10 7 4 7}
    column get $months [column create int {10 7 4 7}]
    column get -list $months [column create int {10 7 4 7}]
} text {
    As seen, indices may be repeated and values are returned in order
    of specified indices.

    Boolean index columns are treated differently in that an element
    is included if the corresponding bit is set in the index column.
} shell {
    column get $months [column create int {1 0 1}]
    column get $months [column create boolean {1 0 1}]
} text {
    Note the difference between the two results above.
}

text {
    ((=== * "Searching and filtering"))

    ((==== * "Linear search"))

    The ((^` column_search "column search")) command works similarly
    to Tcl's `lsearch`. It returns the indices or the values
    of matching elements in a column. Like `lsearch`, by default
    `column search` stops on the first match and returns the matching index.
} shell {
    set col [column create int {-10 10 0 20 0 -5 5}]
    column search $col 0
    column search $col 21;      # Not found
} text {
    The above command returns the index of
    the first element that is 0 using the default matching
    operator that tests for equality. On the other hand, if the `-inline`
    option is specified,
} shell {
    column search -inline -gt $col 0
} text {
    the command returns the value of the first positive element instead
    of its index (using the `-gt` "greater than" operator).

    The `-all` option requests all matching elements to be returned
    instead of the just the first. Thus
} shell {
    column search -all -gt $col 0
} text {
    returns an `int` column containging the indices of all positive elements.
    This is often useful to extract corresponding elements from
    another column.
} shell {
    column get $months [column search -all -gt $rainfall 100]
} text {
    
    When results are further used in logical operations, it is
    useful to specify the `-bitmap` option. This causes the results to
    be returned as a boolean vector where the matching indices are set
    to 1.
} shell {
    set not_wet [column search -bitmap -lt $rainfall 150]; # The `-bitmap` option implies `-all`
    set not_dry [column search -bitmap -gt $rainfall 50]
    set moderate_months [column get $months [column && $not_wet $not_dry]]
} text {
    [TIP]
    ====
    Queries like this are easier to do using ((^ chap_xtal_lang Xtal))
    expressions.
} shell {
    xtal::xtal { months[rainfall > 50 && rainfall < 150] }
} text {
    ====

    You can of course use `-inline` with `-all` to retrieve the
    values instead of indices. Using the `-pat` pattern matching operator
    as an example,
} shell {
    set exes [column create string {tclsh.exe tclsh.man wish.exe}]
    column search -all -inline -nocase -pat $exes *.exe
} text {
    returns the values of all elements that match **.exe* using case-insensitive
    matching as in Tcl's `string match -nocase`.

    The search can be restricted to only look at specific elements using a
    combination of `-range` and `-among` options. For example, find
    all summer months with limited rainfall.
} shell {
    column get $months [column search -all -range {4 7} -lt $rainfall 150]
} text {
    Similarly, using the `-among` option, only search the specified elements.
} shell {
    column get $months [column search -all -among {4 5 6 7} -lt $rainfall 150]
} text {
    The option `-among` is particularly useful in combining
    multiple searches where it can be used to constrain each search to
    the results of the prior search. We will see an example of this later.

    The `column search` command supports several matching operators
    like `-lt`, `-gt` etc. See the
    ((^` column_search "command reference")) for a full list.

    [TIP]
    The ((^` column_intersect3 "column intersect3"))
    command offers another way to combine searches across
    multiple columns as described ((^ sect_guide_other later)).
    
}

text {
    ((==== * "Keyed lookup"))

    Fore columns of type `string` **only**, the
    ((^` column_lookup "column lookup")) command
    provides for faster, dictionary based
    retrieval. This may be beneficial for columns
    used as keys in a table.

    The command returns the index of matching element in the column.
} errorok 1 shell {
    column lookup months Jun
    column lookup months xxx;   # Returns -1 if not present
}

text {
    ((=== * "Ordering elements"))

    Several commands offer rearranging of the elements in a column.

    ((==== * "Sorting"))

    The most common rearrangement operation is sorting. Columns are sorted
    using ((^` column_sort "column sort")) command or its
    variable targeting analogue
    ((^` column_vsort "column vsort")). The commands take the
    `-increasing` and `-decreasing` options to determine the sort order.
} shell {
    column sort $rainfall;   # Default order is `-increasing`
    column sort -decreasing $rainfall
} text {
    The `-indices` option will return indices instead of the sorted
    values themselves. So to print months in order of increasing rainfall
} shell {
    column get -list $months [column sort -indices $rainfall]
} text {
    
    The command also supports the option `-indirect` where the operand
    is a column whose values are indices into the column whose values
    are to be sorted. 
} shell {
    set rain_indices [column series 12]
    column sort -indirect $rainfall $rain_indices
} text {
    Notice the `rain_indices` column is sorted in order of
    the corresponding values in the `rainfall` column. In this
    illustrative example, the indices are ordered before sorting but
    that does not have to be the case.

    One example of how this option is useful is illustrated later
    when we discuss ((^ sect_guide_sort_stability "sort stability")).
}

text { 
    ((==== * "Reversing"))

    A simple reordering transform is reversing the order of elements.
    The ((^` column_reverse "column reverse")) and
    ((^` column_vreverse "column vreverse")) commands can be used for
    this purpose.
} shell {
    column reverse $months
}

text {
    ((==== * "Shuffling"))

    The ((^` column_shuffle "column shuffle")) command returns the elements of a column
    in random order.
} shell {
    set I [column series 9]
    column shuffle $I
    column shuffle $I
}

text {
    ((=== * "Arithmetic and logical operations"))


    ((==== * "Arithmetic operations between columns"))

    The ((^` column_math "column math")) command can be used
    to perform arithmetic and logical operations on columns on
    a per-element basic.
    The command takes multiple arguments each of which may be a column
    or a scalar numeric value. For example,
} shell {
    set I [column create int {10 20 30}]
    set J [column create double {10.1 19.9 30}]
    column math + $I $J 1000
    column math < $I $J
} text {
    As a convenience, the above command can also be issued as
} shell {
    column + $I $J 1000
    column < $I $J
} text {
    Logical operators work similarly but are generally
    used with boolean columns.
} shell {
    set bita [column bitmap0 5 {0 4}]
    set bitb [column bitmap0 5 {2}]
    column || $bita $bitb
} text {
    See the description of `column math` for all the available
    operators.
}

text {
    ((==== * "Arithmetic operations on a column"))

    In contrast to arithmetic commands that operate on a per-element basis,
    some commands operate on all elements of a single entire column.

    The ((^` column_sum "column sum")) command sums all the elements in
    a column.
} shell {
    column sum $J
} text {
    
    The ((^` column_minmax "column minmax"))
    command returns a pair containing the minimum
    and maximum values in a column.
} shell {
    column minmax $J
} text {
    Note that this command is not restricted to numeric columns
    and will work for other types as well.

    You can use the `-indices` option to get the indices of the minimum and
    maximum values instead of the values themselves.
} shell {
    column minmax -indices $J
}

text {
    ((==== * "Set operations"))

    The ((^` column_intersect3 "column intersect3"))
    command returns a list containing the differences between two
    columns, the first element being the intersection, the second
    containing elements of the first that are not present in the
    second, and the third containing elements from the second that are
    not present in the first.
} shell {
    set hot [column search -all -gt $temperatures 25]
    set wet [column search -all -gt $rainfall 150]
    lassign [column intersect3 $hot $wet] hot_and_wet hot_and_dry cool_and_wet
    column get $months $hot_and_wet
} text {
    [TIP]
    An `intersect3` operation on search results is very fast, of order O(n).
    The fact that an index column returned by a search is in sorted order
    is internally noted by the implementation and made use of by a subsequent
    `intersect3`.
}

text {
    ((=== * "Counting elements"))

    The ((^` column_size "column size")) returns the number of
    elements in a column.
} shell {
    column size $rainfall
} text {
    If you are only interested in the count for elements that match
    specific criteria, you can use the 
    ((^` column_count "column count")) command instead. Thus
} shell {
    column count -gt $rainfall 150
} text {
    returns the number of months with heavy rainfall.
}


text {
    ((=== * "Introspecting columns"))

    The type of a column can be retrieved with the `column type` command.
} shell {
    column type $months
    column type $rainfall
}


text {
    ((== sect_guide_tab_opers "Operating on tables"))

    Wherever it makes sense, commands that operate on columns have
    counterparts that operate on tables. For example,
    `column fill` and `table fill`, `column range` and `table range`,
    and so on. Certain commands, like math operations, do not have
    equivalents for obvious reasons. Conversely, tables have
    additional commands like `join` that are not applicable to
    columns.

    Also like the column commands, table commands have variants that
    operate on values and variables respectively, e.g.
    `table put` and `table vput`. We will not always mention both
    variants here; see the reference pages instead for availability
    of a particular variant.
    
    ((=== sect_guide_tab_create "Creating tables"))

    Tables may be created from Tcl lists or from existing columns.

    ((==== * "Creating tables from list of row values"))

    The ((^` table_create "table create")) command
    constructs a table from a list of rows each
    of which is also a list. The first argument to the command defines
    the names and types of each column.
} shell {
    set populations [table create {
        country string population wide
    } {
        {China 1350000000}
        {Vatican 850}
    }]
} text {
    ((==== * "Creating tables from columns"))

    The ((^` table_create2 "table create2")) command
    constructs a table from a sequence of existing columns, all of
    which must be the same length. Since columns are already typed,
    only the column names have to be supplied.
} shell {
    set monthly_temps [table create2 {
        month temperature
    } [list $months $temperatures]]
    set monthly_rainfall [table create2 {
        month rainfall
    } [list $months $rainfall]]
}

text {
    ((=== * "Selecting columns"))

    While closely paralleling the commands that store values in
    columns, commands storing rows in tables have an additional
    consideration that is not applicable to columns.
    A table row consists of an ordered sequence of values from
    multiple columns. When reading or storing data, it is
    often convenient to operate only on a subset of these, and
    moreover to retrieve or provide the values in a different order
    than the column order of the table.

    Many table commands accept the `-columns` option for this
    purpose. Commands that retrieve data will only return the cells
    for those specified columns and in that specific order.
}

text {
    ((=== * "Storing rows"))

    ((==== * "Storing a single row in multiple locations"))

    The ((^` table_fill "table fill")) and
    ((^` table_vfill "table vfill")) commands store a **single** row
    in one or more locations. Like `column fill`, the destination may
    be a single row, a range of rows or at specified row indices.
} shell {
    table vfill populations {India 1320000000} end+1; # Note use of `end+1` notation
}

text {
    ((==== * "Storing rows at arbitrary locations"))

    The ((^` table_place "table place")) and ((^` table_vplace "table vplace"))
    commands store one or more source rows at one or more locations in
    the table in a specified order.

    Assuming the Vatican City and China both experiences some population growth.
} shell {
    table vplace -columns {population} populations {
        {1000}
        {1370000000}
    } {1 0}
} text {
    Notice this example makes use of the `-columns` option to update
    only a single column. Also note the supplied indices need not be
    in order.

    [NOTE]
    The `columns` option value and the row values are placed in braces
    though not really required here because they are actually lists of
    single elements. You would need braces if updating multiple columns.
}

text {
    ((==== * "Storing rows in contiguous locations"))

    The ((^` table_put "table put")) and ((^` table_vput "table vput"))
    commands store one or more source rows in a contiguous range of
    locations in the table. 

} shell {
    table vput -columns {population country} populations {
        {320000000 USA}
        { 82500000 Germany}
    };                          # Note use of the `-columns` option as we are providing row fields in a different order
} text {
    Although the above examples supplied the rows in the form of a
    nested list, the command will also accept a table of the same shape
    as the destination.
}



text {
    ((==== * "Inserting rows"))

    All the commands dicussed to this point overwrite existing
    values, at the target locations. The
    ((^` column_insert "column insert")) and
    ((^` column_vinsert "column vinsert"))
    commands and their table equivalents,
    ((^` table_insert "table insert")) and
    ((^` table_vinsert "table vinsert"))
    store a single repeated value or row, into the type
    array, pushing existing elements further up.
    Similarly, 
    ((^` column_inject "column inject")) and
    ((^` column_vinject "column vinject"))
    commands and their table equivalents,
    ((^` table_inject "table inject")) and
    ((^` table_vinject "table vinject")), insert
    multiple values or rows (passed as a list or a typed array).
} tbd {
    column insert $col 3.0 2 10
    column inject $col {1.0 2.0 3.0} 2
    column inject $col $col 2
} text {

    The first command returns a new column with the same value, `3.0`,
    inserted `10` times at index `2`. The second command returns a new
    column with all values in the passed list, `1.0`, `2.0`, `3.0`,
    inserted at index `2`. The last command returns a new column where
    all existing values in the column are reinserted at index `2`.
}


text {

    ((=== * "Retrieving data"))

    Retrieving data from a typed array involves specifying which
    elements to retrieve and what format to retrieve them in when
    multiple elements are retrieved.

    As usual, the elements to be retrieved can be specified as a
    single index, an index range, a list of indices or an index
    column. In the simplest cast, the index command can be used to
    retrieve a single element.
} shell {
    table index $populations end
} text {
    Multiple elements can be retrieved with the get and range
    commands. The get command can be passed a sequence of
    noncontiguous indices specified as a Tcl list or a `int` column:
} shell {
    table get $populations [column search -all -lt [table column $populations 0] 0]
} text {
    The range command retrieves elements in a specified index range.
} shell {
    table range $populations 0 10
} text {

    By default, both commands returns values as a typed array. The
    `-list` and `-dict` commands can be used to return the values as a Tcl
    list or dictionary instead.  In the latter case, the dictionary
    keys are the indices being retrieved.
} shell {
    table get -dict $populations [column search -all -lt [table column $populations 0] 0]
} text {

    In the case of tables, both commands also provide for retrieval of
    a subset of columns and in a different order than in the
    definition.
} shell {
    table range -columns {population country} $populations 0 end
    table range -columns {1} $populations 0 end
} text {
    Note columns may be specified either by position or name.

    Tables provide additional commands for retrieving entire columns.

    * table column returns a column from a table. This is useful for sorting and
    searching columns as shown in table search examples below.

    * table slice returns a new table containing a subset of the columns of a
    table.
}

tbd {
    To search tables, use the search on individual columns. For example,
} shell {
    set countries [table create {country string population wide area double} {
        {Vatican 850 0.44}
        {China 1350000000 9.55e6}
        {USA 314000000 9.63e6}
        {India 1250000000 3.3e6}
        {Russia 141930000 17e6} }]
    set pop_col [table column $countries 1]; # Column specified by position
    set area_col [table column $countries area]; # Column specified by name
    table get -list -columns {country} $countries [column search -all -among [column search -all -gt $pop_col 250000000] -gt $area_col 5e6]
} text {

    returns names of countries that are populous and large in area. Note how the
    outside search is limited to specific indices using the `-among` option.

    The ((^` column_intersect3 "column intersect3"))
    command offers another way to search across
    multiple columns as described later.

    [TIP]
    ====
    For more complex queries, it is more convenient to use the
    ((^ chap_xtal_lang "Xtal")) extension instead of some combination
    of `search` and `intersect3`. For example, to find all countries
    with a population more than a billion in less than 5 million sq.km,
} shell {
    xtal::xtal { countries.country[countries.population > 1000000000 && countries.area < 5000000]}
} text {
    ====

}

tbd {
        ((==== * "Sorting"))

    Columns can be sorted using the column sort command or its
    variable targeting analogue column vsort. The commands take the
    `-increasing` and `-decreasing` options to determine the sort order.

    The column sort command also takes the -indices option which
    results in the indices being returned instead of the values
    themselves. This is useful for sorting tables based on a
    column. For example, assuming variable `countries` has been
    initialized as above,
} shell {
    table get -list $countries [column sort -indices -nocase [table column $countries 0]]
} text {
    returns rows in the sorted order based on country name.

    ((==== sect_guide_sort_stability "Sort stability"))
    
    When sorting tables, for display purposes for example, it is often
    necessary to display elements that have the same value in the sort
    column in the same order that they were previously
    displayed. Although, individual column sorts are stable, this is
    not enough when sorting across multiple columns. In such cases,
    the -indirect option to the sort command provides a
    solution. Using this option allows sorting where the "initial"
    ordering of elements is different from the actual order of
    elements in the column. An example will clarify this.

    Consider a table that stores heights and weights.
} shell {
    set tab [table create {name string height int weight int} {
        {Jeff 180 80}
        {John 175 80}
        {Jim 170 75} }]
} text {

    The user may choose to sort the table by height which boils down to the
    following code:
} shell {
    table get -list $tab [column sort -indices [table column $tab height]]
} text {
    This results in the table being displayed in the order `Jim`, `John`, `Jeff`.
    The user may then choose to sort by weight.
} shell {
    table get -list $tab [column sort -indices [table column $tab weight]]
} text {

    resulting in a display in order `Jim`, `Jeff`, `John`. Since they
    actually have the same value in the new sort column, this
    interchange of positions between `Jeff` and `John` is
    disconcerting to the user. Use of the `-indirect` option overcomes
    this problem.
} shell {
    set indices [column sort -indices [table column $tab height]]
    table get -list $tab $indices
} text {
    Now use previous order of indices to order elements
    when their values in the weight column are equal
} shell {
    table get -list $tab [column sort -indirect [table column $tab weight] $indices]
} text {
    In this last statement, the sort is done indirectly using values
    from table but the positioning of elements when these values
    compare equal is based on the order in the original table.
}

tbd {

    ((==== * "Reversing row order"))

    Another form of reordering data is reversing the order of rows.
    Both columns and tables support `reverse` and `vreverse` commands which
    reverse the order of elements, an operation that is useful in many
    algorithms.
} shell {
    print [table column $tab name]
    print [column reverse [table column $tab name]]
}

tbd {
    table size
}

text {
    ((=== * "Introspection"))

    The `table cnames` command returns a list containing the names
    of the columns in a table.
} shell {
    table cnames $countries
} text {
    If the full table definition is desired, it can be retrieved with
    `table definition`. The returned string is in a form that can be
    used with `table create`.
} shell {
    table definition $countries
}

tbd {
    ((== * "Formatting output"))
    
    The Tcl `puts` command is not always suitable for printing
    the values for several reasons. The output
    is not formatted and hence difficult to read. The `print` command
    provides a alternative that outputs a more readable format.
} tbd {
    print [table column $countries population] -head 1 -tail 1
    print $countries
} text {
    By default the command only prints the first few and last few
    elements although this can be controlled by various options.

    The `prettify` command is another alternative which
    returns the formatted string instead of printing it to a channel.
} text {
    Another command that helps with formatting data is the
    ((^` column_width "column width")) command. This returns the
    maximum number of characters required to display elements
    of the column in a given format.
} shell {
    set col [column create int {-1000 10 100}]
    column width $col;          # Use default format string
    column width $col "hex representation is %x"; # Specify the format string
} tbd {
    column width
}

text {
    ((== * "Random numbers"))

    We saw earlier the construction of columns containing randomly generated
    values. Random numbers can also be directly generated using the
    `tarray::rng` command. This returns a command object which can then
    be invoked to generate values of the appropriate type.
} shell {
    rng create myrng int;       # Create a random number generator for integers
    myrng get;                  # Gets a random integer
    myrng get 5;                # Get 5 random integers
    myrng destroy;              # Release resources when no longer needed
} text {
    The `rng new` command behaves similarly except a command name need
    not be specified. Moreover, both forms take an optional argument
    to generate random numbers within a specified range.
} shell {
    set r [rng new double 1.0 2.0]; # Generate real numbers between 1.0 and 2.0
    $r get 3
    $r destroy
} text {
    For testing purposes, the generator can be initialized with a specific
    seed to reproduce the same sequence everytime.
} shell {
    rng create myrng byte 10 20
    myrng seed 1000 2000;         # Any 64-bit seed values
    myrng get 5
    myrng get 5
    myrng seed 1000 2000;         # Reset seeds
    myrng get 5
    myrng get 5
    myrng destroy
} text {
    As seen, the same sequence is reproduced by initializing the seed
    with specific values.
}

text {
    == Usage Hints

    .Specifying multiple indices
    When specifying indices to commands, Tcl lists of integers and columns of
    type `int` are usually interchangeable. Similarly, when passing multiple
    values to a command, either a Tcl list or a column of the appropriate type
    can be used. Note there is an ambiguity in the specific case where the
    target of the command is a column of type `any` and the passed operand is a
    string of the form `tarray any {...}`
    where the operand can be interpreted either as a column or a Tcl list with
    three elements `tarray`, `any` and the `{...}`. In this case the operand
    gets interpreted as a column.

    .Copy-on-write efficiency
    Given that the `tarray` extension is meant for dealing with
    large amounts of data, it is useful to keep in mind Tcl's
    object reference counting and copy-on-write
    implementation. Modifying a typed array that is shared will
    result in a copy being made, which can be expensive if the
    array is large.  So, to modify a variable that contains a
    typed array, the command
} tbd {
    column vput col [list 1.0 2.0]
} text {
    is far more efficient than
} tbd {
    set col [column put $col [list 1.0 2.0]]
} text {
    assuming the value in is not itself shared. This is similar to use of Tcl's
    `lset` command to modify lists.

    .Memory efficiency
    As arrays get large `tarray` prioritizes memory usage over efficiency. As
    arrays grow, the additional extra memory is conservatively allocated
    (unlike Tcl which aggressively allocates extra memory).
    If the size of a typed array
    can be estimated in advance, for example, reading records from a database,
    the memory can be preallocated.
} shell {
    column create int {} 1000000
} text {
    preallocates space for a million elements.

    Typed arrays are by design implemented as consecutive elements
    in contiguous memory. Certain operations, such as insertion and
    deletion, will not be efficient when arrays get very large. For
    applications where such operations are common, other structures
    should be built on top using typed arrays as the lower level
    building blocks. Such higher level structures can be scripted and
    customized for specific usage patterns easily as they can be
    implemented at the script level using the low level typed array
    operations for efficiency. Whether this is required or not should
    be determined based on application benchmarks.

    .List and column differences
    Both lists and columns have some differences in terms of
    functionality.  Columns do not have the -stride option but the
    same functionality can be implemented through tables. List
    indexing offers nesting while although columns can be nested, the
    nested columns have to be explicitly accessed. On the other hand,
    columns offer some additional functions such as intersect3 and
    indexing operations (eg. extraction or storing of multiple
    elements through index lists).

    .Considerations for columns of type `any`
    Columns of type `any` are stored as Tcl_Obj objects internally
    and thus are very similar to Tcl lists. Any advantage of an `any`
    typed array over using a simple Tcl list in terms of the memory
    footprint comes only from conservative memory overallocation, not
    from reduced memory size of individual elements. It is therefore
    not as big a benefit as for other types. Thus columns of type
    `any` are mostly beneficial when used in conjunction with other
    column types, for example in a table.

    Note that columns of type `string` are more efficient than type
    `any` for storing small strings.

    .Nesting typed arrays
    The type `any` can be any Tcl value, including typed
    arrays. Typed arrays can therefore be nested (tables are currently
    implemented as nested columns). However, unlike some of the Tcl
    list commands, `tarray` does not have commands that implicitly
    support nesting. Nested typed arrays have to be explicitly
    accessed as such.
} syntax {
    column index [column index $outer_column 4] 0
} text {
    .Sort optimization
    The package internally keeps track of the sorting state of a column. A
    column is internally marked after certain operations where the result is
    known to be sorted. An obvious example is the column sort command. A less
    obvious case is an index column returned from certain search operations.
    Several commands make use of this for more efficient operation. For example,
    the column intersect3 command is much faster when columns are known to be
    sorted. Thus finding the intersection of two index columns resulting from
    searches is an O(n) operation.
}

tbd {
    looping
}

tbd {
    export/import
}
