text {
    ((= chap_tscript "The TScript Language"))
    include::header.ad[]

    ((author "Ashok P. Nadkarni"))
}

text {
    == Introduction

    The ((^ chap_intro `tarray`)) Tcl extension implements _typed arrays_,
    which stores data in native format and provides efficient memory
    utilization and parallelized processing. Columns store elements
    of a single type, while tables, similar to data frames in the R
    language, are a ordered sequence of named columns. The `tarray`
    extension provides the corresponding
    ((^ chap_column_ref `column`)) and ((^ chap_table_ref `table`))
    Tcl commands for their manipulation.

    [TIP]
    This document assumes the reader is familiar with typed arrays.
    If not, please glance through the ((^ chap_guide)) before continuing.
    
    The TScript language is an alternative for 
    working with typed array columns and tables. It provides 
    
    * convenient succint syntax
    * vector operations
    * search operators
    * flexible indexing

    As an example, the statement
} syntax {
    Emp.Salary[Emp.Salary < 50000 && Emp.Age > 35] = 50000
} text {
    raises the salary of all underpaid older employees to a minimum level.

    TScript is embedded in Tcl and is executed through the `tscript`
    command. Tcl and TScript can be freely invoked from the other.
    However, TScript is syntactically completely different from Tcl.
}

text {
    == Running a TScript program

    TScript is part of the `tarray` package which is loaded as
} shell {
    package require tarray
    namespace path tarray;      # Permits us to use the column and table commands without qualification
} eval {
    source ../src/teval.tcl
} text {
    TScript is invoked from Tcl with the `tscript` command. For example,
    the above statement would be invoked from Tcl as 
} syntax {
    tscript {
        Emp.Salary[Emp.Salary < 50000 && Emp.Age > 35] = 50000
    }
} text {
    The `tscript` command itself returns the result of the last statement
    executed.
}

text {
    For demonstrative purposes, this document makes use of the following
    sample data. A column signifying the amount of rainfall during a 
    particular year
} shell {
    set Rainfall [column create double {
        11.0 23.3 18.4 14.7 70.3 180.5 210.2 205.8 126.4 64.9 33.1 19.2
    }]
} text {
    We also use a table containing a simple employee data base:
} shell {
    set Emps [table create {
        Name string Salary uint Age uint Location string
    } {
        {Sally      70000       32       Boston}
        {Tom        65000       36       Boston}
        {Dick       80000       40       {New York}}
        {Harry      45000       37       {New York}}
        {Amanda     48000       35       Seattle}
    }]
} text {
    For readability purposes, we will often make use of the `tarray::print`
    command.
} shell {
    print $Emps
}

text {
    ((== sect_basic_tscript_syntax "Basic TScript syntax"))

    The basic syntax of TScript is closer to the C family of languages
    than to Tcl.

    === Statements

    Like Tcl, a TScript script is a sequence of statements separated
    by either a newline character or a semicolon.
} shell {
    tscript {
        x = 2
        y = 3 ; z = x*y
    }
} text {
    A statement may be an assignment as above, or simply an expression:
} shell {
    tscript {10*x + y}
}

text {
    === Comments

    Comments begin with the `//` sequence and extend to the end of the line.
    They may be placed anywhere in the program. 
}

text {
    === Variables

    As seen above, variables are syntactically different from Tcl:

    * There is no preceding `$` as in Tcl for accessing a variable's value.
    * Variable names are restricted to starting with an alphabetic
    character and may only contain alphanumeric characters, `_` and
    `:`.

    The variables themselves are standard Tcl variables and follow
    the same name resolution rules.
} shell {
    set v "This is a variable"
    tscript { v = "Modified from tscript" }
    puts $v
}

text {    
    === Literals

    Numeric literals are as in Tcl and have the same syntax as in Tcl.
    For example,
} shell {
    tscript {
        r = 2.0e10
        big = 123455678987654321000000000
    }
} text {

    String literals are delimited by double quotes and follow
    the backslash substitution rules as in Tcl.
    However there some differences.

    _A plain unquoted string is treated as an identifier_ and
    not a string literal as in Tcl.
} errorok 1 shell {
    tscript {s = unquoted}
} text {
    Also, unlike in Tcl double quoted strings, there is no
    interpolattion.
} shell {
    set s "Tcl does [set x] interpolation"
    tscript { s = "Tcl does [set x] interpolation" }
} text {
    Also note that braces have different semantics in TScript and
    cannot be used to delimit strings.
}

text {
    === Lists

    Braces in TScript are used to construct lists, similar to the
    `list` command in Tcl. _Note this differs from the use of braces in Tcl._
} shell {
    tscript {
        l = {"a string", x, tcl::clock::seconds(), y+z}
    }
} text {
    Note the list elements are separated using commas and an element may
    be a literal, variable, function call or general expression.

    As an aside, we could also have invoked the Tcl `list` command
    as a function to construct a list.
} shell {
    tscript {l = list(x,"a string",y+z)}
}

text {
    === Invoking commands

    Invocation of commands takes a form similar to function calls in C. 
    Function parameters are wrapped in parenthesis and separated by commas.

} shell {
    tscript {
        hex = format("0x%x", 42)
    }
} text {
    The above calls Tcl's built-in `format` command.
    There is no difference between invoking commands implemented in Tcl or
    in TScript via the `tproc` procedure.

    In addition to the obvious syntactic differences, there is a subtle
    point to be noted when invoking commands from TScript as opposed to Tcl.
    In Tcl, a parameter that is not a literal is implicitly dereferenced
    when passed to a command. It is easy to forget this when calling
    Tcl commands that take variable _names_ as parameters.
    Thus the equivalent of the Tcl script
} shell {
    set val 1
    incr val -1
} text {
    is _not_ 
} shell {
    tscript {
        val = 1
        incr(val, -1)
    }
} text {
    which lands up passing the _value_ of `val`, ie. `1`, to the `incr`
    command which then happily decrements the variable called `1`!

    The correct equivalent is
} shell {
    tscript {
        val = 1
        incr("val", -1)
    }
} 

text {
    ==== Calling ensemble commands

    In order to call Tcl ensemble commands such as
} shell {
    clock seconds
} text {
    from TScript, you have two choices.

    You can pass the subcommand `seconds` as the leading argument.
} shell {
    tscript {clock("seconds")}
} text {
    Alternatively, you can use the namespace qualified equivalent
    to which the ensemble command is mapped.
} shell {
    tscript {tcl::clock::seconds()}
}


text {
    ==== Passing options to commands

    When passing options to commands, TScript supports an additional
    syntax for arguments where the option name does not have to be
    quoted.

    Thus instead of invoking the Tcl `subst` command as follows
} shell {
    tscript { subst("-novariables", "The value of val is $val") }
} text {
    it can be invoked as
} shell {
    tscript { subst(-novariables "The value of val is $val") }
} text {
    Note the option name is not quoted and there is no `,` separating
    it from its value.

    TScript recognizes this form based on the argument being composed
    of two expressions with the first one being a token
    starting with a `-` character.
}

text {
    === Operators

    Operators work with two kinds of operands

    * columns and table, and
    * standard Tcl values

    We only discuss the latter here. Operations on columns and tables
    are discussed later.

    Operator precedence follows that of Tcl.

    ==== Arithmetic operators

    The arithmetic operators supported by TScript are based on those in
    Tcl. 

    * The unary operators include `-`, `+`, `~` and `!`.
    * The binary operators include `+`, `-`, `*`, `/`, `**`, `&`, `|`, `^`

    ==== Relational operators
    
    The relational operators include the `==`, `!=`, `<`, +<=+, `>`, `>=`
    operators that are present in Tcl.

    In addition, they include the additional operators related
    to string and pattern matching that are shown in 
    ((^ tab_tscript_match_ops)).
    
    ((.Table tab_tscript_match_ops "TScript arithmetic operators"))
    [cols="10,30,60", options="headers"]
    |===
    |Operator
    |Syntax
    |Description

    |`=^`
    |`_STRINGA_ =^ _STRINGB_`
    |Returns 1 if the two strings are equal in case-insensitive mode, else 0.

    |`!^`
    |`_STRINGA_ =^ _STRINGB_`
    |Returns 1 if the two strings are not equal in case-insensitive mode, else 0.

    |`=~`
    |`_STRING =~ REGEXP_`
    |Returns 1 if the string matches the specified regular expression, else 0.

    |`=~^`
    |`_STRING =~^ REGEXP_`
    |Returns 1 if the string matches the specified regular expression, else 0.
    The matching is done in case-insensitive mode.

    |`!~`
    |`_STRING !~ REGEXP_`
    |Returns 1 if the string does not match the specified regular expression,
    else 0.

    |`!~^`
    |`_STRING !~^ REGEXP_`
    |Returns 1 if the string does not match the specified regular expression,
    else 0. The matching is done in case-insensitive mode.

    |`=*`
    |`_STRING =* PATTERN_`
    |Returns 1 if the string matches the specified pattern, else 0.
    The matching is done as for the Tcl `string match` command.

    |`=*^`
    |`_STRING =*^ PATTERN_`
    |Returns 1 if the string matches the specified pattern, else 0.
    The matching is done as for the `string match` command
    in case-insensitive mode.

    |`!*`
    |`_STRING !* PATTERN_`
    |Returns 1 if the string does not match the specified pattern,
    else 0. The matching is done as for the Tcl `string match` command.

    |`!*^`
    |`_STRING !*^ PATTERN_`
    |Returns 1 if the string does not match the specified pattern,
    else 0. The matching is done as for the `string match` command
    in case-insensitive mode.

    |===

    Note that for the regular expression and pattern match operators,
    the order of the operands is significant - the first indicates 
    the string being matched and the second is the pattern or regular
    expression.

    [TIP]
    In the matching operators shown above, the first character,
    `=` or `!`, indicates the sense of the match, the second character
    sepcifies the operation `~` or `*` and the optional third
    character `^`, if present, indicates a case-sensitive match.
    
    ==== Logical operators

    The logical operators include `&&` and `||` as in Tcl.
    _However, unlike Tcl these operators do not short-circuit the evaluation
    of their operands._

    ==== List operators

    TScript supports the unary operator `#` which returns the length
    of its list operand. This operator also supports columns and tables
    as we will see later.
} shell {
    set l {a b c d e}
    tscript { len = # l }
    tscript { len = # {1,2,3,4} }
}

text {
    == Columns and tables

    We now come to the primary reason for the existence of TScript -
    convenient operation on columns and tables.

    === Indexing

    Much of the convenience of TScript in dealing with columns and tables
    stems from its variety of indexing options. Indices may be simple
    numerics, ranges, lists or selectors based on boolean expressions.

    ==== Integers

    In the simplest case, an index is simply a integer value, specified
    as a literal or an expression that results in a integer value. As
    the operand of the `[]` operator, it retrieves the value of the element
    at that position.
} shell {
    set i 1
    tscript { Rainfall[0] }
    tscript { Emps[i] }
} text {
    Note that the result is a ''scalar'', the value of the element at
    that position, not a column or table containing that element.
} text {
    ==== Index ranges
    
    Alternatively, the index may specify an _index range_
    in the column or table.
    So, the rainfall for the first quarter can be retrieved by
} shell {
    tscript {q1_rainfall = Rainfall[0:2]}
} text {
    In this case the index operator returns a column (or table)
    containing the specified elements. Thus notice the difference
    between
} shell {
    tscript { Rainfall[0] }
    tscript { Rainfall[0:0] }
} text {
    though they both specify a single element.

    Of course, the range can be specified via variables as well.
} shell {
    tscript {
        i = 0
        j = 2
        print(Emps[i:j])
    }
} text {    
    ==== Index list

    The third form of an index is an _index list_. Here you can
    specify a list of integers or a column of type `int` that
    contain the numeric indices of interest.
} shell {
    tscript {
        i = 10
        Rainfall[{9, i, 11}]
    }
} text {
    We could have specified a column of type `int` instead.
} shell {
    set indices [column create int {11 10 9}]
    tscript {Rainfall[indices]}
} text {
    Notice that an index list (or column) does not need to contain
    the indices in order and may even contain duplicate indices.
    The values returned are in the order of specified indices.

    Again, make a note of the difference with respect to a simple
    numeric index
} shell {
    tscript { Rainfall[0] }
} text {
    which returns the element, versus
} shell {
    set indices [column create int {0}]
    tscript { Rainfall[indices] }
} text {
    which returns a column containing that single element.

    ==== Selectors

    The final form an index can take is that of a _selector_ which
    is a boolean expression involving the column or table. As we will
    see when we discuss ((^ sect_tscript_column_ops "column operators"))
    in detail, comparison of a column with a scalar value results
    in an `int` column containing the indices for which the comparison
    of the corresponding element succeeded.
    
    So for example, consider the following expression:
} shell {
    tscript { Rainfall > 100 }
} text {
    The return value is a column containing the indices corresponding
    to the elements which have a value greater than `100`.

    Therefore, we can use such boolean selectors as indices to 
    retrieve the actual values themselves.
} shell {
    tscript { Rainfall[Rainfall > 100] }
} text {
    Selectors can be used for tables as well with the operand being
    a contained column. Moreover, the selector need not be a simple
    boolean expression. The following prints all employees who are
    over 35 but have an income less than `70,000`.
} outputlimit 0 shell {
    tscript {print(Emps[Emps.Age > 35 && Emps.Salary < 70000])}
} tbd {
    Caveats about use of functions in selectors
}

tbd {
    text {
        ==== The [[]] operator

        The `[[]]` operator is used similarly to `[]` except that it
        returns the indices themselves instead of the corresponding values.
        For example, consider the difference between
    } shell {
        tscript { Rainfall[{0, 1, 2}] }
    } text {
        and
    } shell {
        tscript { Rainfall[[{0, 1, 2}]] }
    } text {
        Now this example has zero value since there is no point getting back the
        same list of indices we had in the first place.

        Where the `[[]]` operator finds its use is to convert index selectors
        into the actual indices which can then be passed to other functions.
    } shell {
        tscript { wet_months = Rainfall[[Rainfall > 100]] }
    } text {
        gives the months (as indices) that are considered rainy. This
        data can then be used for other computation.

        As we will see later, the `[[]]` operator is also useful as
        a mechanism for manual optimization since TScript does not currently
        do common subexpression elimination and the like.
    }
}

text {


    ((=== sect_tscript_column_ops "Column Operators"))

} shell {
    tscript { T = table::delete(Emps, Emps.Salary > 70000) }
}

text {


    ==== Slicing Columns from tables
    T.a versus T.(a, b) Illustrate using print

    === Columns and tables as target of assignment
    T.c
    

}
