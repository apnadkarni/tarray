text {
    ((= chap_tscript "The TScript Language"))
    include::header.ad[]

    ((author "Ashok P. Nadkarni"))
}

text {
    == Introduction

    The ((^ chap_intro `tarray`)) Tcl extension implements _typed arrays_,
    which stores data in native format and provides efficient memory
    utilization and parallelized processing. Columns store elements
    of a single type, while tables, similar to data frames in the R
    language, are a ordered sequence of named columns. The `tarray`
    extension provides the corresponding
    ((^ chap_column_ref `column`)) and ((^ chap_table_ref `table`))
    Tcl commands for their manipulation.

    [TIP]
    This document assumes the reader is familiar with typed arrays.
    If not, please glance through the ((^ chap_guide)) before continuing.

    The TScript language is an alternative for 
    working with typed array columns and tables. It provides 
    
    * convenient succint syntax
    * vector operations
    * search operators
    * flexible indexing

    Although geared towards typed arrays, TScript is not limited to
    operating solely on those structures. It can be used with any data.
    Note however, thatTScript is not a replacement for Tcl.
    Rather, it is embedded in
    Tcl and the two can be intermixed according to whatever syntax suits
    the task at hand.

    Neverthess, TScript is syntactically completely different from Tcl.
}

text {
    == Running TScript 

    TScript is part of the `tarray` package which must be loaded to run
    TScript code.
} shell {
    package require tarray
    namespace path tarray;      # Allows use of tarray commands without qualification
} eval {
    source ../src/teval.tcl
} text {
    A TScript code fragment may be run by one of several means.

    First, it can be run from within using the `tarray::tscript` command.
    This is roughly the equivalent of running a Tcl script using `eval`.
} shell {
    tscript { a = 1 }
} text {
    The `tscript` command returns the result of the last statement it
    executes.
    
    Second, you can define a TScript procedure from Tcl using `tarray::tproc` in
    a similar fashion as the Tcl `proc` command. It can then be invoked
    in the same manner as a Tcl procedure.
} shell {
    tproc add {x y} { return x + y }
    add 2 3
} text {
    Finally, you can load an entire TScript file using the
    `tarray::tsource` command

    In this tour, for ease of exposition we will simply show the
    relevant TScript fragments without any reference to how they
    are executed.
}

text {
    ((== sect_tscript_quick_tour "Quick Tour"))

    This section provides a short tour of TScript to
    introduce the reader to the language. 

    The basic syntax of TScript is close to the C family of languages
    than Tcl.

    .Variable and literals
} tscript {
    a = 1 ; b = 2
    c = 1 + a * b
} text {
    Thus unquoted identifiers are variables, not strings, and do not
    need a `$` prefix as in Tcl. Expressions use the usual infix form.
    
    String literals can be expressed in two forms - surrounded by double
    quotes, or with a single preceding single quote for literals that
    only contain alphanumeric characters.
} tscript {
    puts("Two words")
    puts('OneWord)
} text {
    .Calling functions
    
    Commands or functions
    (we use the terms interchangeably) are called with parameters
    enclosed in parenthesis.
} tscript {
    hex = format("0x%x", 42)
} text { 

    .Mixing Tcl and TScript
    Tcl code can be intermixed within TScript by bracketing it with
    `<>`.
} tscript {
    L = {1, 2}
    < lappend L 3 >
    puts(L)

    now = <clock seconds>
} text {
    The Tcl fragment may also be spread across multiple lines.
} tscript {
    <
    puts "First Tcl statement"
    puts "Second Tcl statement"
    >
}

text {
    .Working with lists
    Lists are constructed using braces but unlike in Tcl, elements
    are expressions separated with commas.
} tscript {
    L = {0, a, b, a + b, tcl::mathfunc::rand()}
} text {
    Although you can call Tcl's list related commands, like
} prompt {} tshell {
    llength(L)
} text {
    there are several convenient operators dealing with lists.
    
    The prefix operator `#` can be used to return the length of a list.
} tscript {
    L = {'zero, 'one, 'two, 'three}
    len = # L  // Comments begin with //, not #
} text {
    Similarly, the indexing operator `[]` can be used instead
    of `lindex` and this supports multiple forms.
} prompt {} tshell {
    L[0]  // Single element
    
    L[0:1] // Index range
    
    L[{3,1,2}] // Index list - note order of indices
} text {
   The indexing operator can be used in assignments as well. 
} prompt {} tshell {
    L[0 : #L-2] = 999
    
    L[{3,2}] = {100, 101}
} text {
    Other list operations are performed by calling the corresponding
    Tcl command.
} prompt {} tshell {
    lsort(L)
}

text {
    .Working with dictionaries
    Dictionary access has a similar shorthand using
    using the `#` or `'` postfix operators.
    The difference between the two
    is that the former specifies the key via a variable and
    the latter as a literal.
} prompt {} tshell {
    colors = {"red", 0xff0000, "green", 0x00ff00, "blue", 0x0000ff}
    
    colors'red

    color = "blue"

    colors#color
} text {
    The same syntax can be used to modify the dictionary as well.
} prompt {} tshell {
    colors#color = 0x0000ee
}

text {
    The primary purpose of TScript is really to work conveniently with
    typed arrays - columns and tables - and we demonstrate that next.

    .Working with columns

    A column is created in TScript as
} tscript {
    Rainfall = @double {
        11.0, 23.3, 18.4, 14.7, 70.3, 180.5, 210.2, 205.8, 126.4, 64.9, 33.1, 19.2
    }
} text {
    We can use much the same operators with columns as we used for lists.
} prompt {} tshell {
    # Rainfall           // Size of column

    Rainfall[0]          // Rainfall in January
    
    Rainfall[9:11]       // Rainfall in the last quarter

    Rainfall[11] = 21.5  // Update the measured amount for December
} text {
    When the indexing operation itself returns a column,
    the vector and folding operations available for columns can be 
    used in conjunction.
} prompt {} tshell {
    print( Rainfall / 10 )      // Print rainfall in centimeters

    column.sum(Rainfall[9:11])  // Total rainfall in the last quarter
} tbd {
    Use of ' and # with columns
    (currently numeric literals do not work with ')
}

text {
    One feature that TScript supports for columns that is not available
    for lists is search using boolean expressions. For example,
    we can get the indices corresponding to the months where the
    rainfall lies within a specific range.
} tscript {
    print(Rainfall > 100 && Rainfall < 200)
} text {
    Moreover, since the boolean expressions return an integer column containing
    the element indices, they can be used with in any operation applicable
    to columns. For example, the `#` count operator will return the
    number of such months.
} prompt {} tshell {
    #(Rainfall > 100 && Rainfall < 200) 
} text {
    Or we could use indexing to retrieve the actual values themselves.
} prompt {} tshell {
    print ( Rainfall [Rainfall > 100 && Rainfall < 200] ) 

    print ( Rainfall [@@ > 100 && @@ < 200] )     // @@ specifies the "current" context
}

text {
    .Working with tables

    As for columns, we will use a small sample table
    containing a simple employee data base for demonstration purposes:
} tscript {
    Emps = @table (
        Name string,   Salary uint,   Age uint,   Location string
    ) {
        {'Sally,      70000,      32,       'Boston},
        {'Tom,        65000,      36,       'Boston},
        {'Dick,       80000,      40,       "New York"},
        {'Harry,      45000,      37,       "New York"},
        {'Amanda,     48000,      35,       'Seattle}
    }
    print(Emps)
} text {
    Tables rows can be accessed in the same manner as column elements.
} prompt {} tshell {
    # Emps      // Number of employees

    print(Emps[3])     // Fourth row of table

    print(Emps[2:4])   // Third through fifth rows

    print(Emps[{3,1}]) // Fourth and second row
}

text {
    Columns within a table are accessed with the `'` and `#` operators
    and indexed as usual.
} prompt {} tshell {
    print(Emps'Name)     // Column name supplied as literal

    colname = 'Salary
    print(Emps#colname)   // Column name supplied in a variable

    print(Emps'Salary[@@ >= 70000])    // High salaries
} text {
    Table slice operators can be used extract subtables.
} prompt {} tshell {
    print(Emps'(Name, Location))

    print(Emps'(Name, Location)[2:4])
}
text {
    As for columns, boolean expression can be used to query tables.
} outputlimit 0 prompt {} tshell {
    print(Emps[Emps'Salary > 50000 && Emps'Location != "New York"])

    print(Emps[Emps'Salary > 50000 && Emps'Location != "New York"] ' (Name, Age))
} text {
    Tables can be modified in multiple ways.
} outputlimit 0 tscript {
    Emps[# Emps] = {'Mary, 38000, 25, 'Seattle}   // Add a row

    Emps'Salary = Emps'Salary + 2000;    // Modify all cells in a column

    Emps'Location[Emps'Name'Sally] = {{"New York"}}  // Modify a single cell

    print(Emps)
}

text {
    ((== sect_basic_tscript_syntax "Basic syntax"))

    The basic syntax of TScript is closer to the C family of languages
    than to Tcl.

    === Statements

    Like Tcl, a TScript script is a sequence of statements separated
    by either a newline character or a semicolon.
} tscript {
    x = 2
    y = 3 ; z = x*y
} text {
    A statement may be an assignment as above, or simply an expression:
} tscript {10*x + y}

text {
    === Mixing Tcl and TScript

    Tcl and TScript code can be intermixed. To embed TScript within
    Tcl, use the `tarray::tscript` command as
} syntax {
    tscript _TSCRIPT_
} text {
    where _TSCRIPT_ is the TScript fragment which may be spread across
    multiple lines.
} shell {
    tscript { x = 2 }
    tscript {
        y = 3
        z = x * y
    }
} text {
    Conversely, Tcl can be embedded with TScript by placing the
    Tcl script within `<` and `>` delimiters.
} prompt {} tshell {
    now = <clock seconds>
} text {
    Multi-line scripts are permitted.
} tscript {
    <
        set x 2
        set y 3
        set z [expr {$x + $y}]
    >
} text {
    The terminating `>` _must_ be followed by a TScript statement terminator
    such as a newline or `;`, optionally with intervening whitespace.

    [NOTE]
    Embedded Tcl is not an expression and thus cannot be used as
    part of an expression.
}

text {
    === Comments

    Comments begin with the `//` sequence and extend to the end of the line.
}

text {
    === Variables

    As seen above, variables are syntactically different from Tcl:

    * There is no preceding `$` as in Tcl for accessing a variable's value.
    * Variable names are restricted to starting with an alphabetic
    character and may only contain alphanumeric characters, `_` and
    `:`.

    The variables themselves are standard Tcl variables and follow
    the same name resolution rules.
} shell {
    set v "This is a variable"
    tscript { v = "Modified from tscript" }
    puts $v
}

text {    
    === Literals

    Numeric literals are as in Tcl and have the same syntax as in Tcl.
    For example,
} prompt {} tshell {
    r = 2.0e10
    big = 123455678987654321000000000
} text {

    String literals are delimited by double quotes and follow
    the backslash substitution rules as in Tcl.

    Unlike in Tcl, _a plain unquoted string is treated as an identifier_ and
    not a string literal.
} errorok 1 prompt {} tshell {
    s = unquoted
} text {
    Also, unlike in Tcl double quoted strings, there is no
    interpolation.
} text {
    [WARNING]
    Also note that braces have different semantics in TScript and
    cannot be used to delimit strings.
} text {
    An alternate form of a string literal is a `'` character preceding
    a string that follows the rules for an identifier.
} tscript { s = 'this::is::a::string } text {
    This alternate form is merely a small convenience.
}

text {
    === Lists

    Braces in TScript are used to construct lists, similar to the
    `list` command in Tcl. _Note this differs from the use of braces in Tcl._
} tscript {
    l = {"a string", x, tcl::clock::seconds(), y+z}
} text {
    The list elements are separated using commas and an element may
    be a literal, variable, function call or general expression.
    The list elements may be spread across multiple lines but must still
    be separated by commas.
} tscript {
    l = {
        x,
        "a string",
        y+z
    }
} text {
    As an aside, we could also have invoked the Tcl `list` command
    as a function to construct a list.
} tscript {l = list(x,"a string",y+z)}

text {
    == Functions

    Functions in TScript may refer to either Tcl commands or to functions
    defined through the TScript `tproc` function.
    
    === Invoking functions
    Invocation of functions/commands takes a form similar to function
    calls in C. 
    Function parameters are wrapped in parenthesis and separated by commas.

} tscript {
        hex = format("0x%x", 42)
} text {
    The above calls Tcl's built-in `format` command.
    There is no difference between invoking commands implemented in Tcl or
    in TScript via the `tproc` procedure.

    [WARNING]
    ====
    There is a subtle
    point to be noted when invoking commands from TScript as opposed to Tcl.
    In TScript, a parameter that is not a literal is implicitly dereferenced
    when passed to a command. It is easy to forget this when calling
    Tcl commands that take variable _names_ as parameters.
    Thus 
    ----
    incr val -1
    ----
    is _not_ 
    ----
    tscript { incr(val, -1) }
    ----
    which lands up passing the _value_ of `val` to the `incr`
    command which actually expects the name `val` itself to be the argument.

    The correct equivalents are either of the following:
    ----
    tscript { incr("val", -1) }
    tscript { incr('val, -1) }
    ----
    ====
} text {
    As for list elements, the parameters for a function call may be
    spread across multiple lines.
} tscript {
    hex = format("0x%x",
                 42)
}

text {
    ==== Calling ensemble commands

    Ensemble commands such as `clock seconds` are called from TScript as
} prompt {} tshell {
    clock.seconds()
} text {
    Note the use of `.` as the separator between the command and its
    subcommand. Depending on how the ensemble is defined, you can
    also directly invoke it.
} prompt {} tshell {
    tcl::clock::seconds()
} text {
    Finally, in the very rare case that the ensemble subcommand does
    not fit the syntax for a TScript identifier, you can pass it as the
    first argument.
} prompt {} tshell {
    clock("seconds")
}

text {
    ==== Calling object methods

    Object methods are called in a manner similar to ensemble commands.
} shell {
    oo::class create OExample { method m args {puts [join $args ,]} }
    OExample create o
    tscript {
        o.m('astring, 10)
        o.destroy()
    }
} text {
    However, there is an additional case here where the name of the
    object is not fixed and the object is accessed through a variable.
} errorok 1 shell {
    set obj [OExample new]
    tscript {obj.m('astring, 10)}
} text {
    _Function and object names, unlike variables, do not get implicitly
    dereferenced._
    In this case, the `$` operator is used for dereferencing.
} prompt {} tshell {
    $obj.m('astring, 10)
    $obj.destroy()
} text {
    We will talk about the dereferencing operator
    ((^ sect_tscript_deref_op later)).
}

text {
    ==== Passing options to commands

    When passing options to commands, TScript supports an additional
    syntax for arguments where the option name does not have to be
    quoted or separated from its value by a `,`.

    Instead of invoking the Tcl `subst` command as follows
} tscript { subst("-novariables", "The value of val is $val") } text {
    it can be invoked as
} tscript { subst(-novariables "The value of val is $val") } text {
    Note the option name is not quoted and there is no `,` separating
    it from its value.

    TScript recognizes this form based on the argument being composed
    of two expressions with the first one being a token
    starting with a `-` character.
}

text {
    === Defining functions

    The `tproc` command has the same form as
    the Tcl `proc` command except that the body of the procedure
    is TScript instead of Tcl.
} syntax {
    tproc _NAME_ _ARGS_ _BODY_
} text {
    _ARGS_ takes the same form as in the `proc` command, including defaults
    for parameter and variable parameters using the `args` notation.
} shell {
    tproc add {a b} {return a + b}
} text {
    [NOTE]
    The `tproc` command is meant to be called from Tcl as opposed
    to being used within TScript itself. 
}

text {
    === The `return` statement
    The TclScript `return` statement returns control to the caller
    from a function or procedure.
} syntax {
    return _EXPRESSION_
} text {
    _EXPRESSION_ is any valid TScript expression.
}

text {
    == Control statements

    TScript implements the `if`, `while` and `for` statements similar to Tcl
    but in a slightly different form.

    === The `if` statement
    The `if` statement has the syntax
} syntax {
    if _EXPRESSION_ { _STATEMENTBLOCK_ } ?else { _STATEMENTBLOCK_ }?
} text {
    As indicated, the `else` clause is optional. If present, it must
    be on the same logical line as the preceding statement block.

    _EXPRESSION_ can be any TScript expression and does not need
    to be enclosed in parenthesis.
} tscript {
    if #Emps {
        print(Emps)
    } else {
        puts("Table is empty")
    }
}

text {
    === The `while` statement
    The `while` statement has the syntax
} syntax {
    while _EXPRESSION_ { _STATEMENTBLOCK_ }
} text {
    _EXPRESSION_ can be any TScript expression and does not need
    to be enclosed in parenthesis.
} outputlimit 3 tscript {
    i = 0
    while i < # Emps {
        puts(Emps'Name[i])
        i = i + 1
    }
}

text {
    === The `for` statement
    The `for` statement takes one of two forms. The first form is
    used to iterate over a range of integers.
} syntax {
    for _IDENTIFIER_ in _LOWEXPR_ : _HIGHEXPR_ ?by _INCREMENT_? _STATEMENTBLOCK_
} text {
    The loop variable _IDENTIFIER_ is initially assigned a value of
    _LOWEXPR_. Thereafter, _STATEMENTBLOCK_ is executed as long as the
    the value of the loop variable is less than or equal to _HIGHEXPR_. After
    each iteration, the loop variable is incremented by _INCREMENT_ which
    defaults to `1` if unspecified.
} tscript {
    for i in 0 : #Emps-1 by 2 {
        puts(Emps'Name[i])
    }
} text {
    The limits of the range are computed only once, before the loop is
    iterated.
}

text {
    The other form of the `for` statement behaves similar to the
    Tcl `foreach` statement where the loop variable takes on values
    from a collection. The syntax is 
} syntax {
    for _IDENTIFIER_ in _COLLECTION_ _STATEMENTBLOCK_
} text {
    where _COLLECTION_ is any TScript expression that results
    in a column, table or a Tcl list.
} outputlimit 3 tscript {
    for rainfall in Rainfall[Rainfall > 100] {
        puts(rainfall)
    }
}

text {
    === The `break` statement
    The `break` statement behaves like the Tcl `break` command. It
    causes the innermost loop to stop execution and continue execution
    at the following statement.
} syntax {
    break
}

text {
    === The `continue` statement
    The `continue` statement behaves like the Tcl `continue` command. It
    aborts the current iteration of the innermost loop containing it
    without aborting the loop itself which then proceeds with its next
    iteration.
} syntax {
    continue
}

text {
    == Operators

    Operators work with two kinds of operands

    * standard Tcl values
    * columns and table, and

    We only discuss the former here. Operations on columns and tables
    are discussed later. Note that neither of the Tcl operators
    and the TScript operators is a subset of the other.

    Operator precedence follows that of Tcl.

    === Arithmetic operators

    The arithmetic operators supported by TScript are based on those in
    Tcl. 

    * The unary operators include `-`, `+`, `~` and `!`.
    * The binary operators include `+`, `-`, `*`, `/`, `**`, `&`, `|`, `^`

    === Relational operators
    
    The relational operators include the `==`, `!=`, `<`, +<=+, `>`, `>=`
    operators that are present in Tcl.

    In addition, they include the additional operators related
    to string and pattern matching that are shown in 
    ((^ tab_tscript_match_ops)).
    
    ((.Table tab_tscript_match_ops "TScript arithmetic operators"))
    [cols="10,30,60", options="headers"]
    |===
    |Operator
    |Syntax
    |Description

    |`=^`
    |`_STRINGA_ =^ _STRINGB_`
    |Returns 1 if the two strings are equal in case-insensitive mode, else 0.

    |`!^`
    |`_STRINGA_ =^ _STRINGB_`
    |Returns 1 if the two strings are not equal in case-insensitive mode, else 0.

    |`=~`
    |`_STRING =~ REGEXP_`
    |Returns 1 if the string matches the specified regular expression, else 0.

    |`=~^`
    |`_STRING =~^ REGEXP_`
    |Returns 1 if the string matches the specified regular expression, else 0.
    The matching is done in case-insensitive mode.

    |`!~`
    |`_STRING !~ REGEXP_`
    |Returns 1 if the string does not match the specified regular expression,
    else 0.

    |`!~^`
    |`_STRING !~^ REGEXP_`
    |Returns 1 if the string does not match the specified regular expression,
    else 0. The matching is done in case-insensitive mode.

    |`=*`
    |`_STRING =* PATTERN_`
    |Returns 1 if the string matches the specified pattern, else 0.
    The matching is done as for the Tcl `string match` command.

    |`=*^`
    |`_STRING =*^ PATTERN_`
    |Returns 1 if the string matches the specified pattern, else 0.
    The matching is done as for the `string match` command
    in case-insensitive mode.

    |`!*`
    |`_STRING !* PATTERN_`
    |Returns 1 if the string does not match the specified pattern,
    else 0. The matching is done as for the Tcl `string match` command.

    |`!*^`
    |`_STRING !*^ PATTERN_`
    |Returns 1 if the string does not match the specified pattern,
    else 0. The matching is done as for the `string match` command
    in case-insensitive mode.

    |===

    Note that for the regular expression and pattern match operators,
    the order of the operands is significant - the first indicates 
    the string being matched and the second is the pattern or regular
    expression.

    [TIP]
    In the matching operators shown above, the first character,
    `=` or `!`, indicates the sense of the match, the second character
    sepcifies the operation `~` or `*` and the optional third
    character `^`, if present, indicates a case-sensitive match.
    
    === Logical operators

    The logical operators include `&&` and `||` as in Tcl.
    _However, unlike Tcl these operators do not short-circuit the evaluation
    of their operands._

    === List operators

    ==== The unary `#` operator for lists

    TScript supports the unary operator `#` which returns the length
    of its list operand. This operator also supports columns and tables
    as we will see later.
} prompt {} tshell {
    l = {'a, 'b, 'c, 'd, 'e}
    len = # l
    len = # {1,2,3,4}
}

text {
    === Dictionary operators

    ==== The `#` and `'` dictionary operators

    The `#` and `'` operators both retrieve values from Tcl dictionaries.
    The `'` operator takes the key as a literal value and returns
    the corresponding element from the dictionary.
} prompt {} tshell {
    d = <dict create a 1 b 2 c 3 d 4> 
    d'c
    d ' c             // Note whitespace is optional
} text {
    On the other hand, the `#` operator takes an operand that
    is the _name of the variable_ containing the key.
} prompt {} tshell {
    key = 'c
    d#key
    d # key           // Note whitespace is optional
} 

tbd {
    === The `$` dereferencing operator
}

text {
    == Columns and tables

    We now come to the primary reason for the existence of TScript -
    convenient vector operations on columns and tables.

} text {
    === Creating columns

    Columns are created using the built-in operators `@boolean`,
    `@byte`, `@int`, `@uint`, `@wide`, `@double`, `@string` and `@any`.
    The syntax of the command is
} syntax {
    @__TYPE__ ?_INITLIST_?
} text {
    where _TYPE_ is one of the tarray column types and _INITLIST_ is
    an optional initializer list. For example,
} tscript { A = @int } text {
    creates an empty column of type `int` and assigns it to `A` and
} tscript { A = @any {10, {1, 2, 3}, len} } text {
    creates a column of type `any` with 3 elements.
}

text {
    === Creating tables
    Tables are defined and created using the @table built-in operator.
    The syntax for the command is
} syntax {
    @table(?_COLNAME_ _TYPE_?, ...) ?_TABLEROWS_?
} text {
    where _COLNAME_ is the name of the column and _TYPE_ is one
    of the tarray column types. _TABLEROWS_ may be specified
    to initialize the table and should be a list of rows as
    for the `tarray::table create` command. Here is the table
    definition from our ((^ sect_tscript_quick_tour)) section.
    
} syntax {
    Emps = @table (
        Name string,   Salary uint,   Age uint,   Location string
    ) {
        {'Sally,      70000,      32,       'Boston},
        {'Tom,        65000,      36,       'Boston},
        {'Dick,       80000,      40,       "New York"},
        {'Harry,      45000,      37,       "New York"},
        {'Amanda,     48000,      35,       'Seattle}
    }
} text {
    [TIP]
    ====
    In many cases, you may find it easier to use Tcl, either directly
    or embedded, to create tables. For example, the above table
    can be created with embedded Tcl as
} tscript {
    Emps = <
      table create {
        Name string   Salary uint    Age uint    Location string
      } {
        {Sally        70000          32          Boston}
        {Tom          65000          36          Boston}
        {Dick         80000          40          "New York"}
        {Harry        45000          37          "New York"}
        {Amanda       48000          35          Seattle}
      }
    >
} text {
    ====
}

text {
    === Indexing and search

    Much of the convenience of TScript in dealing with columns and tables
    stems from its variety of indexing options. Indices may be simple
    numerics, ranges, lists or selectors based on boolean expressions.

    The flexibility of index selectors also means that they are the primary
    means of searching tables and columns for elements matching desired
    criteria.

    ==== Integers

    In the simplest case, an index is simply a integer value, specified
    as a literal or an expression that results in a integer value. As
    the operand of the `[]` operator, it retrieves the value of the element
    at that position.
} prompt {} tshell {
    i = 1
    Rainfall[0]
    Emps[i]
} text {
    Note that the result is a ''scalar'', the value of the element at
    that position, not a column or table containing that element.
} text {
    ==== Index ranges
    
    Alternatively, the index may specify an _index range_
    in the column or table.
    So, the rainfall for the first quarter can be retrieved by
} tscript {q1_rainfall = Rainfall[0:2]} text {
    In this case the index operator returns a column (or table)
    containing the specified elements. Thus notice the difference
    between
} tscript { Rainfall[0] } text {
    and
} tscript { Rainfall[0:0] } text {
    though they both specify a single element.

    Of course, the range can be specified via variables as well.
} tscript {
    i = 0
    j = 2
    print(Emps[i:j])
} text {
    We shall also see later that ranges can also be combined with
    selectors to further focus search and indexing operations.
} text {    
    ==== Index list

    The third form of an index is an _index list_. Here you can
    specify a list of integers or a column of type `int` that
    contain the numeric indices of interest.
} tscript {
    i = 10
    Rainfall[{9, i, 11}]
} text {
    We could have specified a column of type `int` instead.
} tscript {
    indices = @int {11, 10, 9}
    Rainfall[indices]
} text {
    Notice that an index list (or column) does not need to contain
    the indices in order and may even contain duplicate indices.
    The values returned are in the order of specified indices.

    Again, make a note of the difference with respect to a simple
    numeric index
} tscript { Rainfall[0] } text {
    which returns the element, versus
} tscript {
    Rainfall[@int {0}] 
} text {
    which returns a column containing that single element.

    ==== Selectors

    The final form an index can take is that of a _selector_ which
    is a boolean expression involving the column or table. We will
    detail the mechanism by which this works 
    when we discuss ((^ sect_tscript_column_ops "column operators"))
    but in a nutshell, comparison of a column with a scalar value results
    in an `int` column containing the indices for which the comparison
    of the corresponding element succeeded.
    
    So for example, consider the following expression:
} tscript { Rainfall > 100 } text {
    The return value is a column containing the indices corresponding
    to the elements which have a value greater than `100`.

    Therefore, we can use such boolean selectors as indices to 
    retrieve the actual values themselves.
} tscript { Rainfall[Rainfall > 100] } text {
    Selectors can be used for tables as well with the operand being
    a contained column. Moreover, the selector need not be a simple
    boolean expression. The following prints all employees who are
    over 35 but have an income less than `70,000`.
} outputlimit 0 tscript {
    print(Emps[Emps'Age > 35 && Emps'Salary < 70000]) 
} text {
    [NOTE]
    The syntax for referencing a table column using `'` is discussed
    ((^ sect_tscript_table_column_ops later)).

    ===== Ranges in selectors

    Selectors can include ranges as well.
    For example, the rainfall in the last quarter that
    exceeds 50mm is given by
} tscript { Rainfall[9:11 && Rainfall > 50] } text {
    [WARNING]
    A selector can include function calls as well. However, note
    that the function is called just once, not once per element
    of the column or table.

    Because of their flexibility, selectors are the mechanism
    for doing searches in columns and tables.
} text {
    ===== The `@@` selector context

    In previous examples, we supplied the variable containing the table
    or column, for example `Emps`, to the selector expression. In some
    cases, the table or column may not stored in a variable, for example
    when it is a function return value or when it is generated through
    an expression. In this case the `@@` special token may be used to
    reference the table instead of storing the generated value in
    a temporary for naming purposes. This is illustrated in the
    following example.
} shell {
    proc get_table {} { return $::Emps }
    tscript { print( get_table() [@@'Age > 35 && @@'Salary < 70000]) }
}



text {
    ((=== sect_tscript_column_ops "Column and table operators"))

    ==== Arithmetic operators

    As described in the ((^ column_math "math command")) reference,
    normal scalar Tcl values and columns can be mixed in mathematical
    operations. The scalar values are treated as columns filled
    with that value. Here is an example:
} tscript {
        I = @int {10, 20, 30, 40}
        J = @byte {1, 2, 3, 4}
        print(I + 2 * J)
} text {
    TScript supports all the arithmetic operators shown in
    ((^ tab_column_math_ops)).
    
    Tables do not support
    any arithmetic operators but their contained columns can be used anywhere
    that a standalone column is valid.

    For example, we can reduce everyone's salaries by 2K since times
    are tough.
} outputlimit 0 tscript {
    Emps'Salary = Emps'Salary - 2000
    print (Emps)
} text {
    Or perhaps even more for highly paid employees.
} outputlimit 0 tscript {
    Emps'Salary[Emps'Salary > 65000] = Emps'Salary[@@ > 65000] - 2000;
    print (Emps)
} text {


    ==== Relational operators

    ==== The `#` count unary operator

    ==== The `'` and '#' operators for columns and tables

    ===== Specifying table columns

    ===== Locating column elements

} shell {
    tscript { T = table::delete(Emps, Emps'Salary > 70000) }
}

text {


    ==== Slicing Columns from tables
    T.a versus T.(a, b) Illustrate using print

    Column tables can be used anywhere columns are used including assignments

    === Columns and tables as target of assignment
    T.c
    

}

tbd { sum, minmax, sort etc.}
tbd { namespace and execution context }
