text {
    ((= chap_tscript "The TScript Language"))
    include::header.ad[]

    ((author "Ashok P. Nadkarni"))
}

text {
    == Introduction

    The ((^ chap_intro `tarray`)) Tcl extension implements _typed arrays_,
    which stores data in native format and provides efficient memory
    utilization and parallelized processing. Columns store elements
    of a single type, while tables, similar to data frames in the R
    language, are a ordered sequence of named columns. The `tarray`
    extension provides the corresponding
    ((^ chap_column_ref `column`)) and ((^ chap_table_ref `table`))
    Tcl commands for their manipulation.

    [TIP]
    This document assumes the reader is familiar with typed arrays.
    If not, please glance through the ((^ chap_guide)) before continuing.

    The TScript language is an alternative for 
    working with typed array columns and tables. It provides 
    
    * convenient succint syntax
    * vector operations
    * search operators
    * flexible indexing

    Although geared towards typed arrays, TScript is not limited to
    operating solely on those structures. It can be used with any data.
    Note however, thatTScript is not a replacement for Tcl.
    Rather, it is embedded in
    Tcl and the two can be intermixed according to whatever syntax suits
    the task at hand.

    Neverthess, TScript is syntactically completely different from Tcl.
}

text {
    == Running TScript 

    TScript is part of the `tarray` package which must be loaded to run
    TScript code.
} shell {
    package require tarray
    namespace path tarray;      # Allows use of tarray commands without qualification
} eval {
    source ../src/teval.tcl
} text {
    A TScript code fragment may be run by one of several means.

    First, it can be run from within using the `tarray::tscript` command.
    This is roughly the equivalent of running a Tcl script using `eval`.
} shell {
    tscript { a = 1 }
} text {
    The `tscript` command returns the result of the last statement it
    executes.
    
    Second, you can define a TScript procedure from Tcl using `tarray::tproc` in
    a similar fashion as the Tcl `proc` command. It can then be invoked
    in the same manner as a Tcl procedure.
} shell {
    tproc add {x y} { return x + y }
    add 2 3
} text {
    Finally, you can load an entire TScript file using the
    `tarray::tsource` command

    In this tour, for ease of exposition we will simply show the
    relevant TScript fragments without any reference to how they
    are executed.
}

text {
    ((== sect_tscript_quick_tour "Quick Tour"))

    This section provides a short tour of TScript to
    introduce the reader to the language. 

    The basic syntax of TScript is close to the C family of languages
    than Tcl.

    .Variable and literals
} tscript {
    a = 1 ; b = 2
    c = 1 + a * b
} text {
    Thus unquoted identifiers are variables, not strings, and do not
    need a `$` prefix as in Tcl. Expressions use the usual infix form.
    
    String literals can be expressed in two forms - surrounded by double
    quotes, or with a single preceding single quote for literals that
    only contain alphanumeric characters.
} tscript {
    puts("Two words")
    puts('OneWord)
} text {
    .Calling functions
    
    Commands or functions
    (we use the terms interchangeably) are called with parameters
    enclosed in parenthesis.
} tscript {
    hex = format("0x%x", 42)
} text { 

    .Mixing Tcl and TScript
    Tcl code can be intermixed within TScript by bracketing it with
    `<>`.
} tscript {
    L = {1, 2}
    < lappend L 3 >
    puts(L)

    now = <clock seconds>
} text {
    The Tcl fragment may also be spread across multiple lines.
} tscript {
    <
    puts "First Tcl statement"
    puts "Second Tcl statement"
    >
}

text {
    .Working with lists
    Lists are constructed using braces but unlike in Tcl, elements
    are expressions separated with commas.
} tscript {
    L = {0, a, b, a + b, tcl::mathfunc::rand()}
} text {
    Although you can call Tcl's list related commands, like
} prompt {} tshell {
    llength(L)
} text {
    there are several convenient operators dealing with lists.
    
    The prefix operator `#` can be used to return the length of a list.
} tscript {
    L = {'zero, 'one, 'two, 'three}
    len = # L  // Comments begin with //, not #
} text {
    Similarly, the indexing operator `[]` can be used instead
    of `lindex` and this supports multiple forms.
} prompt {} tshell {
    L[0]  // Single element
    
    L[0:1] // Index range
    
    L[{3,1,2}] // Index list - note order of indices
} text {
   The indexing operator can be used in assignments as well. 
} prompt {} tshell {
    L[0 : #L-2] = 999
    
    L[{3,2}] = {100, 101}
} text {
    Other list operations are performed by calling the corresponding
    Tcl command.
} prompt {} tshell {
    lsort(L)
}

text {
    .Working with dictionaries
    Dictionary access has a similar shorthand using
    using the `#` or `'` postfix operators.
    The difference between the two
    is that the former specifies the key via a variable and
    the latter as a literal.
} prompt {} tshell {
    colors = {"red", 0xff0000, "green", 0x00ff00, "blue", 0x0000ff}
    
    colors'red

    color = "blue"

    colors#color
} text {
    The same syntax can be used to modify the dictionary as well.
} prompt {} tshell {
    colors#color = 0x0000ee
}

text {
    The primary purpose of TScript is really to work conveniently with
    typed arrays - columns and tables - and we demonstrate that next.

    .Working with columns

    A column is created in TScript as
} tscript {
    Rainfall = @double {
        11.0, 23.3, 18.4, 14.7, 70.3, 180.5, 210.2, 205.8, 126.4, 64.9, 33.1, 19.2
    }
} text {
    We can use much the same operators with columns as we used for lists.
} prompt {} tshell {
    # Rainfall           // Size of column

    Rainfall[0]          // Rainfall in January
    
    Rainfall[9:11]       // Rainfall in the last quarter

    Rainfall[11] = 21.5  // Update the measured amount for December
} text {
    When the indexing operation itself returns a column,
    the vector and folding operations available for columns can be 
    used in conjunction.
} prompt {} tshell {
    print( Rainfall / 10 )      // Print rainfall in centimeters

    column.sum(Rainfall[9:11])  // Total rainfall in the last quarter
} tbd {
    Use of ' and # with columns
    (currently numeric literals do not work with ')
}

text {
    One feature that TScript supports for columns that is not available
    for lists is search using boolean expressions. For example,
    we can get the indices corresponding to the months where the
    rainfall lies within a specific range.
} tscript {
    print(Rainfall > 100 && Rainfall < 200)
} text {
    Moreover, since the boolean expressions return an integer column containing
    the element indices, they can be used with in any operation applicable
    to columns. For example, the `#` count operator will return the
    number of such months.
} prompt {} tshell {
    #(Rainfall > 100 && Rainfall < 200) 
} text {
    Or we could use indexing to retrieve the actual values themselves.
} prompt {} tshell {
    print ( Rainfall [Rainfall > 100 && Rainfall < 200] ) 

    print ( Rainfall [@@ > 100 && @@ < 200] )     // @@ specifies the "current" context
}

text {
    .Working with tables

    As for columns, we will use a small sample table
    containing a simple employee data base for demonstration purposes:
} tscript {
    Emps = @table (
        Name string,   Salary uint,   Age uint,   Location string
    ) {
        {'Sally,      70000,      32,       'Boston},
        {'Tom,        65000,      36,       'Boston},
        {'Dick,       80000,      40,       "New York"},
        {'Harry,      45000,      37,       "New York"},
        {'Amanda,     48000,      35,       'Seattle}
    }
    print(Emps)
} text {
    Tables rows can be accessed in the same manner as column elements.
} prompt {} tshell {
    # Emps      // Number of employees

    print(Emps[3])     // Fourth row of table

    print(Emps[2:4])   // Third through fifth rows

    print(Emps[{3,1}]) // Fourth and second row
}

text {
    Columns within a table are accessed with the `'` and `#` operators
    and indexed as usual.
} prompt {} tshell {
    print(Emps'Name)     // Column name supplied as literal

    colname = 'Salary
    print(Emps#colname)   // Column name supplied in a variable

    print(Emps'Salary[@@ >= 70000])    // High salaries
} text {
    Table slice operators can be used extract subtables.
} prompt {} tshell {
    print(Emps'(Name, Location))

    print(Emps'(Name, Location)[2:4])
}
text {
    As for columns, boolean expression can be used to query tables.
} outputlimit 0 prompt {} tshell {
    print(Emps[Emps'Salary > 50000 && Emps'Location != "New York"])

    print(Emps[Emps'Salary > 50000 && Emps'Location != "New York"] ' (Name, Age))
} text {
    Tables can be modified in multiple ways.
} outputlimit 0 tscript {
    Emps[# Emps] = {'Mary, 38000, 25, 'Seattle}      // Add a row

    Emps'Salary = Emps'Salary + 2000                 // Modify entire column

    Emps'Location[Emps'Name'Sally] = {{"New York"}}  // Modify a single cell

    print(Emps)
}

text {
    ((== sect_basic_tscript_syntax "Basic syntax"))

    The basic syntax of TScript is closer to the C family of languages
    than to Tcl.

    === Statements

    Like Tcl, a TScript script is a sequence of statements separated
    by either a newline character or a semicolon.
} tscript {
    x = 2
    y = 3 ; z = x*y
} text {
    A statement may be an assignment as above, or simply an expression:
} tscript {10*x + y}

text {
    === Mixing Tcl and TScript

    Tcl and TScript code can be intermixed. To embed TScript within
    Tcl, use the `tarray::tscript` command as
} syntax {
    tscript _TSCRIPT_
} text {
    where _TSCRIPT_ is the TScript fragment which may be spread across
    multiple lines.
} shell {
    tscript { x = 2 }
    tscript {
        y = 3
        z = x * y
    }
} text {
    Conversely, Tcl can be embedded with TScript by placing the
    Tcl script within `<` and `>` delimiters.
} prompt {} tshell {
    now = <clock seconds>
} text {
    Multi-line scripts are permitted.
} tscript {
    <
        set x 2
        set y 3
        set z [expr {$x + $y}]
    >
} text {
    The terminating `>` _must_ be followed by a TScript statement terminator
    such as a newline or `;`, optionally with intervening whitespace.

    [NOTE]
    Embedded Tcl is not an expression and thus cannot be used as
    part of an expression.
}

text {
    === Comments

    Comments begin with the `//` sequence and extend to the end of the line.
}

text {
    === Variables

    As seen above, variables are syntactically different from Tcl:

    * There is no preceding `$` as in Tcl for accessing a variable's value.
    * Variable names are restricted to starting with an alphabetic
    character and may only contain alphanumeric characters, `_` and
    `:`.

    The variables themselves are standard Tcl variables and follow
    the same name resolution rules.
} shell {
    set v "This is a variable"
    tscript { v = "Modified from tscript" }
    puts $v
}

text {    
    === Literals

    Numeric literals are as in Tcl and have the same syntax as in Tcl.
    For example,
} prompt {} tshell {
    r = 2.0e10
    big = 123455678987654321000000000
} text {

    String literals are delimited by double quotes and follow
    the backslash substitution rules as in Tcl.

    Unlike in Tcl, _a plain unquoted string is treated as an identifier_ and
    not a string literal.
} errorok 1 prompt {} tshell {
    s = unquoted
} text {
    Also, unlike in Tcl double quoted strings, there is no
    interpolation.
} text {
    [WARNING]
    Also note that braces have different semantics in TScript and
    cannot be used to delimit strings.
} text {
    An alternate form of a string literal is a `'` character preceding
    a string that follows the rules for an identifier.
} tscript { s = 'this::is::a::string } text {
    This alternate form is merely a small convenience.
}

text {
    === Lists

    Braces in TScript are used to construct lists, similar to the
    `list` command in Tcl. _Note this differs from the use of braces in Tcl._
} tscript {
    l = {"a string", x, tcl::clock::seconds(), y+z}
} text {
    The list elements are separated using commas and an element may
    be a literal, variable, function call or general expression.
    The list elements may be spread across multiple lines but must still
    be separated by commas.
} tscript {
    l = {
        x,
        "a string",
        y+z
    }
} text {
    As an aside, we could also have invoked the Tcl `list` command
    as a function to construct a list.
} tscript {l = list(x,"a string",y+z)}

text {
    == Functions

    Functions in TScript may refer to either Tcl commands or to functions
    defined through the TScript `tproc` function.
    
    === Invoking functions
    Invocation of functions/commands takes a form similar to function
    calls in C. 
    Function parameters are wrapped in parenthesis and separated by commas.

} tscript {
        hex = format("0x%x", 42)
} text {
    The above calls Tcl's built-in `format` command.
    There is no difference between invoking commands implemented in Tcl or
    in TScript via the `tproc` procedure.

    [WARNING]
    ====
    There is a subtle
    point to be noted when invoking commands from TScript as opposed to Tcl.
    In TScript, a parameter that is not a literal is implicitly dereferenced
    when passed to a command. It is easy to forget this when calling
    Tcl commands that take variable _names_ as parameters.
    Thus 
    ----
    incr val -1
    ----
    is _not_ 
    ----
    tscript { incr(val, -1) }
    ----
    which lands up passing the _value_ of `val` to the `incr`
    command which actually expects the name `val` itself to be the argument.

    The correct equivalents are either of the following:
    ----
    tscript { incr("val", -1) }
    tscript { incr('val, -1) }
    ----
    ====
} text {
    As for list elements, the parameters for a function call may be
    spread across multiple lines.
} tscript {
    hex = format("0x%x",
                 42)
} text {
    The function called need not be an identifier; it can be supplied
    as any expression, for example a function call that returns a function
    name.
} prompt {} tshell {
    < proc function_returning_function {} {return puts} >
    function_returning_function () ("Hello there!")
}

text {
    ==== Calling ensemble commands

    Ensemble commands such as `clock seconds` are called from TScript as
} prompt {} tshell {
    clock.seconds()
} text {
    Note the use of `.` as the separator between the command and its
    subcommand. Depending on how the ensemble is defined, you can
    also directly invoke it.
} prompt {} tshell {
    tcl::clock::seconds()
} text {
    Finally, in the very rare case that the ensemble subcommand does
    not fit the syntax for a TScript identifier, you can pass it as the
    first argument.
} prompt {} tshell {
    clock("seconds")
}

text {
    ((==== sect_tscript_calling_methods "Calling object methods"))

    Object methods are called in a manner similar to ensemble commands.
} shell {
    oo::class create OExample { method m args {puts [join $args ,]} }
    OExample create o
    tscript {
        o.m('astring, 10)
        o.destroy()
    }
} text {
    However, there is an additional case here where the name of the
    object is not fixed and the object is accessed through a variable.
} errorok 1 shell {
    set obj [OExample new]
    tscript {obj.m('astring, 10)}
} text {
    _Function and object names, unlike variables, do not get implicitly
    dereferenced._
    In this case, the `$` operator is used for dereferencing.
} prompt {} tshell {
    $obj.m('astring, 10)
    $obj.destroy()
} text {
    We will talk about the dereferencing operator
    ((^ sect_tscript_deref_op later)).
}

text {
    ==== Passing options to commands

    When passing options to commands, TScript supports an additional
    syntax for arguments where the option name does not have to be
    quoted or separated from its value by a `,`.

    Instead of invoking the Tcl `subst` command as follows
} tscript { subst("-novariables", "The value of val is $val") } text {
    it can be invoked as
} tscript { subst(-novariables "The value of val is $val") } text {
    Note the option name is not quoted and there is no `,` separating
    it from its value.

    TScript recognizes this form based on the argument being composed
    of two expressions with the first one being a token
    starting with a `-` character.
}

text {
    === Defining functions

    The `tproc` command has the same form as
    the Tcl `proc` command except that the body of the procedure
    is TScript instead of Tcl.
} syntax {
    tproc _NAME_ _ARGS_ _BODY_
} text {
    _ARGS_ takes the same form as in the `proc` command, including defaults
    for parameter and variable parameters using the `args` notation.
} shell {
    tproc add {a b} {return a + b}
} text {
    [NOTE]
    The `tproc` command is meant to be called from Tcl as opposed
    to being used within TScript itself. 
}

text {
    === The `return` statement
    The TclScript `return` statement returns control to the caller
    from a function or procedure.
} syntax {
    return _EXPRESSION_
} text {
    _EXPRESSION_ is any valid TScript expression.
}

text {
    == Control statements

    TScript implements the `if`, `while` and `for` statements similar to Tcl
    but in a slightly different form.

    === The `if` statement
    The `if` statement has the syntax
} syntax {
    if _EXPRESSION_ { _STATEMENTBLOCK_ } ?else { _STATEMENTBLOCK_ }?
} text {
    As indicated, the `else` clause is optional. If present, it must
    be on the same logical line as the preceding statement block.

    _EXPRESSION_ can be any TScript expression and does not need
    to be enclosed in parenthesis.
} tscript {
    if #Emps {
        print(Emps)
    } else {
        puts("Table is empty")
    }
}

text {
    === The `while` statement
    The `while` statement has the syntax
} syntax {
    while _EXPRESSION_ { _STATEMENTBLOCK_ }
} text {
    _EXPRESSION_ can be any TScript expression and does not need
    to be enclosed in parenthesis.
} outputlimit 3 tscript {
    i = 0
    while i < # Emps {
        puts(Emps'Name[i])
        i = i + 1
    }
}

text {
    === The `for` statement
    The `for` statement takes one of two forms. The first form is
    used to iterate over a range of integers.
} syntax {
    for _IDENTIFIER_ in _LOWEXPR_ : _HIGHEXPR_ ?by _INCREMENT_? _STATEMENTBLOCK_
} text {
    The loop variable _IDENTIFIER_ is initially assigned a value of
    _LOWEXPR_. Thereafter, _STATEMENTBLOCK_ is executed as long as the
    the value of the loop variable is less than or equal to _HIGHEXPR_. After
    each iteration, the loop variable is incremented by _INCREMENT_ which
    defaults to `1` if unspecified.
} tscript {
    for i in 0 : #Emps-1 by 2 {
        puts(Emps'Name[i])
    }
} text {
    The limits of the range are computed only once, before the loop is
    iterated.
}

text {
    The other form of the `for` statement behaves similar to the
    Tcl `foreach` statement where the loop variable takes on values
    from a collection. The syntax is 
} syntax {
    for _IDENTIFIER_ in _COLLECTION_ _STATEMENTBLOCK_
} text {
    where _COLLECTION_ is any TScript expression that results
    in a column, table or a Tcl list.
} outputlimit 3 tscript {
    for rainfall in Rainfall[Rainfall > 100] {
        puts(rainfall)
    }
}

text {
    === The `break` statement
    The `break` statement behaves like the Tcl `break` command. It
    causes the innermost loop to stop execution and continue execution
    at the following statement.
} syntax {
    break
}

text {
    === The `continue` statement
    The `continue` statement behaves like the Tcl `continue` command. It
    aborts the current iteration of the innermost loop containing it
    without aborting the loop itself which then proceeds with its next
    iteration.
} syntax {
    continue
}

text {
    == Columns and tables

    We now come to the primary reason for the existence of TScript -
    convenient vector operations on columns and tables.

} text {
    === Creating columns

    Columns are created using the built-in operators `@boolean`,
    `@byte`, `@int`, `@uint`, `@wide`, `@double`, `@string` and `@any`.
    The syntax of the command is
} syntax {
    @__TYPE__ ?_INITLIST_?
} text {
    where _TYPE_ is one of the tarray column types and _INITLIST_ is
    an optional initializer list. For example,
} tscript { A = @int } text {
    creates an empty column of type `int` and assigns it to `A` and
} tscript { A = @any {10, {1, 2, 3}, len} } text {
    creates a column of type `any` with 3 elements.
}

text {
    === Creating tables
    Tables are defined and created using the @table built-in operator.
    The syntax for the command is
} syntax {
    @table(?_COLNAME_ _TYPE_?, ...) ?_TABLEROWS_?
} text {
    where _COLNAME_ is the name of the column and _TYPE_ is one
    of the tarray column types. _TABLEROWS_ may be specified
    to initialize the table and should be a list of rows as
    for the `tarray::table create` command. Here is the table
    definition from our ((^ sect_tscript_quick_tour)) section.
    
} syntax {
    Emps = @table (
        Name string,   Salary uint,   Age uint,   Location string
    ) {
        {'Sally,      70000,      32,       'Boston},
        {'Tom,        65000,      36,       'Boston},
        {'Dick,       80000,      40,       "New York"},
        {'Harry,      45000,      37,       "New York"},
        {'Amanda,     48000,      35,       'Seattle}
    }
} text {
    [TIP]
    ====
    In many cases, you may find it easier to use Tcl, either directly
    or embedded, to create tables. For example, the above table
    can be created with embedded Tcl as
} tscript {
    Emps = <
      table create {
        Name string   Salary uint    Age uint    Location string
      } {
        {Sally        70000          32          Boston}
        {Tom          65000          36          Boston}
        {Dick         80000          40          "New York"}
        {Harry        45000          37          "New York"}
        {Amanda       48000          35          Seattle}
      }
    >
} text {
    ====
}

text {
    === The `#` and `'` table column selection operators
    Columns from a table can be selected using the `'` and '#' operators.
} syntax {
    _TABLE_'_COLNAME_
    _TABLE_#_VAR_
} text {
    The former takes the actual name of the column as the operand while
    in the latter case the column is specified through a variable.
} prompt {} tshell {
    print(Emps'Name)
    colname = 'Location
    print(Emps#colname)
} text {
    These operators can be used in two contexts:

    * When used in expressions as above, they return column values
    from the table.
    * When referenced on the left side of an assignment statement,
    they select the column to be modified in a table.
    
    We will see examples later when we discuss indexing operators.
}

text {
    === The `'()` and `#()` table slicing operators

    The table slicing operators `'()` and '#()` operators
    return a table containing specific columns from a table.
} syntax {
    _TABLE_'(?_COLNAME_,...?)
    _TABLE_#(?_VAR_,...?)
} text {
    The former takes the actual name of the column as the operand while
    in the latter case the column is specified through a variable.
} prompt {} tshell {
    print(Emps'(Name, Salary))
    colnameA = 'Name ; colnameB = 'Salary
    print(Emps#(colnameA, colnameB))
} text {
    Note the difference between the following two expressions:
} prompt {} tshell {
    Emps'Name
    Emps'(Name)
} text {
    The first returns a column. The second returns a table containing
    a single column.
    
    Like the table column selection operators,
    these operators can also be used in two contexts:

    * When used in expressions as above, they return table slices
    * When referenced on the left side of an assignment statement,
    they assign to the corresponding columns in the table
    
    Again, we will see examples later when we discuss indexing operators.
}

text {
    == Operators

    TScript operators fall into the following classes:

    * ((^ sect_tscript_arith_ops "Arithmetic operators"))
    are similar to those in Tcl's `expr` command
    but work on both scalars as well as columns.

    * ((^ sect_tscript_rel_ops "Relational operators")) and
    ((^ sect_tscript_logic_ops "logical operators"))
    are similar to those in `expr` when used
    with scalar operands. However, when used with column operands
    they have different semantics that provide very convenient search
    and indexing functionality.

    * ((^ sect_tscript_set_ops "Set operators"))
    are applicable only to columns and implement operations like
    union and intersection.
    
    * ((^ sect_tscript_lookup_ops "Lookup operators")) that perform
    associative lookup on dictionaries and columns.

    * ((^ sect_tscript_indexing_ops "Indexing operators"))
    that combine both traditional indexing as well as search
    operations on collection data types including lists, columns
    and tables.

    * ((^ sect_tscript_misc_ops "Other miscellaneous operators")) that
    provide functionality like cardinality.
    
    Note that operator precedence follows that of Tcl.

    ((=== sect_tscript_arith_ops "Arithmetic operators"))

    ==== Unary arithmetic operators
    
    The TScript unary operators are `-`, `+`, `~` and `!` have the
    same semantics as in Tcl for operands that are not columns or tables.

    In the case of columns of type `byte`, `int`, `uint`,
    `wide` and `double`, the `-`, `+` operators return columns
    with each element being the result of the operator being applied
    to the corresponding element of the operand. The `~` operator
    is similar except that it cannot be applied to columns of type `double`.
    For all other combinations of column type and operation, an error is
    raised.

    In the case of operands that are tables, all unary operators will
    raise an error.
    
    ==== Binary arithmetic operators
    
    The binary operators include `+`, `-`, `*`, `/`, `**`, `&`, `|`, `^`.
    
    .Rules of operation
    
    * If either operand is a table or a non-numeric column, an error is raised.

    * If neither operand is a column, they have the same
    semantics as in Tcl.

    * If an operand is not a column, it is treated as a column of the same
    size as the other operand with all elements having the operand value.

    * The result is a column each element of which is the result
    of the operation on the corresponding elements of the operands.
    In case of differing column types, types are promoted as needed.
    See the ((^ column_math "column math")) command reference for
    full details of type promotion and intermediate values.

    Here is an example of mixed operand types:
} tscript {
        I = @int {10, 20, 30, 40}
        J = @byte {1, 2, 3, 4}
        print(I + 2 * J)
} text {
    Tables do not support
    any arithmetic operators but their contained columns can be used anywhere
    that a standalone column is valid.

    For example, we can reduce everyone's salaries by 2K since times
    are tough.
} outputlimit 0 tscript {
    Emps'Salary = Emps'Salary - 2000
    print (Emps)
}

text {
    
    ((=== sect_tscript_rel_ops "Relational operators"))
    
    The relational operators include the `==`, `!=`, `<`, +<=+, `>`, `>=`
    operators that are present in Tcl.

    In addition, they include the additional operators related
    to string and pattern matching that are shown in 
    ((^ tab_tscript_match_ops)).
    
    ((.Table tab_tscript_match_ops "TScript arithmetic operators"))
    [cols="10,30,60", options="headers"]
    |===
    |Operator
    |Syntax
    |Description

    |`=^`
    |`_STRINGA_ =^ _STRINGB_`
    |Returns 1 if the two strings are equal in case-insensitive mode, else 0.

    |`!^`
    |`_STRINGA_ =^ _STRINGB_`
    |Returns 1 if the two strings are not equal in case-insensitive mode, else 0.

    |`=~`
    |`_STRING =~ REGEXP_`
    |Returns 1 if the string matches the specified regular expression, else 0.

    |`=~^`
    |`_STRING =~^ REGEXP_`
    |Returns 1 if the string matches the specified regular expression, else 0.
    The matching is done in case-insensitive mode.

    |`!~`
    |`_STRING !~ REGEXP_`
    |Returns 1 if the string does not match the specified regular expression,
    else 0.

    |`!~^`
    |`_STRING !~^ REGEXP_`
    |Returns 1 if the string does not match the specified regular expression,
    else 0. The matching is done in case-insensitive mode.

    |`=*`
    |`_STRING =* PATTERN_`
    |Returns 1 if the string matches the specified pattern, else 0.
    The matching is done as for the Tcl `string match` command.

    |`=*^`
    |`_STRING =*^ PATTERN_`
    |Returns 1 if the string matches the specified pattern, else 0.
    The matching is done as for the `string match` command
    in case-insensitive mode.

    |`!*`
    |`_STRING !* PATTERN_`
    |Returns 1 if the string does not match the specified pattern,
    else 0. The matching is done as for the Tcl `string match` command.

    |`!*^`
    |`_STRING !*^ PATTERN_`
    |Returns 1 if the string does not match the specified pattern,
    else 0. The matching is done as for the `string match` command
    in case-insensitive mode.

    |===

    Note that for the regular expression and pattern match operators,
    the order of the operands is significant - the first indicates 
    the string being matched and the second is the pattern or regular
    expression.

    [TIP]
    In the matching operators shown above, the first character,
    `=` or `!`, indicates the sense of the match, the second character
    specifies the operation `~` or `*` and the optional third
    character `^`, if present, indicates a case-sensitive match.
    
    .Rules of operation
    
    * If either operand is a table, an error will be generated.

    * If both operands are columns, an error will be generated.

    * If neither operand is a column, the result will be a boolean
    value based on standard Tcl operators or the operators shown
    in ((^ tab_tscript_match_ops)).

    * If (exactly) one of the operands is a column, each element
    of the column is individually compared with the other operand.
    The result
    is an integer column containing the indices of those elements
    for which the specified comparison operation returns true.

    This last rule is illustrated by the example below which prints
    the indices for all months where the rainfall is less than 100mm.
} tscript {
    print(Rainfall < 100)
} text {
    The real usefulness of this will become apparent when we discuss
    ((^ sect_tscript_indexing_ops "indexing operators")).

    [NOTE]
    ====
    TScript does not allow expressions of the form
} syntax {
    a < b < c
} text {
    on the basis that more often than not these are programming errors.
    This holds only for all relational operators, not arithmetic or logical
    operators. In the rare case that you need such expressions, use
    parenthesis to appropriately group the operands.
    ====
}
text {
    ((=== sect_tscript_logic_ops "Logical operators"))

    The logical operators include `&&` and `||` as in Tcl.
    _However, unlike Tcl these operators do not short-circuit the evaluation
    of their operands._

    .Rules of operation

    * If either operand is a table, an error will be generated.

    * If neither operand is a column, the result will be a boolean
    value based on standard Tcl operators.

    * If both operands are columns, the operation is treated
    as a set operation and described in ((^ sect_tscript_set_ops)).

    * If one operand is a column and the other is not, an error is
    raised.
}

text {
    ((=== sect_tscript_set_ops "Set operators"))

    The operators `&&` and `||` behave as set operators when both
    operands are columns. In this case, both operands must be of
    the same type.

    The `&&` operator returns a column of the same type as the operands
    and containing elements that are common to both.
    
    The `||` operator returns a column of the same type as the operands
    and containing elements that are present in either operand.
} tbd {
    Update docs with respect to uniqueness
}

text {
    ((=== sect_tscript_lookup_ops "Lookup operators"))

    The operators `'` and `#` lookup keys in a dictionary
    or column.

    In the case of a dictionary, the operators retrieve
    the value associated with the key.

    The `'` operator takes the key as a literal value and returns
    the corresponding element from the dictionary. If the key follows
    the syntax for an identifier, it does not have to be quoted.
} prompt {} tshell {
    d = <dict create one 1 two 2 three 3 4 four "number five" 5> 
    d'two                 // String key "two" does not need quoting
    d ' "number five"     // Quoted string literal key
    d ' three             // Note whitespace is optional
    d'4                   // Numeric literal
} text {
    On the other hand, the `#` operator takes an operand that
    is the _name of the variable_ containing the key.
} prompt {} tshell {
    key = "number five"
    d#key
    d # key           // Note whitespace is optional
} text { 
    In the case of a column
    the lookup returns the index of the specified value. If the
    value occurs multiple times in the column, any of the corresponding
    indices may be returned.
} prompt {} tshell {
    Emps'Name'Sally
    colname = "Name"
    Emps#colname'Sally
} text {
    In the prior example, note the overloading of the `'` and `#`
    operators. When applied to tables, they act as column selectors.
    When applied to columns (selected from the table in this case)
    they act as lookup operators.

    These operators can also be used on the left hand side of an
    assignment to set new values.
} prompt {} tshell {
    d'c = 99

    I = @string {'zero, 'one, 'two, 'three}
    I'one = 1
}
    
    

text {
    ((=== sect_tscript_indexing_ops "Indexing and search operators"))

    Much of the convenience of TScript in dealing with columns and tables
    stems from its variety of indexing options. Indices may be simple
    numerics, ranges, lists or selectors based on boolean expressions.

    The flexibility of index selectors also means that they are the primary
    means of searching tables and columns for elements matching desired
    criteria. Many indexing and search operators can also be used
    with lists.
}

text {
    ==== Integer indices

    In the simplest case, an index is simply a integer value, specified
    as a literal or an expression that results in a integer value. As
    the operand of the `[]` operator, it retrieves the value of the element
    at that position.
} prompt {} tshell {
    Rainfall[0]          // Index a column with a constant

    i = 1
    Emps[i]              // Index a table with a variable
    
    {1, 2, 3, 4}[i+2]    // Index a list with an expression
} text {
    Note that the result is a ''scalar'', the value of the element at
    that position, not a column or table containing that element.
}

text {
    ==== Index ranges
    
    Alternatively, the index may specify an _index range_
    in the column or table using the syntax `_LOWEXPR_ : _HIGHEXPR_`.
    So, the rainfall for the first quarter can be retrieved by
} tscript {q1_rainfall = Rainfall[0:2]} text {
    In this case the index operator returns a column (or table)
    containing the specified elements. Thus notice the difference
    between
} tscript { Rainfall[0] } text {
    and
} tscript { Rainfall[0:0] } text {
    though they both specify a single element.

    The range limits may be expressions that result in integer
    values.
} tscript {
    i = 0
    print(Emps[i:#Emps-1])
} text {
    Again, ranges may be used with lists as well.
} tscript {
    {1, 2, 3, 4}[1:2]
} text {
    We shall also see later that ranges can also be combined with
    selectors to further focus search and indexing operations.
}

text {    
    ==== Index lists

    The third form of an index is an _index list_. Here you can
    specify a list of integers or a column of type `int` that
    contain the numeric indices of interest.
} tscript {
    i = 10
    Rainfall[{9, i, 11}]
} text {
    We could have specified a column of type `int` instead.
} tscript {
    indices = @int {11, 10, 9}
    Rainfall[indices]
} text {
    Notice that an index list (or column) does not need to contain
    the indices in order and may even contain duplicate indices.
    The values returned are in the order of specified indices.

    Again, make a note of the difference with respect to a simple
    numeric index
} tscript { Rainfall[0] } text {
    which returns the element, versus
} tscript {
    Rainfall[@int {0}] 
} text {
    which returns a column containing that single element.

    Like simple indices and ranges, index lists can be used with
    lists as well.
} tscript {
    {1, 2, 3, 4}[@int{0, 2, 1, 3}]
}

text {
    ==== Selectors

    The final form an index can take is that of a _selector_ which
    is a boolean expression involving the column or table.

    As we noted in ((^ sect_tscript_column_ops "column operators"))
    comparison of a column with a scalar value results
    in an `int` column containing the indices for which the comparison
    of the corresponding element succeeded. This implies that
    the boolean expression can be used as an expression that return
    an index list.
    
    [WARNING]
    Unlike other indexing operations, selectors will not work as
    expected with Tcl lists. In particular, Tcl lists in boolean
    expressions are treated as any other Tcl value and do not return
    an index column.

    As a simple example of a selector, consider the following expression:
} tscript { Rainfall > 100 } text {
    The return value is a column containing the indices corresponding
    to the elements which have a value greater than `100`.

    Therefore, we can use such boolean selectors as indices to 
    retrieve the actual values themselves.
} tscript { Rainfall[Rainfall > 100] } text {
    Selectors can be used for tables as well with the operand being
    a contained column. Moreover, the selector need not be a simple
    boolean expression. The following prints all employees who are
    over 35 but have an income less than `70,000`.
} outputlimit 0 tscript {
    print(Emps[Emps'Age > 35 && Emps'Salary < 70000]) 
}

text {
    ===== Ranges in selectors

    Selectors can include ranges as well.
    For example, the rainfall in the last quarter that
    exceeds 50mm is given by
} tscript { Rainfall[9:11 && Rainfall > 50] } text {
    [WARNING]
    A selector can include function calls as well. However, note
    that the function is called just once, not once per element
    of the column or table.

    Because of their flexibility, selectors are the mechanism
    for doing searches in columns and tables.
}

text {
    ===== The `@@` selector context

    In previous examples, we supplied the variable containing the table
    or column, for example `Emps`, to the selector expression. In some
    cases, the table or column may not stored in a variable, for example
    when it is a function return value or when it is generated through
    an expression. In this case the `@@` special token may be used to
    reference the table instead of storing the generated value in
    a temporary for naming purposes. This is illustrated in the
    following example.
} shell {
    proc get_table {} { return $::Emps }
    tscript { print( get_table() [@@'Age > 35 && @@'Salary < 70000]) }
}

text {
    ==== Using indices in assignments
    The various forms of indexing can also be
    used in the left side of assignments. We have already seen some
    examples earlier. Below are some slightly more involved examples.
} text {
    To move everyone to Boston, fill the entire range with one value.
} tscript {
    Emps'Location[0 : #Emps - 1] = 'Boston
} text {
    To give an increment only to low-paid
    employees make use of selectors.
} outputlimit 0 tscript {
    Emps'Salary[Emps'Salary < 50000] = Emps'Salary[Emps'Salary < 50000] + 2000;
    print (Emps)
} text {
    To modify a subset of the fields for a specific row,
    index a slice of the table. So to relocate Sally with a raise
} outputlimit 0 tscript {
    Emps'(Salary, Location)[Emps'Name'Sally]  = {70000, 'Seattle}
    print (Emps[Emps'Name == 'Sally])
} text {
    Use of indices in assignments is not limited to columns and rows.
    List elements can be assigned in the same manner.
} prompt {} tshell {
    l = {1, 2, 3}
    l[0] = 101
    l[{3,4}] = 1000
} text {
    [WARNING]
    ====
    Because Tcl is untyped, assigning to lists using indices can be ambiguous.
    For example, compare the results of the following two statements:
} prompt {} tshell {
    I = @int {1, 2, 3, 4}
    I[0:1] = 100
    I[2:3] = {102, 103}
    
    l = {1, 2, 3, 4}
    l[0:1] = 100
    l[2:3] = {102, 103}  // Ambiguity, assumes a fill operation
} text {
    In the first case, values 102 and 103 are assigned to consecutive list
    elements. Because the column is typed as integer, TScript can deduce the
    intended operation in both assignments to `I`. In the case of the
    second assignment to the list, there is ambiguity because lists can
    contain elements of any type. Thus the statement could be interpreted
    as filling the range with a single value or as assigning consecutive
    elements of the right hand list. In such a case, TScript assumes
    a fill operation is intended.

    Similar situations can also arise when the column is of type `any` since
    columns of that type can hold any type of value.
    ====
}

text {
    ((=== sect_tscript_misc_ops "Miscellaneous operators"))
}

text {
    ==== The `#` size operator

    The unary operator `#` returns the size
    of its operand which must be a list, column or table.
} prompt {} tshell {
    len = # {1,2,3,4}   // Length of a list
    # Rainfall          // Size of a column
    # (Rainfall > 100)  // Size of a column returned by an expression
    nemps = # Emps      // Size of a table
}

text {
    ((=== sect_tscript_deref_op "The `$` dereferencing operator"))

    The operator `$` is a unary operator that dereferences
    the value of its operand. We have already seen an example of its use
    ((^ sect_tscript_calling_methods earlier)) in calling object methods.

    The operator can only be applied to an identifier or a string literal
    and not to an arbitrary expression. In both cases, it returns the
    value of the variable whose name is given by the operand value.
    
    The operator is useful in a couple of different situations. One is
    when you need to reference a variable that does not follow TScript
    identifier syntax, e.g. one with spaces in it, as shown in the
    Tcl code below. The other is when the variable is to be referenced
    indirectly.

    As an example, suppose you had the following
} shell {
    set "variable with spaces in name" "value of variable with spaces"
    set varname "variable with spaces in name"
} text {
    Then the equivalent of the Tcl code
} shell {
    puts ${variable with spaces in name}
    puts [set $varname]
} text {
    would be the following in TScript
} prompt {} tshell {
    puts($"variable with spaces in name")
    puts($varname)
} text {
    [NOTE]
    Dereferencing operators cannot be used on the left hand side
    of an assignment statement.
}

text {
    == Other operations/library functions
} shell {
    tscript { T = table::delete(Emps, Emps'Salary > 70000) }
}

text {

    Column tables can be used anywhere columns are used including assignments

    === Columns and tables as target of assignment
    T.c
    

}

tbd { sum, minmax, sort etc.}
tbd { namespace and execution context }
