text {
    ((= chap_tscript "The TScript Language"))
    include::header.ad[]

    ((author "Ashok P. Nadkarni"))
}

text {
    == Introduction

    The ((^ chap_intro tarray)) Tcl extension implements _typed arrays_,
    which stores data in native format and provides efficient memory
    utilization and parallelized processing. Columns store elements
    of a single type, while tables, similar to data frames in the R
    language, are an ordered sequence of named columns. The `tarray`
    extension provides the corresponding
    ((^ chap_column_ref `column`)) and ((^ chap_table_ref `table`))
    Tcl commands for their manipulation.

    [TIP]
    This document assumes the reader is familiar with typed arrays.
    If not, please glance through the ((^ chap_guide)) before continuing.

    The TScript language is an alternative for 
    working with typed array columns and tables. It provides 
    
    * convenient succint syntax
    * vector operations
    * search operators
    * flexible indexing

    Although geared towards typed arrays, TScript is not limited to
    operating solely on those structures. It can be used with any data.
    Note however, that TScript is not a replacement for Tcl.
    Rather, it is embedded in
    Tcl and the two can be intermixed according to whatever syntax suits
    the task at hand.

    Neverthess, TScript is syntactically completely different from Tcl.

    [WARNING]
    TScript is still under development. Syntactic and functional changes
    are likely. The parser and runtime is currently implemented in Tcl
    for ease of development and therefore performance on
    _scalar_ operation (as opposed to columns and tables)
    will lag that of Tcl. Both will be reimplemented in C before
    final release.
}

eval {
    package require tarray
    source ../src/teval.tcl
}

text {
    ((== sect_tscript_quick_tour "Quick Tour"))

    This section provides a short tour of TScript to
    introduce the reader to the language. 

    The basic syntax of TScript is close to the C family of languages
    than Tcl.

    .Variable and literals
} tscript {
    a = 1 ; b = 2
    c = 1 + a * b
} text {
    Thus unquoted identifiers are variables, not strings, and do not
    need a `$` prefix as in Tcl. Expressions use the usual infix form.
    
    String literals can be expressed in two forms - surrounded by double
    quotes, or with a single preceding single quote for literals that
    only contain alphanumeric characters.
} tscript {
    puts("Two words")
    puts('OneWord)
} text {
    .Calling functions
    
    Commands or functions
    (we use the terms interchangeably) are called with parameters
    enclosed in parenthesis.
} tscript {
    hex = format("0x%x", 42)
} text { 

    .Mixing Tcl and TScript
    We have already seen how TScript can be invoked from Tcl with
    the `tscript command. Similarly,
    Tcl code can be intermixed within TScript by bracketing it with
    `<>`.
} tscript {
    L = {1, 2}
    < lappend L 3 >
    puts(L)

    now = <clock seconds>
} text {
    The Tcl fragment may also be spread across multiple lines.
} tscript {
    puts("TScript statement")
    <
    puts "First Tcl statement"
    puts "Second Tcl statement"
    >
}

text {
    .Working with lists
    Lists are constructed using braces but unlike in Tcl, elements
    are expressions separated with commas.
} tscript {
    L = {0, a, b, a + b, tcl::mathfunc::rand()}
} text {
    Although you can call Tcl's list related commands, like
} prompt {} tshell {
    llength(L)
} text {
    there are several convenient operators dealing with lists.
    
    The prefix operator `%` can be used to return the length of a list.
} tscript {
    L = {'zero, 'one, 'two, 'three}
    len = % L
} text {
    Similarly, the indexing operator `[]` can be used instead
    of `lindex` and this supports multiple forms.
} prompt {} tshell {
    L[0]  # Single element
    
    L[0:1] # Index range
    
    L[{3,1,2}] # Index list - note indices need not be in order
} text {
   The indexing operator can be used in assignments as well. 
} prompt {} tshell {
    L[0 : %L-2] = 999
    
    L[{3,2}] = {100, 101}
} text {
    Other list operations are performed by calling the corresponding
    Tcl command.
} prompt {} tshell {
    lsort(L)
}

text {
    .Working with dictionaries
    Dictionary access has a similar shorthand using
    using the `%` or `'` postfix operators.
    The difference between the two
    is that the former specifies the key via a variable and
    the latter as a literal.
} prompt {} tshell {
    colors = {"red", 0xff0000, "green", 0x00ff00, "blue", 0x0000ff}
    
    colors'red

    color = "blue"

    colors%color
} text {
    The same syntax can be used to modify the dictionary as well.
} prompt {} tshell {
    colors%color = 0x0000ee
}

text {
    The primary purpose of TScript is really to work conveniently with
    typed arrays - columns and tables - and we demonstrate that next.

    .Working with columns

    A column is created in TScript as
} tscript {
   Rainfall = @double {
        11.0, 23.3, 18.4, 14.7, 70.3, 180.5, 210.2, 205.8, 126.4, 64.9, 33.1, 19.2
    }
} text {
    We can use much the same operators with columns as we used for lists.
} prompt {} tshell {
    % Rainfall           # Size of column

    Rainfall[0]          # Rainfall in January
    
    Rainfall[9:11]       # Rainfall in the last quarter

    Rainfall[11] = 21.5  # Update the measured amount for December
} text {
    When the indexing operation itself returns a column,
    the vector and folding operations available for columns can be 
    used in conjunction.
} prompt {} tshell {
    print( Rainfall / 10 )      # Print rainfall in centimeters

    @sum(Rainfall[9:11])  # Total rainfall in the last quarter
} tbd {
    Use of ' and % with columns
    (currently numeric literals do not work with ')
}

text {
    One feature that TScript supports for columns that is not available
    for lists is search using boolean expressions. For example,
    we can get the indices corresponding to the months where the
    rainfall lies within a specific range.
} tscript {
    print(Rainfall > 100 && Rainfall < 200)
} text {
    Moreover, since the boolean expressions return an integer column containing
    the element indices, they can be used with in any operation applicable
    to columns. For example, the `%` count operator will return the
    number of such months.
} prompt {} tshell {
    %(Rainfall > 100 && Rainfall < 200) 
} text {
    Or we could use indexing to retrieve the actual values themselves.
} prompt {} tshell {
    print ( Rainfall [Rainfall > 100 && Rainfall < 200] ) 

    print ( Rainfall [@@ > 100 && @@ < 200] )     # @@ specifies the "current" context
}

text {
    .Working with tables

    As for columns, we will use a small sample table
    containing a simple employee data base for demonstration purposes:
} tscript {
    Emps = @table (
        Name string,   Salary uint,   Age uint,   Location string
    ) {
        {'Sally,      70000,      32,       'Boston},
        {'Tom,        65000,      36,       'Boston},
        {'Dick,       80000,      40,       "New York"},
        {'Harry,      45000,      37,       "New York"},
        {'Amanda,     48000,      35,       'Seattle}
    }
    print(Emps)
} text {
    Tables rows can be accessed in the same manner as column elements.
} prompt {} tshell {
    % Emps      # Number of employees

    print(Emps[3])     # Fourth row of table

    print(Emps[2:4])   # Third through fifth rows

    print(Emps[{3,1}]) # Fourth and second row
}

text {
    Columns within a table are accessed with the `'` and `%` operators
    and indexed as usual.
} prompt {} tshell {
    print(Emps'Name)     # Column name supplied as literal

    colname = 'Salary
    print(Emps%colname)   # Column name supplied in a variable

    print(Emps'Salary[@@ >= 70000])    # High salaries
} text {
    Table slice operators can be used extract subtables.
} prompt {} tshell {
    print(Emps'(Name, Location))

    print(Emps'(Name, Location)[2:4])
}
text {
    As for columns, boolean expression can be used to query tables.
} outputlimit 0 prompt {} tshell {
    print(Emps[Emps'Salary > 50000 && Emps'Location != "New York"])

    print(Emps[Emps'Salary > 50000 && Emps'Location != "New York"] ' (Name, Age))
} text {
    Tables can be modified in multiple ways.
} outputlimit 0 tscript {
    Emps[% Emps] = {'Mary, 38000, 25, 'Seattle}      # Add a row

    Emps'Salary = Emps'Salary + 2000                 # Modify entire column

    Emps'Location[Emps'Name'Sally] = {{"New York"}}  # Modify a single cell

    print(Emps)
}

text {
    == Running TScript 

    TScript is part of the `tarray` package which must be loaded to run
    TScript code.
} shell {
    package require tarray
    namespace path tarray;      # Allows use of tarray commands without qualification
} eval {
    source ../src/teval.tcl
} text {
    A TScript code fragment may be run by one of several means.

    First, it can be run from within using the `tarray::tscript` command.
    This is roughly the equivalent of running a Tcl script using `eval`.
} shell {
    tscript { a = 1 }
} text {
    The `tscript` command returns the result of the last statement it
    executes.
    
    Second, you can define a TScript procedure from Tcl using `tarray::tproc` in
    a similar fashion as the Tcl `proc` command. It can then be invoked
    in the same manner as a Tcl procedure.
} shell {
    tproc add {x y} { return x + y }
    add 2 3
} text {
    Finally, you can load an entire TScript file using the
    `tarray::tsource` command which has syntax similar to the
    Tcl `source` command.
} syntax {
    tsource ?-encoding _ENCODING_? _TSCRIPTFILE_
} text {

    In this tour, for ease of exposition we will simply show the
    relevant TScript fragments without any reference to how they
    are executed.
}

text {
    ((== sect_basic_tscript_syntax "Basic syntax"))

    The basic syntax of TScript is closer to the C family of languages
    than to Tcl.

    === Statements

    Like Tcl, a TScript script is a sequence of statements separated
    by either a newline character or a semicolon.
} tscript {
    x = 2
    y = 3 ; z = x*y
} text {
    A statement may be an assignment as above, or simply an expression:
} tscript {10*x + y}

text {
    ==== Assignment statement
    An assignment statement in TScript takes the form
} syntax {
    _LVALUE_ = _RAVALUE_
} text {
    where _RVALUE_ may be a TScript expression or
    ((^ sect_tscript_tcl "Tcl fragment")).

    In the current version of TScript, _LVALUE_ cannot be an arbitrary
    expression and must take one of the following forms:

    * an identifier as defined in ((^ sect_tscript_variables))

    * optionally followed by a ((^ sect_tscript_lookup_ops "lookup")),
    ((^ sect_tscript_column_sel_ops "column selection")) or
    ((^ sect_tscript_table_slice_ops "table slicing")) operator

    * optionally followed by an ((^ sect_tscript_indexing_ops "indexing")) operator
}

text {
    ((=== sect_tscript_tcl "Mixing Tcl and TScript"))

    Tcl and TScript code can be intermixed. To embed TScript within
    Tcl, use the `tarray::tscript` command as
} syntax {
    tscript _TSCRIPT_
} text {
    where _TSCRIPT_ is the TScript fragment which may be spread across
    multiple lines.
} shell {
    tscript { x = 2 }
    tscript {
        y = 3
        z = x * y
    }
} text {
    Conversely, Tcl can be embedded with TScript by placing the
    Tcl script within `<` and `>` delimiters.
} prompt {} tshell {
    now = <clock seconds>
} text {
    Multi-line scripts are permitted.
} tscript {
    <
        set x 2
        set y 3
        set z [expr {$x + $y}]
    >
} text {
    The terminating `>` _must_ be followed by a TScript statement terminator
    such as a newline or `;`, optionally with intervening whitespace.

    [NOTE]
    Embedded Tcl is not an expression and thus cannot be used as
    part of an expression.
}

text {
    === Comments

    Comments begin with `#` and extend to the end of the line. Note
    that unlike Tcl, `#` marks the beginning of a comment irrespective
    of where it appears outside of a quoted string.
}

text {
    ((=== sect_tscript_variables Variables))

    As seen above, variables are syntactically different from Tcl:

    * There is no preceding `$` as in Tcl for accessing a variable's value.
    * Variable names are restricted to starting with an alphabetic
    character and may only contain alphanumeric characters, `_` and
    `:`.

    The variables themselves are standard Tcl variables and follow
    the same name resolution rules.
} shell {
    set v "This is a variable"
    tscript { v = "Modified from tscript" }
    puts $v
}

text {    
    === Literals

    Numeric literals are as in Tcl and have the same syntax as in Tcl.
    For example,
} prompt {} tshell {
    r = 2.0e10
    big = 123455678987654321000000000
} text {

    String literals are delimited by double quotes and follow
    the backslash substitution rules as in Tcl.

    Unlike in Tcl, _a plain unquoted string is treated as an identifier_ and
    not a string literal.
} errorok 1 prompt {} tshell {
    s = unquoted
} text {
    Also, unlike in Tcl double quoted strings, there is no
    interpolation.
} text {
    [WARNING]
    Also note that braces have different semantics in TScript and
    cannot be used to delimit strings.
} text {
    An alternate form of a string literal is a `'` character preceding
    a string that follows the rules for an identifier.
} tscript { s = 'this::is::a::string } text {
    This alternate form is merely a small convenience.
}

text {
    === Lists

    Braces in TScript are used to construct lists, similar to the
    `list` command in Tcl. _Note this differs from the use of braces in Tcl._
} tscript {
    l = {"a string", x, tcl::clock::seconds(), y+z}
} text {
    The list elements are separated using commas and an element may
    be a literal, variable, function call or general expression.
    The list elements may be spread across multiple lines but must still
    be separated by commas.
} tscript {
    l = {
        x,
        "a string",
        y+z
    }
} text {
    As an aside, we could also have invoked the Tcl `list` command
    as a function to construct a list.
} tscript {l = list(x,"a string",y+z)}

text {
    == Functions

    Functions in TScript may refer to either Tcl commands or to functions
    defined through the TScript `tproc` function.
    
    === Invoking functions
    Invocation of functions/commands takes a form similar to function
    calls in C. 
    Function parameters are wrapped in parenthesis and separated by commas.

} tscript {
        hex = format("0x%x", 42)
} text {
    The above calls Tcl's built-in `format` command.
    There is no difference between invoking commands implemented in Tcl or
    in TScript via the `tproc` procedure.

    [WARNING]
    ====
    There is a subtle
    point to be noted when invoking commands from TScript as opposed to Tcl.
    In TScript, a parameter that is not a literal is implicitly dereferenced
    when passed to a command. It is easy to forget this when calling
    Tcl commands that take variable _names_ as parameters.
    Thus 
    ----
    incr val -1
    ----
    is _not_ 
    ----
    tscript { incr(val, -1) }
    ----
    which lands up passing the _value_ of `val` to the `incr`
    command which actually expects the name `val` itself to be the argument.

    The correct equivalents are either of the following:
    ----
    tscript { incr("val", -1) }
    tscript { incr('val, -1) }
    ----
    ====
} text {
    As for list elements, the parameters for a function call may be
    spread across multiple lines.
} tscript {
    hex = format("0x%x",
                 42)
} text {
    The function called need not be an identifier; it can be supplied
    as any expression, for example a function call that returns a function
    name.
} prompt {} tshell {
    < proc function_returning_function {} {return puts} >
    function_returning_function () ("Hello there!")
}

text {
    ==== Calling ensemble commands

    Ensemble commands such as `clock seconds` are called from TScript as
} prompt {} tshell {
    clock.seconds()
} text {
    Note the use of `.` as the separator between the command and its
    subcommand. Depending on how the ensemble is defined, you can
    also directly invoke it.
} prompt {} tshell {
    tcl::clock::seconds()
} text {
    Finally, in the very rare case that the ensemble subcommand does
    not fit the syntax for a TScript identifier, you can pass it as the
    first argument.
} prompt {} tshell {
    clock("seconds")
}

text {
    ((==== sect_tscript_calling_methods "Calling object methods"))

    Object methods are called in a manner similar to ensemble commands.
} shell {
    oo::class create OExample { method m args {puts [join $args ,]} }
    OExample create o
    tscript {
        o.m('astring, 10)
        o.destroy()
    }
} text {
    However, there is an additional case here where the name of the
    object is not fixed and the object is accessed through a variable.
} errorok 1 shell {
    set obj [OExample new]
    tscript {obj.m('astring, 10)}
} text {
    _Function and object names, unlike variables, do not get implicitly
    dereferenced._
    In this case, the `$` operator is used for dereferencing.
} prompt {} tshell {
    $obj.m('astring, 10)
    $obj.destroy()
} text {
    We will talk about the dereferencing operator
    ((^ sect_tscript_deref_op later)).
}

text {
    ==== Passing options to commands

    When passing options to commands, TScript supports an additional
    syntax for arguments where the option name does not have to be
    quoted or separated from its value by a `,`.

    Instead of invoking the Tcl `subst` command as follows
} tscript { subst("-novariables", "The value of val is $val") } text {
    it can be invoked as
} tscript { subst(-novariables "The value of val is $val") } text {
    Note the option name is not quoted and there is no `,` separating
    it from its value.

    TScript recognizes this form based on the argument being composed
    of two expressions with the first one being a token
    starting with a `-` character.
}

text {
    === Defining functions

    The `tproc` command has the same form as
    the Tcl `proc` command except that the body of the procedure
    is TScript instead of Tcl.
} syntax {
    tproc _NAME_ _ARGS_ _BODY_
} text {
    _ARGS_ takes the same form as in the `proc` command, including defaults
    for parameter and variable parameters using the `args` notation.
} shell {
    tproc add {a b} {return a + b}
} text {
    [NOTE]
    The `tproc` command is meant to be called from Tcl as opposed
    to being used within TScript itself. 
}

text {
    === The `return` statement
    The TclScript `return` statement returns control to the caller
    from a function or procedure.
} syntax {
    return _EXPRESSION_
} text {
    _EXPRESSION_ is any valid TScript expression.
}

text {
    == Control statements

    TScript implements the `if`, `while` and `for` statements similar to Tcl
    but in a slightly different form.

    === The `if` statement
    The `if` statement has the syntax
} syntax {
    if _EXPRESSION_ { _STATEMENTBLOCK_ } ?else { _STATEMENTBLOCK_ }?
} text {
    As indicated, the `else` clause is optional. If present, it must
    be on the same logical line as the preceding statement block.

    _EXPRESSION_ can be any TScript expression and does not need
    to be enclosed in parenthesis.
} tscript {
    if %Emps {
        print(Emps)
    } else {
        puts("Table is empty")
    }
}

text {
    === The `while` statement
    The `while` statement has the syntax
} syntax {
    while _EXPRESSION_ { _STATEMENTBLOCK_ }
} text {
    _EXPRESSION_ can be any TScript expression and does not need
    to be enclosed in parenthesis.
} outputlimit 3 tscript {
    i = 0
    while i < % Emps {
        puts(Emps'Name[i])
        i = i + 1
    }
}

text {
    === The `for` statement
    The `for` statement takes one of two forms. The first form is
    used to iterate over a range of integers.
} syntax {
    for _IDENTIFIER_ in _LOWEXPR_ : _HIGHEXPR_ ?by _INCREMENT_? _STATEMENTBLOCK_
} text {
    The loop variable _IDENTIFIER_ is initially assigned a value of
    _LOWEXPR_. Thereafter, _STATEMENTBLOCK_ is executed as long as the
    the value of the loop variable is less than or equal to _HIGHEXPR_. After
    each iteration, the loop variable is incremented by _INCREMENT_ which
    defaults to `1` if unspecified.
} tscript {
    for i in 0 : %Emps-1 by 2 {
        puts(Emps'Name[i])
    }
} text {
    The limits of the range are computed only once, before the loop is
    iterated.
}

text {
    The other form of the `for` statement behaves similar to the
    Tcl `foreach` statement where the loop variable takes on values
    from a collection. The syntax is 
} syntax {
    for _IDENTIFIER_ in _COLLECTION_ _STATEMENTBLOCK_
} text {
    where _COLLECTION_ is any TScript expression that results
    in a column, table or a Tcl list.
} outputlimit 3 tscript {
    for rainfall in Rainfall[Rainfall > 100] {
        puts(rainfall)
    }
}

text {
    === The `break` statement
    The `break` statement behaves like the Tcl `break` command. It
    causes the innermost loop to stop execution and continue execution
    at the following statement.
} syntax {
    break
}

text {
    === The `continue` statement
    The `continue` statement behaves like the Tcl `continue` command. It
    aborts the current iteration of the innermost loop containing it
    without aborting the loop itself which then proceeds with its next
    iteration.
} syntax {
    continue
}

text {
    === The `try` statement
    The `try` statement closely resembles Tcl's `try` command
    differing only in that the syntax is a little different
    and the clauses are in TScript.

    The general syntax of the command is
} syntax {
    try { _BODY_ } ?_HANDLER_ ...? ?finally { _FINALBODY_ }?
} text {
    Multiple handlers may be specified.
    Each _HANDLER_ may be one of two forms:
} syntax {
    on _EXCEPTIONCODE_ ?_VARNAME_ ...? { _HANDLERBODY_ }
    trap _ERRORPREFIX_ ?_VARNAME_ ...? { _HANDLERBODY_ }
} text {
    The statement results in the execution of _BODY_. The exception code
    resulting from the execution is matched against each handler in turn.
    The _HANDLERBODY_ corresponding to the first matching handler is
    executed and propagation of the exception stops in that case. Further
    handlers are not checked.
    If no handler matches, the exception is propagated. In all cases,
    irrespective of the exception code and whether any handler matched,
    the _FINALBODY_ script is run if present.

    In the case of the `on` handler, _EXCEPTIONCODE_ is an integer value
    or one of the strings `ok`, `error`, `continue`, `break` or `return`.
    The handler will match if this matches the exception code resulting
    from the execution of _BODY_.

    The `trap` handler only matches if the exception code is `error`.
    Additionally the appropriate number of leading values from
    the `-errorcode` entry in the interpreter status dictionary
    must match the values specified in 
    _ERRORPREFIX_ which must be of the form used for constructing lists.
    
    In both types of handlers, the handler script body may be preceded
    by zero or more variable names. If present, the first of these receives
    the result of the execution of _BODY_. The second variable, if present,
    receives the status dictionary.

    The following example will help clarify the working.
} tscript {
    try {
        x = nosuchvar
    } trap {'TCL, 'LOOKUP, 'VARNAME} message status_dict {
        puts("Oops, variable does not exist")
        puts(message)
    } on error message status_dict {
        puts("Some other error")
    } finally {
        puts("Oh well, life goes on")
    }
} text {
    [WARNING]
    Make a note of how the _ERRORPREFIX_ is specified as a list construct.
    The elements may be general expressions and hence string constants
    have to be quoted as shown in the example.
    
    A more bare-bones version of the above, with a different error this
    time, would be
} tscript {
    try {
        throw 'TSCRIPT, 'TEST, "This is only a test"
    } trap {'TCL, 'LOOKUP, 'VARNAME} {
        puts("Oops, variable does not exist")
    } on error message {
        puts(message)
    }
}

text {
    === The `throw` statement
    The `throw` statement raises a Tcl error in similar manner to
    Tcl's own `throw` and `error` statement. Its general syntax is
} syntax {
    throw _EXPRESSION_ ?, _EXPRESSION_ ...?
} text {
    If a single argument is given, it is taken to be the equivalent
    of the message argument to a Tcl `error` or `throw` command.
    If multiple arguments are given, the last argument is interpreted
    as the message. Moreover, all arguments are gathered into a list
    which becomes the value of the error code.
} shell {
    catch { tscript {throw "This is the error message"} } message
    puts $message
    puts $::errorCode

    catch { tscript {throw 'TSCRIPT, 'ERROR, "This is only a test"} } message
    puts $message
    puts $::errorCode
}

text {
    == Columns and tables

    We now come to the primary reason for the existence of TScript -
    convenient vector operations on columns and tables.

} text {
    === Creating columns

    Columns are created using the built-in operators `@boolean`,
    `@byte`, `@int`, `@uint`, `@wide`, `@double`, `@string` and `@any`.
    The syntax of the command can take two forms, the first of which is
} syntax {
    @__TYPE__ ?_INITLIST_?
} text {
    Here _TYPE_ is one of the tarray column types and _INITLIST_ is
    an optional initializer list. For example,
} tscript { A = @int } text {
    creates an empty column of type `int` and assigns it to `A` and
} tscript { A = @any {10, {1, 2, 3}, len} } text {
    creates a column of type `any` with 3 elements.

    The second form is that of a function, which is
} syntax {
    @__TYPE__ (?EXPR?)
} text {
    Again, here _TYPE_ is one of the tarray column types. _EXPR_,
    if specified, is an expression that will be used to initialize the column.
    Thus this form can also be used to ''cast'' a column to a column of
    a different type.
} prompt {} tshell {
    @int(Rainfall)
}

text {
    === Creating tables
    Tables are defined and created using the @table built-in operator.
    The syntax for the command is
} syntax {
    @table(?_COLNAME_ _TYPE_?, ...) ?_TABLEROWS_?
} text {
    where _COLNAME_ is the name of the column and _TYPE_ is one
    of the tarray column types. _TABLEROWS_ may be specified
    to initialize the table and should be a list of rows as
    for the `tarray::table create` command. Here is the table
    definition from our ((^ sect_tscript_quick_tour)) section.
    
} syntax {
    Emps = @table (
        Name string,   Salary uint,   Age uint,   Location string
    ) {
        {'Sally,      70000,      32,       'Boston},
        {'Tom,        65000,      36,       'Boston},
        {'Dick,       80000,      40,       "New York"},
        {'Harry,      45000,      37,       "New York"},
        {'Amanda,     48000,      35,       'Seattle}
    }
} text {
    [TIP]
    ====
    In many cases, you may find it easier to use Tcl, either directly
    or embedded, to create tables. For example, the above table
    can be created with embedded Tcl as
} tscript {
    Emps = <
      table create {
        Name string   Salary uint    Age uint    Location string
      } {
        {Sally        70000          32          Boston}
        {Tom          65000          36          Boston}
        {Dick         80000          40          "New York"}
        {Harry        45000          37          "New York"}
        {Amanda       48000          35          Seattle}
      }
    >
} text {
    ====
}

text {
    ((=== sect_tscript_column_sel_ops "The `%` and `'` table column selection operators"))
    Columns from a table can be selected using the `'` and '%' operators.
} syntax {
    _TABLE_'_COLNAME_
    _TABLE_%_VAR_
} text {
    The former takes the actual name of the column as the operand while
    in the latter case the column is specified through a variable.
} prompt {} tshell {
    print(Emps'Name)
    colname = 'Location
    print(Emps%colname)
} text {
    These operators can be used in two contexts:

    * When used in expressions as above, they return column values
    from the table.
    * When referenced on the left side of an assignment statement,
    they select the column to be modified in a table.
    
    We will see examples later when we discuss indexing operators.
}

text {
    ((=== sect_tscript_table_slice_ops "The `'()` and `%()` table slicing operators"))

    The table slicing operators `'()` and '%()` operators
    return a table containing specific columns from a table.
} syntax {
    _TABLE_'(?_COLNAME_,...?)
    _TABLE_%(?_VAR_,...?)
} text {
    The former takes the actual name of the column as the operand while
    in the latter case the column is specified through a variable.
} prompt {} tshell {
    print(Emps'(Name, Salary))
    colnameA = 'Name ; colnameB = 'Salary
    print(Emps%(colnameA, colnameB))
} text {
    Note the difference between the following two expressions:
} prompt {} tshell {
    Emps'Name
    Emps'(Name)
} text {
    The first returns a column. The second returns a table containing
    a single column.
    
    Like the table column selection operators,
    these operators can also be used in two contexts:

    * When used in expressions as above, they return table slices
    * When referenced on the left side of an assignment statement,
    they assign to the corresponding columns in the table
    
    Again, we will see examples later when we discuss indexing operators.
}

text {
    === Converting to lists and dictionaries

    Columns and tables can be converted to lists and dictionaries
    with the `@list` and `@dict` functions respectively. In the case
    of the latter, the key for the dictionary is the index of the
    value in the column or table.
} prompt {} tshell {
    @list (Emps)
    
    @dict (Rainfall)
} text {
    Any expression that results in a column or table
    may be supplied as the parameter to these functions. If
    the expression does not result in a column or table, an error is
    generated.
}

text {
    == Operators

    TScript operators fall into the following classes:

    * ((^ sect_tscript_arith_ops "Arithmetic operators"))
    are similar to those in Tcl's `expr` command
    but work on both scalars as well as columns.

    * ((^ sect_tscript_rel_ops "Relational operators")) and
    ((^ sect_tscript_logic_ops "logical operators"))
    are similar to those in `expr` when used
    with scalar operands. However, when used with column operands
    they have different semantics that provide very convenient search
    and indexing functionality.

    * ((^ sect_tscript_set_ops "Set operators"))
    are applicable only to columns and implement operations like
    union and intersection.
    
    * ((^ sect_tscript_lookup_ops "Lookup operators")) that perform
    associative lookup on dictionaries and columns.

    * ((^ sect_tscript_indexing_ops "Indexing operators"))
    that combine both traditional indexing as well as search
    operations on collection data types including lists, columns
    and tables.

    * ((^ sect_tscript_misc_ops "Other miscellaneous operators")) that
    provide functionality like cardinality.
    
    Note that operator precedence follows that of Tcl.

    ((=== sect_tscript_arith_ops "Arithmetic operators"))

    ==== Unary arithmetic operators
    
    The TScript unary operators are `-`, `+`, `~` and `!` have the
    same semantics as in Tcl for operands that are not columns or tables.

    In the case of columns of type `byte`, `int`, `uint`,
    `wide` and `double`, the `-`, `+` operators return columns
    with each element being the result of the operator being applied
    to the corresponding element of the operand. The `~` operator
    is similar except that it cannot be applied to columns of type `double`.
    For all other combinations of column type and operation, an error is
    raised.

    In the case of operands that are tables, all unary operators will
    raise an error.
    
    ==== Binary arithmetic operators
    
    The binary operators include `+`, `-`, `*`, `/`, `**`, `&`, `|`, `^`.
    
    .Rules of operation
    
    * If either operand is a table or a non-numeric column, an error is raised.

    * If neither operand is a column, they have the same
    semantics as in Tcl.

    * If an operand is not a column, it is treated as a column of the same
    size as the other operand with all elements having the operand value.

    * The result is a column each element of which is the result
    of the operation on the corresponding elements of the operands.
    In case of differing column types, types are promoted as needed.
    See the ((^ column_math "column math")) command reference for
    full details of type promotion and intermediate values.

    Here is an example of mixed operand types:
} tscript {
        I = @int {10, 20, 30, 40}
        J = @byte {1, 2, 3, 4}
        print(I + 2 * J)
} text {
    Tables do not support
    any arithmetic operators but their contained columns can be used anywhere
    that a standalone column is valid.

    For example, we can reduce everyone's salaries by 2K since times
    are tough.
} outputlimit 0 tscript {
    Emps'Salary = Emps'Salary - 2000
    print (Emps)
}

text {
    
    ((=== sect_tscript_rel_ops "Relational operators"))
    
    The relational operators include the `==`, `!=`, `<`, +<=+, `>`, `>=`
    operators that are present in Tcl.

    In addition, they include the additional operators related
    to string and pattern matching that are shown in 
    ((^ tab_tscript_match_ops)).
    
    ((.Table tab_tscript_match_ops "TScript arithmetic operators"))
    [cols="10,30,60", options="headers"]
    |===
    |Operator
    |Syntax
    |Description

    |`=^`
    |`_STRINGA_ =^ _STRINGB_`
    |Returns 1 if the two strings are equal in case-insensitive mode, else 0.

    |`!^`
    |`_STRINGA_ =^ _STRINGB_`
    |Returns 1 if the two strings are not equal in case-insensitive mode, else 0.

    |`=~`
    |`_STRING =~ REGEXP_`
    |Returns 1 if the string matches the specified regular expression, else 0.

    |`=~^`
    |`_STRING =~^ REGEXP_`
    |Returns 1 if the string matches the specified regular expression, else 0.
    The matching is done in case-insensitive mode.

    |`!~`
    |`_STRING !~ REGEXP_`
    |Returns 1 if the string does not match the specified regular expression,
    else 0.

    |`!~^`
    |`_STRING !~^ REGEXP_`
    |Returns 1 if the string does not match the specified regular expression,
    else 0. The matching is done in case-insensitive mode.

    |`=*`
    |`_STRING =* PATTERN_`
    |Returns 1 if the string matches the specified pattern, else 0.
    The matching is done as for the Tcl `string match` command.

    |`=*^`
    |`_STRING =*^ PATTERN_`
    |Returns 1 if the string matches the specified pattern, else 0.
    The matching is done as for the `string match` command
    in case-insensitive mode.

    |`!*`
    |`_STRING !* PATTERN_`
    |Returns 1 if the string does not match the specified pattern,
    else 0. The matching is done as for the Tcl `string match` command.

    |`!*^`
    |`_STRING !*^ PATTERN_`
    |Returns 1 if the string does not match the specified pattern,
    else 0. The matching is done as for the `string match` command
    in case-insensitive mode.

    |===

    Note that for the regular expression and pattern match operators,
    the order of the operands is significant - the first indicates 
    the string being matched and the second is the pattern or regular
    expression.

    [TIP]
    In the matching operators shown above, the first character,
    `=` or `!`, indicates the sense of the match, the second character
    specifies the operation `~` or `*` and the optional third
    character `^`, if present, indicates a case-sensitive match.
    
    .Rules of operation
    
    * If either operand is a table, an error will be generated.

    * If both operands are columns, an error will be generated.

    * If neither operand is a column, the result will be a boolean
    value based on standard Tcl operators or the operators shown
    in ((^ tab_tscript_match_ops)).

    * If (exactly) one of the operands is a column, each element
    of the column is individually compared with the other operand.
    The result
    is an integer column containing the indices of those elements
    for which the specified comparison operation returns true.

    This last rule is illustrated by the example below which prints
    the indices for all months where the rainfall is less than 100mm.
} tscript {
    print(Rainfall < 100)
} text {
    The real usefulness of this will become apparent when we discuss
    ((^ sect_tscript_indexing_ops "indexing operators")).

    [NOTE]
    ====
    TScript does not allow expressions of the form
} syntax {
    a < b < c
} text {
    on the basis that more often than not these are programming errors.
    This holds only for all relational operators, not arithmetic or logical
    operators. In the rare case that you need such expressions, use
    parenthesis to appropriately group the operands.
    ====
}
text {
    ((=== sect_tscript_logic_ops "Logical operators"))

    The logical operators include `&&` and `||` as in Tcl.
    _However, unlike Tcl these operators do not short-circuit the evaluation
    of their operands._

    .Rules of operation

    * If either operand is a table, an error will be generated.

    * If neither operand is a column, the result will be a boolean
    value based on standard Tcl operators.

    * If both operands are columns, the operation is treated
    as a set operation and described in ((^ sect_tscript_set_ops)).

    * If one operand is a column and the other is not, an error is
    raised.
}

text {
    ((=== sect_tscript_set_ops "Set operators"))

    The operators `&&` and `||` behave as set operators when both
    operands are columns. In this case, both operands must be of
    the same type.

    The `&&` operator returns a column of the same type as the operands
    and containing elements that are common to both.
    
    The `||` operator returns a column of the same type as the operands
    and containing elements that are present in either operand.
} tbd {
    Update docs with respect to uniqueness
}

text {
    ((=== sect_tscript_lookup_ops "Lookup operators"))

    The operators `'` and `%` lookup keys in a dictionary
    or column.

    In the case of a dictionary, the operators retrieve
    the value associated with the key.

    The `'` operator takes the key as a literal value and returns
    the corresponding element from the dictionary. If the key follows
    the syntax for an identifier, it does not have to be quoted.
} prompt {} tshell {
    d = <dict create one 1 two 2 three 3 4 four "number five" 5> 
    d'two                 # String key "two" does not need quoting
    d ' "number five"     # Quoted string literal key
    d ' three             # Note whitespace is optional
    d'4                   # Numeric literal
} text {
    On the other hand, the `%` operator takes an operand that
    is the _name of the variable_ containing the key.
} prompt {} tshell {
    key = "number five"
    d%key
    d % key           # Note whitespace is optional
} text { 
    In the case of a column
    the lookup returns the index of the specified value. If the
    value occurs multiple times in the column, any of the corresponding
    indices may be returned.
} prompt {} tshell {
    Emps'Name'Sally
    colname = "Name"
    Emps%colname'Sally
} text {
    In the prior example, note the overloading of the `'` and `%`
    operators. When applied to tables, they act as column selectors.
    When applied to columns (selected from the table in this case)
    they act as lookup operators.

    In all cases, an error is raised if the value being looked up
    does not exist in the dictionary or column.

    These operators can also be used on the left hand side of an
    assignment to set new values.
} prompt {} tshell {
    d'c = 99

    I = @string {'zero, 'one, 'two, 'three}
    I'one = 1
} text {
    [NOTE]
    If a variable does not already exist, the operator creates it
    as a dictionary.
}

text {
    ((=== sect_tscript_indexing_ops "Indexing and search operators"))

    Much of the convenience of TScript in dealing with columns and tables
    stems from its variety of indexing options. Indices may be simple
    numerics, ranges, lists or selectors based on boolean expressions.

    The flexibility of index selectors also means that they are the primary
    means of searching tables and columns for elements matching desired
    criteria. Many indexing and search operators can also be used
    with lists.
}

text {
    ==== Integer indices

    In the simplest case, an index is simply a integer value, specified
    as a literal or an expression that results in a integer value. As
    the operand of the `[]` operator, it retrieves the value of the element
    at that position.
} prompt {} tshell {
    Rainfall[0]          # Index a column with a constant

    i = 1
    Emps[i]              # Index a table with a variable
    
    {1, 2, 3, 4}[i+2]    # Index a list with an expression
} text {
    Note that the result is a ''scalar'', the value of the element at
    that position, not a column or table containing that element.
}

text {
    ==== Index ranges
    
    Alternatively, the index may specify an _index range_
    in the column or table using the syntax `_LOWEXPR_ : _HIGHEXPR_`.
    So, the rainfall for the first quarter can be retrieved by
} tscript {q1_rainfall = Rainfall[0:2]} text {
    In this case the index operator returns a column (or table)
    containing the specified elements. Thus notice the difference
    between
} tscript { Rainfall[0] } text {
    and
} tscript { Rainfall[0:0] } text {
    though they both specify a single element.

    The range limits may be expressions that result in integer
    values.
} tscript {
    i = 0
    print(Emps[i:%Emps-1])
} text {
    Again, ranges may be used with lists as well.
} tscript {
    {1, 2, 3, 4}[1:2]
} text {
    We shall also see later that ranges can also be combined with
    selectors to further focus search and indexing operations.
}

text {    
    ==== Index lists

    The third form of an index is an _index list_. Here you can
    specify a list of integers or a column of type `int` that
    contain the numeric indices of interest.
} tscript {
    i = 10
    Rainfall[{9, i, 11}]
} text {
    We could have specified a column of type `int` instead.
} tscript {
    indices = @int {11, 10, 9}
    Rainfall[indices]
} text {
    Notice that an index list (or column) does not need to contain
    the indices in order and may even contain duplicate indices.
    The values returned are in the order of specified indices.

    Again, make a note of the difference with respect to a simple
    numeric index
} tscript { Rainfall[0] } text {
    which returns the element, versus
} tscript {
    Rainfall[@int {0}] 
} text {
    which returns a column containing that single element.

    Like simple indices and ranges, index lists can be used with
    lists as well.
} tscript {
    {1, 2, 3, 4}[@int{0, 2, 1, 3}]
}

text {
    ==== Selectors

    The final form an index can take is that of a _selector_ which
    is a boolean expression involving the column or table.

    As we noted in ((^ sect_tscript_column_rel_ops "column operators"))
    comparison of a column with a scalar value results
    in an `int` column containing the indices for which the comparison
    of the corresponding element succeeded. This implies that
    the boolean expression can be used as an expression that return
    an index list.
    
    [WARNING]
    Unlike other indexing operations, selectors will not work as
    expected with Tcl lists. In particular, Tcl lists in boolean
    expressions are treated as any other Tcl value and do not return
    an index column.

    As a simple example of a selector, consider the following expression:
} tscript { Rainfall > 100 } text {
    The return value is a column containing the indices corresponding
    to the elements which have a value greater than `100`.

    Therefore, we can use such boolean selectors as indices to 
    retrieve the actual values themselves.
} tscript { Rainfall[Rainfall > 100] } text {
    Selectors can be used for tables as well with the operand being
    a contained column. Moreover, the selector need not be a simple
    boolean expression. The following prints all employees who are
    over 35 but have an income less than `70,000`.
} outputlimit 0 tscript {
    print(Emps[Emps'Age > 35 && Emps'Salary < 70000]) 
}

text {
    ===== Ranges in selectors

    Selectors can include ranges as well.
    For example, the rainfall in the last quarter that
    exceeds 50mm is given by
} tscript { Rainfall[9:11 && Rainfall > 50] } text {
    [WARNING]
    A selector can include function calls as well. However, note
    that the function is called just once, not once per element
    of the column or table.

    Because of their flexibility, selectors are the mechanism
    for doing searches in columns and tables.
}

text {
    ===== The `@@` selector context

    In previous examples, we supplied the variable containing the table
    or column, for example `Emps`, to the selector expression. In some
    cases, the table or column may not stored in a variable, for example
    when it is a function return value or when it is generated through
    an expression. In this case the `@@` special token may be used to
    reference the table instead of storing the generated value in
    a temporary for naming purposes. This is illustrated in the
    following example.
} shell {
    proc get_table {} { return $::Emps }
    tscript { print( get_table() [@@'Age > 35 && @@'Salary < 70000]) }
}

text {
    ==== Using indices in assignments
    The various forms of indexing can also be
    used in the left side of assignments. We have already seen some
    examples earlier. Below are some slightly more involved examples.
} text {
    To move everyone to Boston, fill the entire range with one value.
} tscript {
    Emps'Location[0 : %Emps - 1] = 'Boston
} text {
    To give an increment only to low-paid
    employees make use of selectors.
} outputlimit 0 tscript {
    Emps'Salary[Emps'Salary < 50000] = Emps'Salary[Emps'Salary < 50000] + 2000;
    print (Emps)
} text {
    To modify a subset of the fields for a specific row,
    index a slice of the table. So to relocate Sally with a raise
} outputlimit 0 tscript {
    Emps'(Salary, Location)[Emps'Name'Sally]  = {70000, 'Seattle}
    print (Emps[Emps'Name == 'Sally])
} text {
    Use of indices in assignments is not limited to columns and rows.
    List elements can be assigned in the same manner.
} prompt {} tshell {
    l = {1, 2, 3}
    l[0] = 101
    l[{3,4}] = 1000
} text {
    [WARNING]
    ====
    Because Tcl is untyped, assigning to lists using indices can be ambiguous.
    For example, compare the results of the following two statements:
} prompt {} tshell {
    I = @int {1, 2, 3, 4}
    I[0:1] = 100
    I[2:3] = {102, 103}
    
    l = {1, 2, 3, 4}
    l[0:1] = 100
    l[2:3] = {102, 103}  # Ambiguity, assumes a fill operation
} text {
    In the first case, values 102 and 103 are assigned to consecutive list
    elements. Because the column is typed as integer, TScript can deduce the
    intended operation in both assignments to `I`. In the case of the
    second assignment to the list, there is ambiguity because lists can
    contain elements of any type. Thus the statement could be interpreted
    as filling the range with a single value or as assigning consecutive
    elements of the right hand list. In such a case, TScript assumes
    a fill operation is intended.

    Similar situations can also arise when the column is of type `any` since
    columns of that type can hold any type of value.
    ====
}

text {
    ((=== sect_tscript_misc_ops "Miscellaneous operators"))
}

text {
    ==== The `%` size operator

    The unary operator `%` returns the size
    of its operand which must be a list, column or table.
} prompt {} tshell {
    len = % {1,2,3,4}   # Length of a list
    % Rainfall          # Size of a column
    % (Rainfall > 100)  # Size of a column returned by an expression
    nemps = % Emps      # Size of a table
}

text {
    ((=== sect_tscript_deref_op "The `$` dereferencing operator"))

    The operator `$` is a unary operator that dereferences
    the value of its operand. We have already seen an example of its use
    ((^ sect_tscript_calling_methods earlier)) in calling object methods.

    The operator can only be applied to an identifier or a string literal
    and not to an arbitrary expression. In both cases, it returns the
    value of the variable whose name is given by the operand value.
    
    The operator is useful in a couple of different situations. One is
    when you need to reference a variable that does not follow TScript
    identifier syntax, e.g. one with spaces in it, as shown in the
    Tcl code below. The other is when the variable is to be referenced
    indirectly.

    As an example, suppose you had the following
} shell {
    set "variable with spaces in name" "value of variable with spaces"
    set varname "variable with spaces in name"
} text {
    Then the equivalent of the Tcl code
} shell {
    puts ${variable with spaces in name}
    puts [set $varname]
} text {
    would be the following in TScript
} prompt {} tshell {
    puts($"variable with spaces in name")
    puts($varname)
} text {
    [NOTE]
    Dereferencing operators cannot be used on the left hand side
    of an assignment statement.
}

text {
    == Built-in functions

    A number of `tarray` commands that are not implemented as operators,
    or for which only a subset of functionality is available through operators,
    are available as built-in functions. These built-in functions can
    always be invoked through the normal function call mechanism using
    their qualified name (for example, `column.reverse`). However, invoking
    them as built-ins has some convenience like polymorphism and slightly
    shorter syntax.

    [NOTE]
    The documentation provides a summary of the built-in functions.
    For full details you can refer to the documentation for
    the corresponding `tarray` command.
}

text {
    === The `@delete` function
    The `@delete` deletes elements from a column or table. It has one
    of two forms:
} syntax {
    @delete(__COLUMN_OR_TABLE__, _FIRST_, _LAST_)
    @delete(__COLUMN_OR_TABLE__, _INDICES_)
} text {
    The first form deletes all elements in the index range from _FIRST_
    to _LAST_. The second form deletes the elements whose indices are
    specified by _INDICES_ which may be a single index, an index column
    or a list of indices.

    So for instance we could get rid of all our high-priced employees.
} outputlimit 0 tscript {
    Emps = @delete(Emps, Emps'Salary > 75000)
    print(Emps)
}

text {
    === The `@inject` function
    The assignment operators in TScript cannot be used to insert elements
    between two elements in a column or rows in a table. The `@inject`
    and `@insert` functions are provided instead for that purpose. The
    `@inject` command inserts the contents of a list or column (table)
    into another and returns the result. The syntax is
} syntax {
    @inject(__COLUMN_OR_TABLE__, _SOURCE_, _START_)
} text {
    where _SOURCE_ is a list or column (table) to be inserted at position
    _START_ in __COLUMN_OR_TABLE__. For example, we can add a couple
    of low priced lackeys to replace the ones we layed off.
} outputlimit 0 tscript {
    Emps = @inject(Emps, {
        {'Tom,      30000,      38,       'Boston},
        {'Peyton,   30000,      38,       'Denver}
    }, 0)
    print(Emps)
} text {
    We supplied a list of rows to be added above but we could also have
    specified a compatible table instead.
}

text {
    === The `@insert` function
    The `@insert` function is similar to `@inject` but inserts a _single_
    repeated value  or row into a column or table. It has the syntax
} syntax {
    @insert(__COLUMN_OR_TABLE__, _VALUE_, _START_ ?, _COUNT_?)
} text {
    The function inserts _COUNT_ instances of _VALUE_ at the index position
    _START_. _COUNT_ defaults to 1 if unspecified.
} prompt {} tshell {
    @insert (@int {1,2,3}, 99, 0)

    @insert (@int {1,2,3}, 100, 1, 2)
}

text {
    === The `@lookup` function

    The function returns the index of an element in a column _which
    must be of type `string`. It has the syntax
} syntax {
    @lookup(_STRINGCOLUMN_ ?, _KEY_?)
} text {
    The command returns the index of an element in _STRINGCOLUMN_ that exactly
    matches _LOOKUPKEY_ or -1 if not found. If _KEY_ is not specified,
    command builds an internal dictionary (see below) and the return value
    is an empty string.

    Unlike the `@search`
    command, the returned index is not necessarily that of the first
    occurence in cases where _KEY_ occurs multiple times in the column.

    The primary purpose of this function is to provide fast 
    access to columns that are used as an index.
    For more details, see the documentation for the
    ((^ column_lookup "column lookup")) command.
}

text {
    === The `@reverse` function
    The `@reverse` function reverses columns and tables.
} tscript {
    @reverse (@int {1,2,3})
} 

text {
    === The `@search` command
     
    The `@search` command searches a specified column and returns
    matching elements or the corresponding indices.
    Unlike most of the other built-ins, `@search` is called as a command
    and does not use the standard function call notation. It can
    take one of two forms. In the first form, the search target is specified
    directly:
} syntax {
    @search _COLUMNEXPR_ _RELOP_ _EXPRESSION_ ?_SEARCHOPTIONS_?
} text {
    In this form, _COLUMNEXPR_ can be any expression that results in
    a column value. _RELOP_ is any
    ((^ sect_tscript_rel_ops "relational operator")). Without any options
    specified, the command returns the index of the first element
    of the column that matches _EXPRESSION_.
    _SEARCHOPTIONS_ is a space-separated
    list of options that modify this behaviour. The possible
    option values are shown in ((^ tab_tscript_search_options)).

    ((.Table tab_tscript_search_options "@search options"))
    [cols="20,80", options="header"]
    |===
    |Option
    |Description

    |all
    |If specified, a column containing _all_ matching elements
    are returned as opposed to just the first match. The type of the column
    is `int` if the `inline` option is not specified. Otherwise it
    is the type of the search target.

    |inline
    |If specified, the command returns the value, or values if the `all`
    option is specified, of the matching element, or elements, as opposed
    to their indices.
    
    |===

    The following examples illustrate the various combinations.
} prompt {} tshell {
    @search Emps'Salary > 40000
    
    @search Emps'Salary > 40000 all
    
    @search Emps'Salary > 40000 inline
    
    @search Emps'Salary > 40000 inline all
} text {
} text {
    The second form that `@search` takes is
} syntax {
    @search _INDEXCOLUMN_ -> _COLUMNEXPR_ _ _RELOP_ _EXPRESSION_ ?_SEARCHOPTIONS_?
} text {
    In this case, _INDEXCOLUMN_ is expected to contain indices into
    the column _COLUMNEXPR_ and the search only examines the corresponding
    elements for a match. In all other respects, this form of the command
    behaves the same as the first form. See the next section for an
    example.
} text {
    .Search versus selectors
    Given that selectors perform a similar function to `@search`, when might
    one be preferred to the other?

    The selector form is more succint, convenient and not
    limited in its expressive power related to conditions. However,
    the search command in the current implemenation has some
    performance advantages illustrated in the example below.
    
    Suppose we want to list the salaries of 
    all employees in Boston who make more than 45000/year. We could write this
    using selectors.
} tscript {
    print (Emps'Name[Emps'Salary > 45000 && Emps'Location == 'Boston])
} text {
    Alternatively, using `@search`,
} tscript {
    indices = @search (Emps'Salary > 45000) -> Emps'Location == 'Boston all
    print (Emps'Name[indices])
} text {
    In the first case, TScript searches the appropriate columns for
    salaries greater than the specified amount and then again for the
    specified location. Finally, it returns the intersection of the two
    and retrieves those names from the `Name` column of the table.

    In the second case, the list of indices where the salary is greater
    than the specified amount is retrieved. Then _only those elements_
    are searched for the location. Consequently, this method is significantly
    faster for large data sets.

    [NOTE]
    This performance benefit is only true because the current
    TScript optimizer is extremely rudimentary and not capable of
    recognising and transforming the selector into the more efficient
    form. It is hoped future releases will improve on this.
}

text {
    === The `@sort` command
    The `@sort` command provides a flexible mechanism for sorting columns.
    Like `@search` and unlike most of the other built-ins,
    `@sort` is called as a command
    and does not use the standard function call notation. It can
    take one of two forms. In the first form, the sort target is specified
    directly:
} syntax {
    @sort _COLUMNEXPR_ ?_SORTOPTIONS_?
} text {
    In this form, _COLUMNEXPR_ can be any expression that results in
    a column value. The command then returns a column of the same type
    sorted based on the specified options. _SORTOPTIONS_ is a space-separated
    list of options that control the sorting operations. The possible
    option values are shown in ((^ tab_tscript_sort_options)).

    ((.Table tab_tscript_sort_options "@sort options"))
    [cols="20,80", options="header"]
    |===
    |Option
    |Description

    |decreasing
    |Sorts in order of decreasing value

    |increasing
    |Sorts in order of increasing value
    
    |indices
    |Specifies that the command should return the indices of the sorted
    values instead of the values themselves.

    |nocase
    |Specifies that sorting should be done in case-insensitive manner
    if the column is of type `string` or `any`. The default is
    a case-sensitive sort.
    
    |===

    So we might want to get the rainfall in sorted order.
}  tshell {
    print (Rainfall)
    
    print (@sort Rainfall)
} text {
    But what is probably more interesting is the order of months so
    we might instead do the following
    (this time choosing a decreasing sort order).
} tshell {
    print (@sort Rainfall decreasing indices)
} text {
    This returns a column of type `int` containing the indices of
    the sorted values.

    The sorted indices are useful in many circumstances. For example,
    we might display the employee database in multiple windows,
    one sorted by age, the other by salary. Instead of keeping
    two copies of the table sorted differently, it is cheaper in
    terms of memory to keep indices sorted differently. For example,
} tshell {
    EmpsByAge    = @sort Emps'Age    indices
    EmpsBySalary = @sort Emps'Salary indices decreasing

    print (Emps[EmpsByAge])

    print (Emps[EmpsBySalary])
} text {
    The second form that `@sort` takes is
} syntax {
    @sort _INDEXCOLUMN_ -> _COLUMNEXPR_ ?_SORTOPTIONS_?
} text {
    Here the sorting is done indirectly. _INDEXCOLUMN_ is an
    integer index column as the ones we computed above. This is
    treated as containing indices into the column _COLUMNEXPR_.
    The return value is _INDEXCOLUMN_ sorted by
    comparing the corresponding values from the column
    _COLUMNEXPR_.

    There are a couple of scenarios where this is useful. One is
    in keeping a stable sort order when sorting successively on
    multiple keys. This is discussed in detail in
    ((^ sect_guide_sort_stability)) in the ((^ chap_guide)).

    The other example is when only a subset of a column or
    table is to be sorted. If we wanted to list salaries in
    sorted order but only for employees older than 35, we
    could do the following:
} prompt {} tshell {
    OlderEmployees = Emps'Age > 35
    
    print (Emps[@sort OlderEmployees -> Emps'Salary])
} text {
    Or if you want to save on lines,
} prompt {} tshell {
    print (Emps[@sort (Emps'Age > 35) -> Emps'Salary])
} text {
    This method is a lot cheaper than working directly with the table.
}

text {
    === The `@sum` function

    The `@sum` function returns the sum of the elements in a column.
} syntax {
    @sum(__NUMERIC_COLUMNEXPR__)
} text {
    So to get our annual salary expenditure,
} tscript {
    @sum(Emps'Salary)
}

