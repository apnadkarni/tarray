text {
    ((= chap_tscript "The TScript Language"))
    include::header.ad[]

    ((author "Ashok P. Nadkarni"))
}

text {
    == Introduction

    The ((^ chap_intro `tarray`)) Tcl extension implements _typed arrays_,
    which stores data in native format and provides efficient memory
    utilization and parallelized processing. Columns store elements
    of a single type, while tables, similar to data frames in the R
    language, are a ordered sequence of named columns. The `tarray`
    extension provides the corresponding
    ((^ chap_column_ref `column`)) and ((^ chap_table_ref `table`))
    Tcl commands for their manipulation.

    [TIP]
    This document assumes the reader is familiar with typed arrays.
    If not, please glance through the ((^ chap_guide)) before continuing.
    
    The TScript language is an alternative for 
    working with typed array columns and tables. It provides 
    
    * convenient succint syntax
    * vector operations
    * search operators
    * flexible indexing

    As an example, the statement
} syntax {
    Emp'Salary[Emp'Salary < 50000 && Emp'Age > 35] = 50000
} text {
    raises the salary of all underpaid older employees to a minimum level.

    TScript is embedded in Tcl and is executed through the `tscript`
    command. Tcl and TScript can be freely invoked from each other
    at a fine-grained level allowing the two to be intermixed according to
    whatever syntax suits the task.
} tbd {
    Example of intermixing
} text {
    Neverthess, TScript is syntactically completely different from Tcl.
}

text {
    == Running a TScript program

    TScript is part of the `tarray` package which is loaded as
} shell {
    package require tarray
    namespace path tarray;      # Permits us to use the column and table commands without qualification
} eval {
    source ../src/teval.tcl
} text {
    TScript is invoked from Tcl with the `tscript` command. For example,
    the above statement would be invoked from Tcl as 
} syntax {
    tscript {
        Emp.Salary[Emp.Salary < 50000 && Emp.Age > 35] = 50000
    }
} text {
    The `tscript` command itself returns the result of the last statement
    executed.
}

text {
    For demonstrative purposes, this document makes use of the following
    sample data. A column signifying the amount of rainfall during a 
    particular year
} shell {
    set Rainfall [column create double {
        11.0 23.3 18.4 14.7 70.3 180.5 210.2 205.8 126.4 64.9 33.1 19.2
    }]
} text {
    We also use a table containing a simple employee data base:
} shell {
    set Emps [table create {
        Name string Salary uint Age uint Location string
    } {
        {Sally      70000       32       Boston}
        {Tom        65000       36       Boston}
        {Dick       80000       40       {New York}}
        {Harry      45000       37       {New York}}
        {Amanda     48000       35       Seattle}
    }]
} text {
    For readability purposes, we will often make use of the `tarray::print`
    command.
} shell {
    print $Emps
}

text {
    ((== sect_basic_tscript_syntax "Basic TScript syntax"))

    The basic syntax of TScript is closer to the C family of languages
    than to Tcl.

    === Statements

    Like Tcl, a TScript script is a sequence of statements separated
    by either a newline character or a semicolon.
} shell {
    tscript {
        x = 2
        y = 3 ; z = x*y
    }
} text {
    A statement may be an assignment as above, or simply an expression:
} shell {
    tscript {10*x + y}
}

text {
    === Comments

    Comments begin with the `//` sequence and extend to the end of the line.
}

text {
    === Variables

    As seen above, variables are syntactically different from Tcl:

    * There is no preceding `$` as in Tcl for accessing a variable's value.
    * Variable names are restricted to starting with an alphabetic
    character and may only contain alphanumeric characters, `_` and
    `:`.

    The variables themselves are standard Tcl variables and follow
    the same name resolution rules.
} shell {
    set v "This is a variable"
    tscript { v = "Modified from tscript" }
    puts $v
}

text {    
    === Literals

    Numeric literals are as in Tcl and have the same syntax as in Tcl.
    For example,
} shell {
    tscript {
        r = 2.0e10
        big = 123455678987654321000000000
    }
} text {

    String literals are delimited by double quotes and follow
    the backslash substitution rules as in Tcl.

    Unlike in Tcl, _a plain unquoted string is treated as an identifier_ and
    not a string literal.
} errorok 1 shell {
    tscript {s = unquoted}
} text {
    Also, unlike in Tcl double quoted strings, there is no
    interpolattion.
} shell {
    set s "Tcl does [set x] interpolation"
    tscript { s = "Tcl does [set x] interpolation" }
} text {
    Also note that braces have different semantics in TScript and
    cannot be used to delimit strings.
} text {
    An alternate form of a string literal is a `'` character preceding
    a string that follows the rules for an identifier.
} shell {
    tscript { s = 'this::is::a::string }
} text {
    This alternate form is merely a small convenience.
}

text {
    === Lists

    Braces in TScript are used to construct lists, similar to the
    `list` command in Tcl. _Note this differs from the use of braces in Tcl._
} shell {
    tscript {
        l = {"a string", x, tcl::clock::seconds(), y+z}
    }
} text {
    The list elements are separated using commas and an element may
    be a literal, variable, function call or general expression.

    As an aside, we could also have invoked the Tcl `list` command
    as a function to construct a list.
} shell {
    tscript {l = list(x,"a string",y+z)}
}

text {
    === Invoking commands

    Invocation of commands takes a form similar to function calls in C. 
    Function parameters are wrapped in parenthesis and separated by commas.

} shell {
    tscript {
        hex = format("0x%x", 42)
    }
} text {
    The above calls Tcl's built-in `format` command.
    There is no difference between invoking commands implemented in Tcl or
    in TScript via the `tproc` procedure.

    [WARNING]
    ====
    There is a subtle
    point to be noted when invoking commands from TScript as opposed to Tcl.
    In TScript, a parameter that is not a literal is implicitly dereferenced
    when passed to a command. It is easy to forget this when calling
    Tcl commands that take variable _names_ as parameters.
    Thus 
    ----
    incr val -1
    ----
    is _not_ 
    ----
    tscript { incr(val, -1) }
    ----
    which lands up passing the _value_ of `val` to the `incr`
    command which actually expects the name `val` itself to be the argument.

    The correct equivalents are either of the following:
    ----
    tscript { incr("val", -1) }
    tscript { incr('val, -1) }
    ----
    ====
} 

text {
    ==== Calling ensemble commands

    Ensemble commands such as `clock seconds` are called from TScript as
} shell {
    tscript {clock.seconds()}
} text {
    Note the use of `.` as the separator between the command and its
    subcommand. Depending on how the ensemble is defined, you can
    also directly invoke it.
} shell {
    tscript {tcl::clock::seconds()}
} text {
    Finally, in the very rare case that the ensemble subcommand does
    not fit the syntax for a TScript identifier, you can pass it as the
    first argument.
} shell {
    tscript {clock("seconds")}
}

text {
    ==== Calling object methods

    Object methods are called in a manner similar to ensemble commands.
} shell {
    oo::class create OExample { method m args {puts [join $args ,]} }
    OExample create o
    tscript {
        o.m('astring, 10)
        o.destroy()
    }
} text {
    However, there is an additional case here where the name of the
    object is not fixed and the object is accessed through a variable.
} errorok 1 shell {
    set obj [OExample new]
    tscript {obj.m('astring, 10)}
} text {
    _Function and object names, unlike variables, do not get implicitly
    dereferenced._
    In this case, the `$` operator is used for dereferencing.
} shell {
    tscript {
        $obj.m('astring, 10)
        $obj.destroy()
    } 
} text {
    We will talk about the dereferencing operator
    ((^ sect_tscript_deref_op later)).
}

text {
    ==== Passing options to commands

    When passing options to commands, TScript supports an additional
    syntax for arguments where the option name does not have to be
    quoted or separated from its value by a `,`.

    Instead of invoking the Tcl `subst` command as follows
} shell {
    tscript { subst("-novariables", "The value of val is $val") }
} text {
    it can be invoked as
} shell {
    tscript { subst(-novariables "The value of val is $val") }
} text {
    Note the option name is not quoted and there is no `,` separating
    it from its value.

    TScript recognizes this form based on the argument being composed
    of two expressions with the first one being a token
    starting with a `-` character.
}

text {
    === Operators

    Operators work with two kinds of operands

    * standard Tcl values
    * columns and table, and

    We only discuss the former here. Operations on columns and tables
    are discussed later. Note that neither of the Tcl operators
    and the TScript operators is a subset of the other.

    Operator precedence follows that of Tcl.

    ==== Arithmetic operators

    The arithmetic operators supported by TScript are based on those in
    Tcl. 

    * The unary operators include `-`, `+`, `~` and `!`.
    * The binary operators include `+`, `-`, `*`, `/`, `**`, `&`, `|`, `^`

    ==== Relational operators
    
    The relational operators include the `==`, `!=`, `<`, +<=+, `>`, `>=`
    operators that are present in Tcl.

    In addition, they include the additional operators related
    to string and pattern matching that are shown in 
    ((^ tab_tscript_match_ops)).
    
    ((.Table tab_tscript_match_ops "TScript arithmetic operators"))
    [cols="10,30,60", options="headers"]
    |===
    |Operator
    |Syntax
    |Description

    |`=^`
    |`_STRINGA_ =^ _STRINGB_`
    |Returns 1 if the two strings are equal in case-insensitive mode, else 0.

    |`!^`
    |`_STRINGA_ =^ _STRINGB_`
    |Returns 1 if the two strings are not equal in case-insensitive mode, else 0.

    |`=~`
    |`_STRING =~ REGEXP_`
    |Returns 1 if the string matches the specified regular expression, else 0.

    |`=~^`
    |`_STRING =~^ REGEXP_`
    |Returns 1 if the string matches the specified regular expression, else 0.
    The matching is done in case-insensitive mode.

    |`!~`
    |`_STRING !~ REGEXP_`
    |Returns 1 if the string does not match the specified regular expression,
    else 0.

    |`!~^`
    |`_STRING !~^ REGEXP_`
    |Returns 1 if the string does not match the specified regular expression,
    else 0. The matching is done in case-insensitive mode.

    |`=*`
    |`_STRING =* PATTERN_`
    |Returns 1 if the string matches the specified pattern, else 0.
    The matching is done as for the Tcl `string match` command.

    |`=*^`
    |`_STRING =*^ PATTERN_`
    |Returns 1 if the string matches the specified pattern, else 0.
    The matching is done as for the `string match` command
    in case-insensitive mode.

    |`!*`
    |`_STRING !* PATTERN_`
    |Returns 1 if the string does not match the specified pattern,
    else 0. The matching is done as for the Tcl `string match` command.

    |`!*^`
    |`_STRING !*^ PATTERN_`
    |Returns 1 if the string does not match the specified pattern,
    else 0. The matching is done as for the `string match` command
    in case-insensitive mode.

    |===

    Note that for the regular expression and pattern match operators,
    the order of the operands is significant - the first indicates 
    the string being matched and the second is the pattern or regular
    expression.

    [TIP]
    In the matching operators shown above, the first character,
    `=` or `!`, indicates the sense of the match, the second character
    sepcifies the operation `~` or `*` and the optional third
    character `^`, if present, indicates a case-sensitive match.
    
    ==== Logical operators

    The logical operators include `&&` and `||` as in Tcl.
    _However, unlike Tcl these operators do not short-circuit the evaluation
    of their operands._

    ==== List operators

    ===== The unary `#` operator for lists

    TScript supports the unary operator `#` which returns the length
    of its list operand. This operator also supports columns and tables
    as we will see later.
} shell {
    set l {a b c d e}
    tscript { len = # l }
    tscript { len = # {1,2,3,4} }
}

text {
    ==== Dictionary operators

    ===== The `#` and `'` dictionary operators

    The `#` and `'` operators both retrieve values from Tcl dictionaries.
    The `'` operator takes the key as a literal value and returns
    the corresponding element from the dictionary.
} shell {
    set d [dict create a 1 b 2 c 3 d 4]
    tscript { d'c}
    tscript { d ' c };           # Note whitespace is optional
} text {
    On the other hand, the `#` operator takes an operand that
    is the _name of the variable_ containing the key.
} shell {
    set key c
    tscript { d#key}
    tscript { d # key };           # Note whitespace is optional
} 

tbd {
    ==== The `$` dereferencing operator
}

text {
    == Columns and tables

    We now come to the primary reason for the existence of TScript -
    convenient vector operations on columns and tables.

} text {
    === Creating columns and tables

    Columns are created using the built-in operators `@boolean`,
    `@byte`, `@int`, `@uint`, `@wide`, `@double`, `@string` and `@any`.
} shell {
    tscript { A = @int }
} text {
    creates an empty column of type `int` and assigns it to `A`.

    An optional operand, containing a list of values of the appropriate
    type may be passed to initialize the column.
} shell {
    tscript { A = @any {10, {1, 2, 3}, len} }
} text {
    creates a column of type `any` with 3 elements.

    There are no built-in operators for defining tables. These
    are most conveniently created from Tcl using the
    ((^ table_create "table create")) command.

} text {
    === Indexing and search

    Much of the convenience of TScript in dealing with columns and tables
    stems from its variety of indexing options. Indices may be simple
    numerics, ranges, lists or selectors based on boolean expressions.

    The flexibility of index selectors also means that they are the primary
    means of searching tables and columns for elements matching desired
    criteria.

    ==== Integers

    In the simplest case, an index is simply a integer value, specified
    as a literal or an expression that results in a integer value. As
    the operand of the `[]` operator, it retrieves the value of the element
    at that position.
} shell {
    set i 1
    tscript { Rainfall[0] }
    tscript { Emps[i] }
} text {
    Note that the result is a ''scalar'', the value of the element at
    that position, not a column or table containing that element.
} text {
    ==== Index ranges
    
    Alternatively, the index may specify an _index range_
    in the column or table.
    So, the rainfall for the first quarter can be retrieved by
} shell {
    tscript {q1_rainfall = Rainfall[0:2]}
} text {
    In this case the index operator returns a column (or table)
    containing the specified elements. Thus notice the difference
    between
} shell {
    tscript { Rainfall[0] }
    tscript { Rainfall[0:0] }
} text {
    though they both specify a single element.

    Of course, the range can be specified via variables as well.
} shell {
    tscript {
        i = 0
        j = 2
        print(Emps[i:j])
    }
} text {
    We shall also see later that ranges can also be combined with
    selectors to further focus search and indexing operations.
} text {    
    ==== Index list

    The third form of an index is an _index list_. Here you can
    specify a list of integers or a column of type `int` that
    contain the numeric indices of interest.
} shell {
    tscript {
        i = 10
        Rainfall[{9, i, 11}]
    }
} text {
    We could have specified a column of type `int` instead.
} shell {
    set indices [column create int {11 10 9}]
    tscript {Rainfall[indices]}
} text {
    Notice that an index list (or column) does not need to contain
    the indices in order and may even contain duplicate indices.
    The values returned are in the order of specified indices.

    Again, make a note of the difference with respect to a simple
    numeric index
} shell {
    tscript { Rainfall[0] }
} text {
    which returns the element, versus
} shell {
    set indices [column create int {0}]
    tscript { Rainfall[indices] }
} text {
    which returns a column containing that single element.

    ==== Selectors

    The final form an index can take is that of a _selector_ which
    is a boolean expression involving the column or table. We will
    detail the mechanism by which this works 
    when we discuss ((^ sect_tscript_column_ops "column operators"))
    but in a nutshell, comparison of a column with a scalar value results
    in an `int` column containing the indices for which the comparison
    of the corresponding element succeeded.
    
    So for example, consider the following expression:
} shell {
    tscript { Rainfall > 100 }
} text {
    The return value is a column containing the indices corresponding
    to the elements which have a value greater than `100`.

    Therefore, we can use such boolean selectors as indices to 
    retrieve the actual values themselves.
} shell {
    tscript { Rainfall[Rainfall > 100] }
} text {
    Selectors can be used for tables as well with the operand being
    a contained column. Moreover, the selector need not be a simple
    boolean expression. The following prints all employees who are
    over 35 but have an income less than `70,000`.
} outputlimit 0 shell {
    tscript { print(Emps[Emps'Age > 35 && Emps'Salary < 70000]) }
} text {
    [NOTE]
    The syntax for referencing a table column using `'` is discussed
    ((^ sect_tscript_table_column_ops later)).

    ===== Ranges in selectors

    Selectors can include ranges as well.
    For example, the rainfall in the last quarter that
    exceeds 50mm is given by
} shell {
    tscript { Rainfall[9:11 && Rainfall > 50] }
} text {
    [WARNING]
    A selector can include function calls as well. However, note
    that the function is called just once, not once per element
    of the column or table.

    Because of their flexibility, selectors are the mechanism
    for doing searches in columns and tables.
} text {
    ===== The `@@` selector context

    In previous examples, we supplied the variable containing the table
    or column, for example `Emps`, to the selector expression. In some
    cases, the table or column may not stored in a variable, for example
    when it is a function return value or when it is generated through
    an expression. In this case the `@@` special token may be used to
    reference the table instead of storing the generated value in
    a temporary for naming purposes. This is illustrated in the
    following example.
} shell {
    proc function_returning_table {} { return $::Emps }
    tscript { print( function_returning_table() [@@'Age > 35 && @@'Salary < 70000]) }
}



text {
    ((=== sect_tscript_column_ops "Column and table operators"))

    ==== Arithmetic operators

    As described in the ((^ column_math "math command")) reference,
    normal scalar Tcl values and columns can be mixed in mathematical
    operations. The scalar values are treated as columns filled
    with that value. Here is an example:
} shell {
    tscript {
        I = @int {10, 20, 30, 40}
        J = @byte {1, 2, 3, 4}
        print(I + 2 * J)
    }
} text {
    TScript supports all the arithmetic operators shown in
    ((^ tab_column_math_ops)).
    
    Tables do not support
    any arithmetic operators but their contained columns can be used anywhere
    that a standalone column is valid.

    For example, we can reduce everyone's salaries by 2K since times
    are tough.
} outputlimit 0 shell {
    tscript {
        Emps'Salary = Emps'Salary - 2000
        print (Emps)
    }
} text {
    Or perhaps even more for highly paid employees.
} outputlimit 0 shell {
    tscript {
        Emps'Salary[Emps'Salary > 65000] = Emps'Salary[@@ > 65000] - 2000;
        print (Emps)
    }
} text {


    ==== Relational operators

    ==== The `#` count unary operator

    ==== The `'` and '#' operators for columns and tables

    ===== Specifying table columns

    ===== Locating column elements

} shell {
    tscript { T = table::delete(Emps, Emps'Salary > 70000) }
}

text {


    ==== Slicing Columns from tables
    T.a versus T.(a, b) Illustrate using print

    Column tables can be used anywhere columns are used including assignments

    === Columns and tables as target of assignment
    T.c
    

}

tbd { sum, minmax, sort etc.}
tbd { namespace and execution context }
