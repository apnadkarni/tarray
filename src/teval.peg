# Much of this based on Phillippe Segaude's example C grammar
# from https://github.com/PhilippeSigaud/Pegged/blob/master/pegged/examples/c.d
PEG TEval (Program)
    # A Program is a sequence of statements
    Program <- WS (Statement (WS Separator WS Statement)*)? WS EOF;
void:  EOF <- !.;

    # A Statement is a function call or an assignment. In particular
    # an arbitrary expression that is not a function call is not allowed.
    Statement <- Assignment / MultiAssignment / Expression / Empty ;
void:    Empty <- WS ;

    # Assignment to a single LValue
    Assignment <- LValue WS AssignOp WS Expression;


    # Assigns multiple variables from a list / tarray. Expression here
    # will be checked at run time to provide multiple values.
    MultiAssignment <- LValue (WS ',' WS LValue)+ WS '=' Expression;

    Expression <- LogicalOrExpr ;
    LogicalOrExpr <- LogicalAndExpr ( WS LogicalOrOp WS LogicalOrExpr)* ;
    LogicalAndExpr <- BitOrExpr (WS  LogicalAndOp WS LogicalAndExpr)* ;
    BitOrExpr <- BitXorExpr (WS BitOrOp WS BitOrExpr)* ;
    BitXorExpr <- BitAndExpr (WS BitXorOp WS BitXorExpr)* ;
    BitAndExpr <- RelExpr (WS BitAndOp WS BitAndExpr)* ;
    RelExpr <- AddExpr (WS RelOp WS RelExpr)* ;
    AddExpr  <- MulExpr (WS AddOp WS AddExpr)* ;
    MulExpr <- UnaryExpr (WS MulOp WS MulExpr)* ;
    UnaryExpr <- PostfixExpr / UnaryOp WS UnaryExpr ;
    PostfixExpr  <- PrimaryExpr (WS PostfixOp)* ;
    PostfixOp <-   '[' WS Selector WS ']' /
    	      	   FunctionOp /
		   SliceOp ;
    PrimaryExpr  <- BuiltinIdentifier / ColumnIdentifier / Identifier / Number / String / Sequence / '(' Expression ')' ;
    FunctionOp <- '(' WS ArgumentExprList? WS ')' ;
    ArgumentExprList <- Expression WS (WS ',' WS Expression)* ;
    SliceOp <- '.' WS (Identifier / IdentifierList) ;

    # Any term that can be assigned to. Note only range based slices
    # are allowed so cannot use VarSlice here.
    LValue <- Identifier (WS '[' WS (Range / Expression) WS ']')? ;

    IdentifierList <- '(' WS Identifier (WS ',' WS Identifier)* WS ')';

    Selector <- RangeAndExpression / Index ;
    RangeAndExpression <- Range (WS '&&' WS Expression)? ;
    Index    <- 'end' / Expression;

    # A range is two integers, both optional, but validity checks are done
    # mostly at run time
    Range <- RangeHigh / RangeFull / RangeLowHigh / RangeLow;

leaf: RangeFull <- ':' ;
RangeLow <- AddExpr WS ':' ;
RangeHigh <- ':' WS AddExpr ;
RangeLowHigh <- AddExpr WS ':' WS AddExpr;   


leaf: BuiltinIdentifier <- [$] Identifier ;
leaf: ColumnIdentifier <- BuiltinIdentifier '.' Identifier ;
leaf: Identifier <- ('_' / '::' / <alpha>) ('_' / '::' / <alnum>)* ;
leaf: Number <- <ddigit> + ('.' <ddigit> + )? ( ('e' / 'E' ) ('+' / '-') ? <ddigit> + )?;
Sequence <- '{' WS (Expression (WS ',' WS Expression)*)? WS '}' ;
leaf: String <- Quote (!Quote Char)* Quote;
void: Char   <- BackSlash ( Quote 
                     / BackSlash
                     / [bfnrt]
                     / 'x' <xdigit> <xdigit> <xdigit>
                     / 'u' <xdigit> <xdigit> <xdigit> <xdigit>
                     / 'U' <xdigit> <xdigit> <xdigit> <xdigit> <xdigit> <xdigit> <xdigit> <xdigit>
                    )
           / . ;
void: Quote <- '"';
void: Backslash <- '\\';

void: Separator <- EOL / ';';

leaf: AssignOp <- '=' / '+=' / '-=' / '*=' / '/=' / '|=' / '&=';

leaf: Sign  <- [-+];
leaf: MulOp       <- '*' / '/'                                    ;
leaf: AddOp       <- '+' / '-'                                    ;
leaf: PowOp       <- '**'                                         ;

leaf: RelOp <- '==' / '!=' / '<=' / '>=' /
               '<' / '>' / '=^' / '!^' / '=~' / '!~' / '=^~' /
               '!^~' / '=*' / '!*' / '=^*' / '!^*';
leaf: UnaryOp <- [-+~!] ;
leaf: RangeOp <- ':' ;
leaf: BitAndOp <- '&' ;
leaf: BitOrOp <- '|' ;
leaf: BitXorOp <- '^' ;
leaf: LogicalAndOp <- '&&' ;
leaf: LogicalOrOp <- '||' ;


void: WS    <- (('\\' EOL) / (!EOL <space>))*;
void: WSob  <- (('\\' EOL) / (!EOL <space>))+;






END;
