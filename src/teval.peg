# Much of this based on Phillippe Segaude's example C grammar
# from https://github.com/PhilippeSigaud/Pegged/blob/master/pegged/examples/c.d
PEG TEval (Program)
    # A Program is a sequence of statements.
    # The Comment? is there because otherwise [tscript {// comment}] errors out
    Program <- WS (Statement (WS Separator WS Statement)*)? WS Comment? EOF;
void:  EOF <- !.;

    # A Statement is a function call or an assignment. In particular
    # an arbitrary expression that is not a function call is not allowed.
    Statement <- Assignment / MultiAssignment / Expression / Empty;
void:    Empty <- WS ;

    # Assignment to a single LValue
    Assignment <- LValue WS AssignOp WS Expression;


    # Assigns multiple variables from a list / tarray. Expression here
    # will be checked at run time to provide multiple values.
    # TBD   MultiAssignment <- LValue (WS ',' WS LValue)+ WS '=' Expression;

    # Any term that can be assigned to. Note only range based slices
    # are allowed so cannot use VarSlice here.
    LValue <- Identifier WS (Column / Columns)? (WS '[' WS (Range / Expression) WS ']')? ;

    # Expressions in ascending precedence order
    Expression <- LogicalOrExpr ;
    LogicalOrExpr <- LogicalAndExpr ( WS LogicalOrOp WS LogicalAndExpr)* ;
    LogicalAndExpr <- RangeExpr (WS  LogicalAndOp WS RangeExpr)* ;
    RangeExpr  <- BitOrExpr WS ':' WS BitOrExpr / BitOrExpr ;
    # Following are written as to implement left-associativity
    BitOrExpr <- BitXorExpr (WS BitOrOp WS BitXorExpr)* ;
    BitXorExpr <- BitAndExpr (WS BitXorOp WS BitAndExpr)* ;
    BitAndExpr <- RelExpr (WS BitAndOp WS RelExpr)* ;
    RelExpr <- AddExpr (WS RelOp WS AddExpr)* ;
    AddExpr  <- MulExpr (WS AddOp WS MulExpr)* ;
    MulExpr <- UnaryExpr (WS MulOp WS UnaryExpr)* ;
    UnaryExpr <- PostfixExpr / UnaryOp WS PostfixExpr ;
    PostfixExpr  <- PrimaryExpr (WS PostfixOp)* ;

    # Basic terms
    PrimaryExpr  <- ColumnConstructor
                    / BuiltinIdentifier
		    / Identifier
		    / Number
		    / Token
		    / String
		    / Sequence
		    / '(' Expression ')' ;

    # Postfix operators
    PostfixOp <-  Selector
		  / FunctionCall
		  / Column
		  / Columns ;
    Selector <- '[' WS ('end' / Expression) WS ']' ;
    FunctionCall <- '(' WS ArgumentList? WS ')' ;
    ArgumentList <- Argument (WS ',' WS Argument)* ;
    Argument <- OptionString WS Expression / Expression ;
    Column <- '.' WS ColumnIdentifier ;
    Columns <- '.' WS '(' WS ColumnList? WS ')' ;
    ColumnList <- ColumnIdentifier WS (WS ',' WS ColumnIdentifier)* ;

    ColumnConstructor <- [@] ColumnType WS Sequence? ;

    # Syntax based definitions

leaf: ColumnType <- 'boolean' / 'byte' / 'int' / 'uint' / 'wide' / 'double' / 'string' / 'any' ;
leaf: BuiltinIdentifier <- [$] ([$#] / Identifier) ;
ColumnIdentifier <- Identifier;
leaf: Identifier <- ('_' / '::' / <alpha>) ('_' / '::' / <alnum>)* ;
leaf: OptionString <- '-' ('_' / '-' / <alnum>)+ ;
leaf: Number <- <ddigit> + ('.' <ddigit> + )? ( ('e' / 'E' ) ('+' / '-') ? <ddigit> + )?;
Sequence <- '{' WS SequenceElements? WS '}' ;
SequenceElements <- Expression (WS ',' WS Expression)* ;
leaf: Token <- SingleQuote Identifier ;
leaf: String <- Quote (!Quote Char)* Quote;
void: Char   <- BackSlash ( Quote 
                     / BackSlash
                     / [bfnrt]
                     / 'x' <xdigit> <xdigit> <xdigit>
                     / 'u' <xdigit> <xdigit> <xdigit> <xdigit>
                     / 'U' <xdigit> <xdigit> <xdigit> <xdigit> <xdigit> <xdigit> <xdigit> <xdigit>
                    )
           / . ;
void: Quote <- '"';
void: SingleQuote <- ['] ;
void: Backslash <- '\\';

void: Separator <- Comment? EOL / ';';
void:   Comment <- '//' (!EOL .)* ;
void: EOL <- '\n';

# TBD leaf: AssignOp <- '=' / '+=' / '-=' / '*=' / '/=' / '|=' / '&=';
leaf: AssignOp <- '=' ;

leaf: MulOp       <- '*' / '/'                                    ;
leaf: AddOp       <- '+' / '-'                                    ;
leaf: PowOp       <- '**'                                         ;

# NOTE tokens whose prefixes match shorter tokens need to be listed first!
leaf: RelOp <- '==' / '!=' / '<=' / '>=' / '<' / '>' /
               '=^' / '!^' /
               '=~^' / '=~' / '!~^' / '!~' / 
	       '=*^' / '=*' / '!*^' / '!*';
leaf: UnaryOp <- [-+~!#] ;
leaf: BitAndOp <- '&' ;
leaf: BitOrOp <- '|' ;
leaf: BitXorOp <- '^' ;
leaf: LogicalAndOp <- '&&' ;
leaf: LogicalOrOp <- '||' ;


void: WS    <- (('\\' EOL) / (!EOL <space>))*;
void: WSob  <- (('\\' EOL) / (!EOL <space>))+;






END;
