#
# Copyright (c) 2012-2013, Ashok P. Nadkarni
# All rights reserved.
#
# See the file LICENSE for license
#

package require critcl 3.1
critcl::buildrequirement {
    package require critcl::class
}
critcl::clean_cache
critcl::tcl 8.5
if {[string match "*-gcc" [critcl::targetconfig]]} {
    critcl::cflags -std=gnu99 -Winline
}

critcl::csources tarray.c table.c tasearch.c bitarray.c tasort.c timsort.c timsort_r.c
critcl::tsources tarray.tcl
critcl::cheaders tarray.h timsort-impl.h

critcl::ccode {
#include "tarray.h"
    typedef Tcl_Obj *TArrayObjPtr;

    /* Must match order of TA_FORMAT_* in tarray.h */
    static const char *gFormatOptions[] = {
        "-tarray",
        "-list",
        "-dict",
        NULL
    };

    /*
     * If status is success, sets ip result to ores. Always returns status.
     * ores might be deallocated unless caller makes sure it is holding a 
     * ref count. Primary purpose of this trivial routine is to deal
     * with returning an object that might have been either allocated
     * or be an existing object passed in the objv[] array to a command.
     */
    TA_INLINE TCL_RESULT ta_return_result(Tcl_Interp *ip, TCL_RESULT status, Tcl_Obj *ores)
    {
        Tcl_IncrRefCount(ores);
        if (status == TCL_OK)
            Tcl_SetObjResult(ip, ores);
        Tcl_DecrRefCount(ores);
        return status;
    }

    /*
     * Sets the value of the variable given by ovarname to ovalue and sets the
     * the interp result to the resulting value of the variable (which may be
     * different from ovalue because of traces).
     * 
     * IMPORTANT: Caller should NOT access ovalue again unless it has protected
     * it by bumping its ref count.
     */
    TCL_RESULT ta_set_var_result(Tcl_Interp *ip, TCL_RESULT status, Tcl_Obj *ovarname, Tcl_Obj *ovalue)
    {
        Tcl_Obj *oresult;
        Tcl_IncrRefCount(ovalue);
        if (status == TCL_OK) {
            oresult = Tcl_ObjSetVar2(ip, ovarname, NULL, ovalue, TCL_LEAVE_ERR_MSG);
            if (oresult)
                Tcl_SetObjResult(ip, oresult);
            else
                status = TCL_ERROR;
        }
        Tcl_DecrRefCount(ovalue);

        return status;
    }

}

critcl::cinit {
    TA_ASSERT(ba_sanity_check() == 0);
    g_tcl_list_type_ptr = Tcl_GetObjType("list");
} {
}

critcl::argtype TArrayObjPtr {
    if (tcol_convert(interp, @@) != TCL_OK)
        return TCL_ERROR;
    @A = @@;
}

critcl::argtype thdr_t* {
    if (tcol_convert(interp, @@) != TCL_OK)
        return TCL_ERROR;
    @A = TARRAYHDR(@@);
}

critcl::ccommand tarray::column::create {} {
    int init_size;
    int tatype;
    Tcl_Obj **elems;
    int nelems;
    thdr_t *thdrP;

    if (objc < 2 || objc > 4) {
        Tcl_WrongNumArgs(interp, 1, objv, "TYPE ?INITVAL? ?INITSIZE?");
        return TCL_ERROR;
    }

    if (Tcl_GetIndexFromObj(interp, objv[1], g_type_tokens, "TArrayType",
                            TCL_EXACT, &tatype) != TCL_OK) {
	return TCL_ERROR;
    }

    init_size = 0;
    nelems = 0;
    elems = NULL;
    if (objc > 2) {
        if (Tcl_ListObjGetElements(interp, objv[2], &nelems, &elems) != TCL_OK)
            return TCL_ERROR;
        if (objc > 3) {
            if (Tcl_GetIntFromObj(interp, objv[3], &init_size) != TCL_OK)
                return TCL_ERROR;
        }
    }

    thdrP = thdr_alloc_and_init(interp, tatype, nelems, elems, init_size);
    if (thdrP == NULL)
        return TCL_ERROR;

    Tcl_SetObjResult(interp, tcol_new(thdrP));
    return TCL_OK;
}


critcl::ccommand tarray::column::delete {} {
    Tcl_Obj *tcol;
    int status;

    if (objc != 3 && objc != 4) {
	Tcl_WrongNumArgs(interp, 1, objv, "TARRAY (INDEXLIST | LOW ?HIGH?)");
	return TCL_ERROR;
    }
    
    tcol = objv[1];
    if (Tcl_IsShared(tcol))
        tcol = Tcl_DuplicateObj(objv[1]);

    status = tcol_delete(interp, tcol, objv[2], objc == 4 ? objv[3] : NULL);
    return ta_return_result(interp, status, tcol);
}

critcl::ccommand tarray::column::vdelete {} {
    Tcl_Obj *tcol;
    int status;

    if (objc != 3 && objc != 4) {
	Tcl_WrongNumArgs(interp, 1, objv, "TARRAYVAR (INDEXLIST | LOW ?HIGH?)");
	return TCL_ERROR;
    }
    
    tcol = Tcl_ObjGetVar2(interp, objv[1], NULL, TCL_LEAVE_ERR_MSG);
    if (tcol == NULL)
        return TCL_ERROR;
    if (Tcl_IsShared(tcol))
        tcol = Tcl_DuplicateObj(tcol);

    status = tcol_delete(interp, tcol, objv[2], objc == 4 ? objv[3] : NULL);
    return ta_set_var_result(interp, status, objv[1], tcol);
}

critcl::cproc tarray::column::size {Tcl_Interp* interp TArrayObjPtr tcol} int {
    return tcol_occupancy(tcol);
}

critcl::cproc tarray::column::type {Tcl_Interp* interp TArrayObjPtr tcol} "const char*" {
    return ta_type_string(tcol_type(tcol));
}

critcl::cproc tarray::column::index {Tcl_Interp* interp TArrayObjPtr COLUMN Tcl_Obj* INDEX} ok {
    int ix;
    Tcl_Obj *o;
    if (ta_convert_index(interp, INDEX, &ix, tcol_occupancy(COLUMN)-1, 0, tcol_occupancy(COLUMN)-1) != TCL_OK)
        return TCL_ERROR;
    
    o = tcol_index(interp, COLUMN, ix);
    if (o) {
        Tcl_SetObjResult(interp, o);
        return TCL_OK;
    } else
        return TCL_ERROR;
}

critcl::ccommand tarray::column::get {} {
    Tcl_Obj *tcol;
    int low, count;
    int status;
    int fmt = TA_FORMAT_TARRAY;
    int ta_arg;
    thdr_t *pindices;

    if (objc < 3)
        goto badargs;
    
    /*
     * Parsing is ambiguous. We do not want check if objv[1] is an option
     * directly because it might shimmer a huge tarray into a string.
     * So check for options only if not a tarray. Note it is possible that
     * objv[1] is a tarray even though it's type does not indicate as much.
     * In that the string rep will anyways exist and question of shimmering
     * does not arise.
     */
    if (tcol_affirm(objv[1])) {
        ta_arg = 1;
    } else {
        /* OK, see if it is an option */
        status = Tcl_GetIndexFromObj(NULL, objv[1], gFormatOptions,
                                     "FORMAT", TCL_EXACT, &fmt);
        if (status == TCL_OK)
            ta_arg = 2;
        else
            ta_arg = 1;
        if ((status = tcol_convert(interp, objv[ta_arg])) != TCL_OK)
            return status;
    }
       
    if ((objc - ta_arg) < 2 || (objc - ta_arg) > 3)
        goto badargs;

    switch (objc - ta_arg - 1) {
    case 1:
        switch (ta_obj_to_indices(interp, objv[ta_arg+1], 0, 0, &pindices, NULL)) {
        case TA_INDEX_TYPE_ERROR:
            return TCL_ERROR;
        case TA_INDEX_TYPE_INT:
            Tcl_Panic("ta_obj_to_indices returned TA_INDEX_TYPE_INT when passed NULL pointer");
            break;
        case TA_INDEX_TYPE_THDR:
            tcol = tcol_get(interp, objv[ta_arg], pindices, fmt);
            thdr_decr_refs(pindices);
            break;
        }
        break;
    case 2:
        /* Range LOW HIGH */
        /* TBD - reuse the thdr_t if not shared */
        status = ta_fix_range_bounds(interp, tcol_occupancy(objv[ta_arg]),
                                         objv[ta_arg+1], objv[ta_arg+2],
                                         &low, &count);
        if (status != TCL_OK)
            return TCL_ERROR;
        tcol = tcol_range(interp, objv[ta_arg], low, count, fmt);
        break;
    default:
        goto badargs;
    }

    if (tcol) {
        Tcl_SetObjResult(interp, tcol);
        return TCL_OK;
    } else
        return TCL_ERROR;

badargs:
    Tcl_WrongNumArgs(interp, 1, objv, "?OPTIONS? TCOLUMN (LOW ?HIGH? | INDEXLIST)");
    return TCL_ERROR;

}

critcl::ccommand tarray::column::sort {} {
    Tcl_Obj *tcol;
    int flags, status;

    if (objc < 2) {
	Tcl_WrongNumArgs(interp, 1, objv, "?options? tarray");
	return TCL_ERROR;
    }

    if ((status = tcol_parse_sort_options(interp, objc, objv, &flags)) != TCL_OK)
        return status;

    tcol = objv[objc-1];
    if (Tcl_IsShared(tcol))
        tcol = Tcl_DuplicateObj(tcol);

    status = tcol_sort(interp, tcol, flags);
    return ta_return_result(interp, status, tcol);
}

critcl::ccommand tarray::column::vsort {} {
    Tcl_Obj *tcol;
    int status;
    int flags;

    if (objc < 2) {
    	Tcl_WrongNumArgs(interp, 1, objv, "?options? COLUMNVAR");
        return TCL_ERROR;
    }

    if ((status = tcol_parse_sort_options(interp, objc, objv, &flags)) != TCL_OK)
        return status;

    if (flags & TA_SORT_INDICES) {
        Tcl_SetResult(interp, "Invalid option -indices", TCL_STATIC);
        return TCL_ERROR;
    }

    tcol = Tcl_ObjGetVar2(interp, objv[objc-1], NULL, TCL_LEAVE_ERR_MSG);
    if (tcol == NULL)
        return TCL_ERROR;
    if (Tcl_IsShared(tcol))
            tcol = Tcl_DuplicateObj(tcol);

    status = tcol_sort(interp, tcol, flags);
    return ta_set_var_result(interp, status, objv[objc-1], tcol);
}

critcl::cproc tarray::column::bitsset {Tcl_Interp* interp TArrayObjPtr tcol} ok {
    thdr_t *thdrP = TARRAYHDR(tcol);
    if (thdrP->type != TA_BOOLEAN) {
        Tcl_SetResult(interp, "tarray type is not boolean", TCL_STATIC);
        return TCL_ERROR;
    }
        
    Tcl_SetObjResult(
        interp,
        Tcl_NewIntObj(ba_count_ones(THDRELEMPTR(thdrP, ba_t, 0), 0, thdrP->used)));
    return TCL_OK;
}

critcl::ccommand tarray::column::search tcol_search_cmd

critcl::ccommand tarray::column::insert {} {
    Tcl_Obj *tcol;
    int status;

    if (objc != 4 && objc != 5) {
    	Tcl_WrongNumArgs(interp, 1, objv, "COLUMN (VALUES POSITION | VALUE POSITION COUNT)");
	return TCL_ERROR;
    }
    
    tcol = objv[1];
    if (Tcl_IsShared(tcol))
        tcol = Tcl_DuplicateObj(tcol);
    status = tcol_insert_obj(interp, tcol, objv[2], objv[3], objc == 4 ? NULL : objv[4]);
    return ta_return_result(interp, status, tcol);
}

critcl::ccommand tarray::column::vinsert {} {
    Tcl_Obj *tcol;
    int status;

    if (objc != 4 && objc != 5) {
    	Tcl_WrongNumArgs(interp, 1, objv, "COLUMNVAR (VALUES POSITION | VALUE POSITION COUNT)");
	return TCL_ERROR;
    }
    
    tcol = Tcl_ObjGetVar2(interp, objv[1], NULL, TCL_LEAVE_ERR_MSG);
    if (tcol == NULL)
        return TCL_ERROR;
    if (Tcl_IsShared(tcol))
        tcol = Tcl_DuplicateObj(tcol);
    status = tcol_insert_obj(interp, tcol, objv[2], objv[3], objc == 4 ? NULL : objv[4]);
    return ta_set_var_result(interp, status, objv[1], tcol);
}

critcl::cproc tarray::column::put {Tcl_Interp* interp Tcl_Obj* COLUMN Tcl_Obj* VALUES Tcl_Obj* {FIRST 0}} ok {
    Tcl_Obj *tcol;
    int status;

    tcol = COLUMN;
    if (Tcl_IsShared(tcol))
        tcol = Tcl_DuplicateObj(tcol);

    /* Values may be given as a list or a tarray */
    if (tcol_convert(NULL, VALUES) == TCL_OK) {
        /* It is a tarray. Verify the right type */
        status = tcol_copy_thdr(interp, tcol, TARRAYHDR(VALUES), FIRST, 0);
    } else {
        status = tcol_put_objs(interp, tcol, VALUES, FIRST, 0);
    }

    return ta_return_result(interp, status, tcol);
}

critcl::cproc tarray::column::vput {Tcl_Interp* interp Tcl_Obj* COLUMNVAR Tcl_Obj* VALUES Tcl_Obj* {FIRST 0}} ok {
    Tcl_Obj *tcol;
    int status;

    tcol = Tcl_ObjGetVar2(interp, COLUMNVAR, NULL, TCL_LEAVE_ERR_MSG);
    if (tcol == NULL)
        return TCL_ERROR;
    if (Tcl_IsShared(tcol))
        tcol = Tcl_DuplicateObj(tcol);

    /* Values may be given as a list or a tarray */
    if (tcol_convert(NULL, VALUES) == TCL_OK) {
        /* It is a tarray */
        status = tcol_copy_thdr(interp, tcol, TARRAYHDR(VALUES), FIRST, 0);
    } else {
        status = tcol_put_objs(interp, tcol, VALUES, FIRST, 0);
    }
    return ta_set_var_result(interp, status, COLUMNVAR, tcol);
}

critcl::cproc tarray::column::place {Tcl_Interp* interp Tcl_Obj* COLUMN Tcl_Obj* VALUES Tcl_Obj* INDICES} ok {
    int status;

    if (Tcl_IsShared(COLUMN))
        COLUMN = Tcl_DuplicateObj(COLUMN);

    if (tcol_convert(NULL, VALUES) == TCL_OK)
        status = tcol_place_indices(interp, COLUMN, VALUES, INDICES);
    else
        status = tcol_place_objs(interp, COLUMN, VALUES, INDICES);
    return ta_return_result(interp, status, COLUMN);
}

critcl::cproc tarray::column::vplace {Tcl_Interp* interp Tcl_Obj* COLUMNVAR Tcl_Obj* VALUES Tcl_Obj* INDICES} ok {
    Tcl_Obj *tcol;
    int status;

    tcol = Tcl_ObjGetVar2(interp, COLUMNVAR, NULL, TCL_LEAVE_ERR_MSG);
    if (tcol == NULL)
        return TCL_ERROR;
    if (Tcl_IsShared(tcol))
        tcol = Tcl_DuplicateObj(tcol);
    
    if (tcol_convert(NULL, VALUES) == TCL_OK)
        status = tcol_place_indices(interp, tcol, VALUES, INDICES);
    else
        status = tcol_place_objs(interp, tcol, VALUES, INDICES);

    return ta_set_var_result(interp, status, COLUMNVAR, tcol);
}

critcl::ccommand tarray::column::fill {} {
    Tcl_Obj *tcol;
    int status;

    if (objc != 4 && objc != 5) {
	Tcl_WrongNumArgs(interp, 1, objv, "COLUMN VALUE (INDEXLIST | LOW ?HIGH?)");
	return TCL_ERROR;
    }

    tcol = objv[1];
    if (Tcl_IsShared(tcol))
        tcol = Tcl_DuplicateObj(tcol);

    status = tcol_fill_obj(interp, tcol, objv[2], objv[3],
                               objc == 5 ? objv[4] : NULL);
    return ta_return_result(interp, status, tcol);
}

critcl::ccommand tarray::column::vfill {} {
    Tcl_Obj *tcol;
    int status;

    if (objc != 4 && objc != 5) {
	Tcl_WrongNumArgs(interp, 1, objv, "TCOLUMNVAR VALUE (INDEXLIST | LOW ?HIGH?)");
	return TCL_ERROR;
    }
    
    tcol = Tcl_ObjGetVar2(interp, objv[1], NULL, TCL_LEAVE_ERR_MSG);
    if (tcol == NULL)
        return TCL_ERROR;
    if (Tcl_IsShared(tcol))
        tcol = Tcl_DuplicateObj(tcol);

    status = tcol_fill_obj(interp, tcol, objv[2], objv[3], objc == 5 ? objv[4] : NULL);
    return ta_set_var_result(interp, status, objv[1], tcol);
}

critcl::cproc tarray::column::reverse {Tcl_Interp* interp Tcl_Obj* tcol} ok {
    if (Tcl_IsShared(tcol))
        tcol = Tcl_DuplicateObj(tcol);
    return ta_return_result(interp, tcol_reverse(interp, tcol), tcol);
}
    
critcl::cproc tarray::column::vreverse {Tcl_Interp* interp Tcl_Obj* ovar} ok {
    Tcl_Obj *tcol;

    tcol = Tcl_ObjGetVar2(interp, ovar, NULL, TCL_LEAVE_ERR_MSG);
    if (tcol == NULL)
        return TCL_ERROR;
    if (Tcl_IsShared(tcol))
        tcol = Tcl_DuplicateObj(tcol);

    return ta_set_var_result(interp, tcol_reverse(interp, tcol), ovar, tcol);
}


critcl::cproc tarray::table::put {Tcl_Interp* interp Tcl_Obj* GRID Tcl_Obj* VALUES Tcl_Obj* {FIRST 0}} ok {
    Tcl_Obj *table;
    int status;

    table = GRID;
    if (Tcl_IsShared(table))
        table = Tcl_DuplicateObj(table);

    /* Values may be given as a table or a Tcl list */
    if (table_convert(NULL, VALUES) == TCL_OK)
        status = table_copy(interp, table, VALUES, FIRST, 0);
    else
        status = table_put_objs(interp, table, VALUES, FIRST, 0);

    return ta_return_result(interp, status, table);
}

critcl::cproc tarray::table::vput {Tcl_Interp* interp Tcl_Obj* GRIDVAR Tcl_Obj* VALUES Tcl_Obj* {FIRST 0}} ok {
    Tcl_Obj *table;
    int status;

    table = Tcl_ObjGetVar2(interp, GRIDVAR, NULL, TCL_LEAVE_ERR_MSG);
    if (table == NULL)
        return TCL_ERROR;
    if (Tcl_IsShared(table))
        table = Tcl_DuplicateObj(table);

    /* Values may be given as a table or a Tcl list */
    if (table_convert(NULL, VALUES) == TCL_OK)
        status = table_copy(interp, table, VALUES, FIRST, 0);
    else
        status = table_put_objs(interp, table, VALUES, FIRST, 0);

    return ta_set_var_result(interp, status, GRIDVAR, table);
}

critcl::ccommand tarray::table::fill {} {
    Tcl_Obj *table;
    int status;

    if (objc != 4 && objc != 5) {
	Tcl_WrongNumArgs(interp, 1, objv, "GRID VALUES (INDEXLIST | LOW ?HIGH?");
	return TCL_ERROR;
    }

    table = objv[1];
    if (Tcl_IsShared(table))
        table = Tcl_DuplicateObj(table);

    status = table_fill_obj(interp, table, objv[2], objv[3], 
                            objc == 5 ? objv[4] : NULL, 0);

    return ta_return_result(interp, status, table);
}

critcl::ccommand tarray::table::vfill {} {
    int status;
    Tcl_Obj *table;

    if (objc != 4 && objc != 5) {
	Tcl_WrongNumArgs(interp, 1, objv, "GRIDVAR VALUES (INDEXLIST | LOW ?HIGH?");
	return TCL_ERROR;
    }

    table = Tcl_ObjGetVar2(interp, objv[1], NULL, TCL_LEAVE_ERR_MSG);
    if (table == NULL)
        return TCL_ERROR;
    if (Tcl_IsShared(table))
        table = Tcl_DuplicateObj(table);

    status = table_fill_obj(interp, table, objv[2], objv[3], 
                            objc == 5 ? objv[4] : NULL, 0);
    return ta_set_var_result(interp, status, objv[1], table);
}

critcl::ccommand tarray::table::delete {} {
    Tcl_Obj *table;
    int status;

    if (objc != 3 && objc != 4) {
	Tcl_WrongNumArgs(interp, 1, objv, "GRID (INDEXLIST | LOW ?HIGH?)");
	return TCL_ERROR;
    }
    
    table = objv[1];
    if (Tcl_IsShared(table))
        table = Tcl_DuplicateObj(table);
    status = table_delete(interp, table, objv[2], objc == 4 ? objv[3] : NULL);
    return ta_return_result(interp, status, table);
}


critcl::ccommand tarray::table::vdelete {} {
    Tcl_Obj *table;
    int status;

    if (objc != 3 && objc != 4) {
	Tcl_WrongNumArgs(interp, 1, objv, "GRIDVAR (INDEXLIST | LOW ?HIGH?)");
	return TCL_ERROR;
    }
    
    table = Tcl_ObjGetVar2(interp, objv[1], NULL, TCL_LEAVE_ERR_MSG);
    if (table == NULL)
        return TCL_ERROR;
    if (Tcl_IsShared(table))
        table = Tcl_DuplicateObj(table);
    status = table_delete(interp, table, objv[2], objc == 4 ? objv[3] : NULL);
    return ta_set_var_result(interp, status, objv[1], table);
}

critcl::ccommand tarray::table::get {} {
    Tcl_Obj *table;
    int low, count;
    int status;
    int fmt = TA_FORMAT_TARRAY;
    int ta_arg;
    thdr_t *pindices;

    if (objc < 3)
        goto badargs;
    
    /*
     * Parsing is ambiguous. We do not want check if objv[1] is an option
     * directly because it might shimmer a huge tarray into a string.
     * So check for options only if not a tarray. Note it is possible that
     * objv[1] is a tarray even though it's type does not indicate as much.
     * In that the string rep will anyways exist and question of shimmering
     * does not arise.
     */
    if (tcol_affirm(objv[1])) {
        /* Note we check for tcol_affirm, not table_affirm */
        ta_arg = 1;
    } else {
        /* OK, see if it is an option */
        status = Tcl_GetIndexFromObj(NULL, objv[1], gFormatOptions,
                                     "FORMAT", TCL_EXACT, &fmt);
        if (status == TCL_OK)
            ta_arg = 2;
        else
            ta_arg = 1;
    }
       
    if ((objc - ta_arg) < 2 || (objc - ta_arg) > 3)
        goto badargs;

    if ((status = table_convert(interp, objv[ta_arg])) != TCL_OK)
        return status;

    switch (objc - ta_arg - 1) {
    case 1:
        switch (ta_obj_to_indices(interp, objv[ta_arg+1], 0, 0, &pindices, NULL)) {
        case TA_INDEX_TYPE_ERROR:
            return TCL_ERROR;
        case TA_INDEX_TYPE_INT:
            Tcl_Panic("ta_obj_to_indices returned TA_INDEX_TYPE_INT when passed NULL pointer");
            break;
        case TA_INDEX_TYPE_THDR:
            table = table_get(interp, objv[ta_arg], pindices, fmt);
            thdr_decr_refs(pindices);
            break;
        }
        break;
    case 2:
        /* Range LOW HIGH */
        status = ta_fix_range_bounds(interp, table_length(objv[ta_arg]),
                                         objv[ta_arg+1], objv[ta_arg+2],
                                         &low, &count);
        if (status != TCL_OK)
            return status;
        table = table_range(interp, objv[ta_arg], low, count, fmt);
        break;
    default:
        goto badargs;
    }

    if (table) {
        Tcl_SetObjResult(interp, table);
        return TCL_OK;
    } else
        return TCL_ERROR;

badargs:
    Tcl_WrongNumArgs(interp, 1, objv, "?OPTIONS? TCOLUMN (LOW ?HIGH? | INDEXLIST)");
    return TCL_ERROR;

}

critcl::cproc tarray::table::index {Tcl_Interp* interp Tcl_Obj* GRID Tcl_Obj* INDEX} ok {
    int ix;
    Tcl_Obj *o;

    if (table_convert(interp, GRID) == TCL_OK) {
        int end = table_length(GRID) - 1;
	if (ta_convert_index(interp, INDEX, &ix, end, 0, end) == TCL_OK) {
            o = table_index(interp, GRID, ix);
            if (o) {
                Tcl_SetObjResult(interp, o);
                return TCL_OK;
            }
        }
    }
    return TCL_ERROR;
}


critcl::ccommand tarray::table::insert {} {
    Tcl_Obj *table;
    int status;

    if (objc != 4 && objc != 5) {
    	Tcl_WrongNumArgs(interp, 1, objv, "GRID (VALUES POSITION | VALUE POSITION COUNT)");
	return TCL_ERROR;
    }
    
    table = objv[1];
    if (Tcl_IsShared(table))
        table = Tcl_DuplicateObj(table);
    status = table_insert_obj(interp, table, objv[2], objv[3], objc == 4 ? NULL : objv[4]);
    return ta_return_result(interp, status, table);
}

critcl::ccommand tarray::table::vinsert {} {
    Tcl_Obj *table;
    int status;

    if (objc != 4 && objc != 5) {
    	Tcl_WrongNumArgs(interp, 1, objv, "COLUMNVAR (VALUES POSITION | VALUE POSITION COUNT)");
	return TCL_ERROR;
    }
    
    table = Tcl_ObjGetVar2(interp, objv[1], NULL, TCL_LEAVE_ERR_MSG);
    if (table == NULL)
        return TCL_ERROR;
    if (Tcl_IsShared(table))
        table = Tcl_DuplicateObj(table);
    status = table_insert_obj(interp, table, objv[2], objv[3], objc == 4 ? NULL : objv[4]);
    return ta_set_var_result(interp, status, objv[1], table);
}

critcl::cproc tarray::table::place {Tcl_Interp* interp Tcl_Obj* GRID Tcl_Obj* VALUES Tcl_Obj* INDICES} ok {
    int status;

    if (Tcl_IsShared(GRID))
        GRID = Tcl_DuplicateObj(GRID);

    if (table_convert(NULL, VALUES) == TCL_OK)
        status = table_place_indices(interp, GRID, VALUES, INDICES);
    else
        status = table_place_objs(interp, GRID, VALUES, INDICES);
    return ta_return_result(interp, status, GRID);
}

critcl::cproc tarray::table::vplace {Tcl_Interp* interp Tcl_Obj* GRIDVAR Tcl_Obj* VALUES Tcl_Obj* INDICES} ok {
    int status;
    Tcl_Obj *table;

    table = Tcl_ObjGetVar2(interp, GRIDVAR, NULL, TCL_LEAVE_ERR_MSG);
    if (table == NULL)
        return TCL_ERROR;
    if (Tcl_IsShared(table))
        table = Tcl_DuplicateObj(table);
    
    if (table_convert(NULL, VALUES) == TCL_OK)
        status = table_place_indices(interp, table, VALUES, INDICES);
    else
        status = table_place_objs(interp, table, VALUES, INDICES);
    return ta_set_var_result(interp, status, GRIDVAR, table);
}

critcl::cproc tarray::table::reverse {Tcl_Interp* interp Tcl_Obj* table} ok {
    if (Tcl_IsShared(table))
        table = Tcl_DuplicateObj(table);

    return ta_return_result(interp, table_reverse(interp, table), table);
}
    
critcl::cproc tarray::table::vreverse {Tcl_Interp* interp Tcl_Obj* ovar} ok {
    Tcl_Obj *table;

    table = Tcl_ObjGetVar2(interp, ovar, NULL, TCL_LEAVE_ERR_MSG);
    if (table == NULL)
        return TCL_ERROR;

    if (Tcl_IsShared(table))
        table = Tcl_DuplicateObj(table);

    return ta_set_var_result(interp, table_reverse(interp, table), ovar, table);
}


# If you are new to critcl, note that the order of constructor, insvariable
# etc. is very important in terms of how initialization and freeing is done.
critcl::class::define tarray::db {
    classvariable int dummy_to_prevent_compile_fails_due_to_empty_class_def
    insvariable Tcl_HashTable column_names {
        Maps column names to index
    } {
        Tcl_InitObjHashTable(&instance->column_names);
    } {
        Tcl_DeleteHashTable(&instance->column_names);
    }

    insvariable thdr_t* columns {
        Points to a tarray containing the table columns
    } {
        instance->columns = NULL;
    } {
        if (instance->columns) {
            thdr_decr_refs(instance->columns);
            instance->columns = NULL;
        }
    }

    constructor {

        Tcl_Obj **elems;
        int i, nelems, tatype;
        thdr_t thdr;
        
        /* table new DEFINITION */
        if (objc != 1) {
            Tcl_SetResult(interp, "Syntax error", TCL_STATIC);
            goto error;
        }

        if (Tcl_ListObjGetElements(interp, objv[0], &nelems, &elems) != TCL_OK)
            goto error;

        if (nelems == 0 || nelems & 1) {
            Tcl_SetResult(interp, "Invalid table definition", TCL_STATIC);
            goto error;
        }

        instance->columns = thdr_alloc(interp, TA_ANY, nelems/2);
        if (instance->columns == NULL)
            goto error;
        thdr_incr_refs(instance->columns);
        /* This loop is structured slightly strange because of how critcl
           puts together constructor fragments. The constructor
           alwasy fall through for the success case
        */
        for (i = 0; i < nelems-1; i += 2) {
            Tcl_Obj *tcol;
            Tcl_HashEntry *he;
            if (Tcl_GetIndexFromObj(interp, elems[i+1], g_type_tokens, "TArrayType",
                                    TCL_EXACT, &tatype) == TCL_OK) {
                tcol = tcol_new(thdr_alloc(interp, tatype, 0));
                if (tcol && thdr_put_objs(interp, instance->columns, i/2, 1, &tcol, 0) == TCL_OK) {
                    int is_new;
                    he = Tcl_CreateHashEntry(&instance->column_names, (char *)elems[i], &is_new);
                    if (is_new) {
                        Tcl_SetHashValue(he, (ClientData) (i/2));
                        continue; /* Success, go on with next field */
                    } else {
                        Tcl_SetObjResult(interp,
                                         Tcl_ObjPrintf("Duplicate column name %s in table definition", Tcl_GetString(elems[i])));
                    }
                }
            }
            /* Something or the other failed */
            thdr_decr_refs(instance->columns);
            instance->columns = NULL;
            Tcl_DeleteHashTable(&instance->column_names);
            goto error;
        }
    }

    method_introspection
}

package provide tarray 0.1

critcl::load
