#
# Copyright (c) 2012, Ashok P. Nadkarni
# All rights reserved.
#
# See the file LICENSE for license


package require critcl 3.1
critcl::buildrequirement {
    package require critcl::class ; # DSL, easy spec of Tcl class/object commands.
}
critcl::clean_cache
critcl::tcl 8.5
critcl::debug symbols
#critcl::cflags -std=gnu99 -Winline

critcl::csources tarray.c tasearch.c bitarray.c tasort.c
critcl::tsources tarray.tcl
critcl::cheaders tarray.h

critcl::ccode {
#include "tarray.h"
    typedef Tcl_Obj *TArrayObjPtr;

    /* Must match order of TA_FORMAT_* in tarray.h */
    static const char *gFormatOptions[] = {
        "-tarray",
        "-list",
        "-dict",
        NULL
    };
}


critcl::cinit {
    tclListTypePtr = Tcl_GetObjType("list");
} {
}

critcl::argtype TArrayObjPtr {
    if (TArrayConvert(interp, @@) != TCL_OK)
        return TCL_ERROR;
    @A = @@;
}

critcl::argtype TAHdr* {
    if (TArrayConvert(interp, @@) != TCL_OK)
        return TCL_ERROR;
    @A = TARRAYHDR(@@);
}

critcl::ccommand tarray::column::create {} {
    int init_size;
    int tatype;
    Tcl_Obj **elems;
    int nelems;
    TAHdr *thdrP;

    if (objc < 2 || objc > 4) {
        Tcl_WrongNumArgs(interp, 1, objv, "TYPE ?INITVAL? ?INITSIZE?");
        return TCL_ERROR;
    }

    if (Tcl_GetIndexFromObj(interp, objv[1], gTArrayTypeTokens, "TArrayType",
                            TCL_EXACT, &tatype) != TCL_OK) {
	return TCL_ERROR;
    }

    init_size = 0;
    nelems = 0;
    elems = NULL;
    if (objc > 2) {
        if (Tcl_ListObjGetElements(interp, objv[2], &nelems, &elems) != TCL_OK)
            return TCL_ERROR;
        if (objc > 3) {
            if (Tcl_GetIntFromObj(interp, objv[3], &init_size) != TCL_OK)
                return TCL_ERROR;
        }
    }

    thdrP = TAHdrAllocAndInit(interp, tatype, nelems, elems, init_size);
    if (thdrP == NULL)
        return TCL_ERROR;

    Tcl_SetObjResult(interp, TArrayNewObj(thdrP));
    return TCL_OK;
}

critcl::ccommand tarray::column::delete {} {
    Tcl_Obj *taObj;
    TAHdr *thdrP;
    int low, count;
    int status;

    if (objc != 3 && objc != 4) {
	Tcl_WrongNumArgs(interp, 1, objv, "TARRAY LOW ?HIGH?");
	return TCL_ERROR;
    }
    
    if ((status = TArrayConvert(interp, objv[1])) != TCL_OK)
        return status;

    taObj = Tcl_IsShared(objv[1]) ? Tcl_DuplicateObj(objv[1]) : objv[1];

    status = TArrayMakeModifiable(interp, taObj, TARRAYELEMCOUNT(taObj),
                                  TARRAYELEMCOUNT(taObj));
    thdrP = TARRAYHDR(taObj);
    if (status == TCL_OK) {
        if (objc == 4) {
            status = RationalizeRangeIndices(interp, thdrP, objv[2],
                                             objv[3], &low, &count);
            if (status == TCL_OK)
                TAHdrDeleteRange(thdrP, low, count);
        } else {
            /* Not a range, either a list or single index */
            TAHdr *indicesP;
            /* Note status is TCL_OK at this point */
            switch (TArrayConvertToIndices(interp, objv[2], 1, &indicesP, &low)) {
            case TA_INDEX_TYPE_ERROR:
                status = TCL_ERROR;
                break;
            case TA_INDEX_TYPE_INT:
                TAHdrDeleteRange(thdrP, low, 1);
                break;
            case TA_INDEX_TYPE_TAHDR:
                TAHdrDeleteIndices(thdrP, indicesP);
                TAHDR_DECRREF(indicesP);
                break;
            }
        }
    }

    if (status == TCL_OK)
        Tcl_SetObjResult(interp, taObj);
    else if (taObj != objv[1])
        Tcl_DecrRefCount(taObj); /* We allocated it so free it */

    return status;
}

critcl::cproc tarray::column::size {Tcl_Interp* interp TArrayObjPtr taobjP} int {
    return TARRAYELEMCOUNT(taobjP);
}

critcl::cproc tarray::column::type {Tcl_Interp* interp TArrayObjPtr taobjP} "const char*" {
    return TArrayTypeString(TARRAYTYPE(taobjP));
}

critcl::cproc tarray::column::index {Tcl_Interp* interp TAHdr* tcolumn Tcl_Obj* index} ok {
    int ix;
    if (IndexToInt(interp, index, &ix, tcolumn->used-1, 0, tcolumn->used-1) != TCL_OK)
        return TCL_ERROR;
    if (ix < 0 || ix >= tcolumn->used) {
        TArrayIndexRangeError(interp, ix);
        return TCL_ERROR;
    }
    Tcl_SetObjResult(interp, TAHdrIndex(tcolumn, ix));
    return TCL_OK;
}

critcl::ccommand tarray::column::get {} {
    Tcl_Obj *taObj;
    TAHdr *thdrP;
    int low, count;
    int status;
    int fmt = TA_FORMAT_TARRAY;
    int ta_arg;
    TAHdr *indicesP;

    if (objc < 3)
        goto badargs;
    
    /*
     * Parsing is ambiguous. We do not want check if objv[1] is an option
     * directly because it might shimmer a huge tarray into a string.
     * So check for options only if not a tarray. Note it is possible that
     * objv[1] is a tarray even though it's type does not indicate as much.
     * In that the string rep will anyways exist and question of shimmering
     * does not arise.
     */
    if (objv[1]->typePtr == &gTArrayType) {
        ta_arg = 1;
    } else {
        /* OK, see if it is an option */
        status = Tcl_GetIndexFromObj(NULL, objv[1], gFormatOptions,
                                     "FORMAT", TCL_EXACT, &fmt);
        if (status == TCL_OK)
            ta_arg = 2;
        else
            ta_arg = 1;
        if ((status = TArrayConvert(interp, objv[ta_arg])) != TCL_OK)
            return status;
    }
       
    if ((objc - ta_arg) < 2 || (objc - ta_arg) > 3)
        goto badargs;

    switch (objc - ta_arg - 1) {
    case 1:
        switch (TArrayConvertToIndices(interp, objv[ta_arg+1], 0, &indicesP, NULL)) {
        case TA_INDEX_TYPE_ERROR:
            return TCL_ERROR;
        case TA_INDEX_TYPE_INT:
            Tcl_Panic("TArrayConvertToIndices returned TA_INDEX_TYPE_INT when passed NULL pointer");
            break;
        case TA_INDEX_TYPE_TAHDR:
            taObj = TArrayGet(interp, TARRAYHDR(objv[ta_arg]), indicesP, fmt);
            TAHDR_DECRREF(indicesP);
            break;
        }
        break;
    case 2:
        /* Range LOW HIGH */
        /* TBD - reuse the TAHdr if not shared */
        status = RationalizeRangeIndices(interp, TARRAYHDR(objv[ta_arg]),
                                         objv[ta_arg+1], objv[ta_arg+2],
                                         &low, &count);
        if (status != TCL_OK)
            return TCL_ERROR;
        taObj = TArrayRange(interp, objv[ta_arg], low, count, fmt);
        break;
    default:
        goto badargs;
    }

    if (taObj) {
        Tcl_SetObjResult(interp, taObj);
        return TCL_OK;
    } else
        return TCL_ERROR;

badargs:
    Tcl_WrongNumArgs(interp, 1, objv, "?OPTIONS? TCOLUMN (LOW ?HIGH? | INDEXLIST)");
    return TCL_ERROR;

}

critcl::ccommand tarray::column::sort {} {
    static const char *switches[] = {
        "-decreasing", "-increasing", "-indices", NULL
    };
    enum TArraySortSwitches {
        TA_SORT_DECREASING, TA_SORT_INCREASING, TA_SORT_INDICES
    };
    int decreasing = 0;
    int return_indices = 0;
    Tcl_Obj *srcObj;
    int i, n, opt;
    TAHdr *srcP;
    TAHdr *sortedP;
    Tcl_Obj *resultObj;
    int (__cdecl *cmpfn)(const void*, const void*);
    int (__cdecl *cmpindexedfn)(void *, const void*, const void*);
    int existing_sort_order;

    if (objc < 2) {
	Tcl_WrongNumArgs(interp, 1, objv, "?options? tarray");
	return TCL_ERROR;
    }

    srcObj = objv[objc-1];
    if (TArrayConvert(interp, objv[objc-1]) != TCL_OK)
        return TCL_ERROR;
    srcP = TARRAYHDR(objv[objc-1]);
    for (i = 1; i < objc-1; ++i) {
	if (Tcl_GetIndexFromObj(interp, objv[i], switches, "option", 0, &opt)
            != TCL_OK) {
            return TCL_ERROR;
	}
        switch ((enum TArraySortSwitches) opt) {
        case TA_SORT_DECREASING: decreasing = 1; break;
        case TA_SORT_INCREASING: decreasing = 0; break;
        case TA_SORT_INDICES: return_indices = 1; break;
        }
    }

    existing_sort_order = TAHdrSorted(srcP);
    if (existing_sort_order && ! return_indices) {
        /* We want contents and input is in sorted... */
        if ((existing_sort_order < 0 && decreasing) ||
            (existing_sort_order > 0 && !decreasing)) {
            /* ...in the desired order, no less! */
            resultObj = srcObj;
        } else {
            /*
             * Need to reverse the order. If unshared, we can do this
             * in place else need to allocate a new object and array
             */
            if (Tcl_IsShared(srcObj) || TAHDR_SHARED(srcP)) {
                /* Cannot modify in place. Need to dup it */
                sortedP = TAHdrCloneReversed(interp, srcP, 0);
                if (sortedP == NULL)
                    return TCL_ERROR;
                resultObj = TArrayNewObj(sortedP);
            } else {
                sortedP = srcP;
                resultObj = srcObj;
                TAHdrReverse(sortedP);
                Tcl_InvalidateStringRep(resultObj);
            }
            if (decreasing)
                TAHdrSortMarkDescending(sortedP);
            else
                TAHdrSortMarkAscending(sortedP);
        }
    } else if (return_indices) {
        /* Caller wants indices to be returned */
        int *indexP;
        sortedP = TAHdrAlloc(interp, TA_INT, srcP->used);
        if (sortedP == NULL)
            return TCL_ERROR;
        resultObj = TArrayNewObj(sortedP);
        /* Initialize the indexes */
        sortedP->used = srcP->used;
        indexP = TAHDRELEMPTR(sortedP, int, 0);

        if (existing_sort_order) {
            /* Input already sorted ... */
            if ((existing_sort_order < 0 && decreasing) ||
                (existing_sort_order > 0 && !decreasing)) {
                /* ...and in the right order! */
                for (i = 0; i < srcP->used; ++i, ++indexP)
                    *indexP = i;
                TAHdrSortMarkAscending(sortedP);
            } else {
                /* ...but in reverse order. */
                for (i = srcP->used; i > 0; ++indexP)
                    *indexP = --i;
                TAHdrSortMarkDescending(sortedP);
            }
        } else {
            /* Input is not already sorted */

            /* Init the indices array for sorting */
            for (i = 0; i < srcP->used; ++i, ++indexP)
                *indexP = i;

            switch (sortedP->type) {
            case TA_BOOLEAN:
                cmpindexedfn = decreasing ? uintcmpindexedrev : uintcmpindexed;
                break;
            case TA_UINT:
                cmpindexedfn = decreasing ? uintcmpindexedrev : uintcmpindexed;
                break;
            case TA_INT:
                cmpindexedfn = decreasing ? intcmpindexedrev : intcmpindexed;
                break;
            case TA_WIDE:
                cmpindexedfn = decreasing ? widecmpindexedrev : widecmpindexed;
                break;
            case TA_DOUBLE:
                cmpindexedfn = decreasing ? doublecmpindexedrev : doublecmpindexed;
                break;
            case TA_OBJ:
                cmpindexedfn = decreasing ? tclobjcmpindexedrev : tclobjcmpindexed;
                break;
            default:
                TArrayTypePanic(sortedP->type);
            }
            /* Note the list of indices is NOT sorted, do not mark it as such ! */
            tarray_qsort_r(TAHDRELEMPTR(sortedP, int, 0), sortedP->used, sizeof(int), TAHDRELEMPTR(srcP, unsigned char, 0), cmpindexedfn);
        }
    } else {
        /*
         * We want sorted contents, not indices. If object is not shared,
         * we can sort in place, else need to create a new object.
         */
        /* Why not using TArrayMakeModifiable here ? */
        if (Tcl_IsShared(srcObj) || TAHDR_SHARED(srcP)) {
            /* Cannot modify in place. Need to dup it */
            sortedP = TAHdrClone(interp, srcP, 0);
            if (sortedP == NULL)
                return TCL_ERROR;
            resultObj = TArrayNewObj(sortedP);
        } else {
            sortedP = srcP;
            resultObj = srcObj;
            Tcl_InvalidateStringRep(resultObj);
        }

        /*
         * Return sorted contents. Boolean type we treat separately
         * since we just need to count how many 1's and 0's.
         */
        if (sortedP->type == TA_BOOLEAN) {
            ba_t *baP = TAHDRELEMPTR(sortedP, ba_t, 0);
            n = ba_count_ones(baP, 0, sortedP->used); /* Number of 1's set */
            if (decreasing) {
                ba_fill(baP, 0, n, 1);
                ba_fill(baP, n, sortedP->used - n, 0);
            } else {
                ba_fill(baP, 0, sortedP->used - n, 0);
                ba_fill(baP, sortedP->used - n, n, 1);
            }
        } else {
            switch (sortedP->type) {
            case TA_UINT:
                cmpfn = decreasing ? uintcmprev : uintcmp;
                break;
            case TA_INT:
                cmpfn = decreasing ? intcmprev : intcmp;
                break;
            case TA_WIDE:
                cmpfn = decreasing ? widecmprev : widecmp;
                break;
            case TA_DOUBLE:
                cmpfn = decreasing ? doublecmprev : doublecmp;
                break;
            case TA_OBJ:
                cmpfn = decreasing ? tclobjcmprev : tclobjcmp;
                break;
            default:
                TArrayTypePanic(sortedP->type);
            }
            qsort(TAHDRELEMPTR(sortedP, unsigned char, 0), sortedP->used,
                  sortedP->elem_bits / CHAR_BIT, cmpfn);
        }
        if (decreasing)
            TAHdrSortMarkDescending(sortedP);
        else
            TAHdrSortMarkAscending(sortedP);
    }

    Tcl_SetObjResult(interp, resultObj);
    return TCL_OK;
}

critcl::cproc tarray::column::bitsset {Tcl_Interp* interp TArrayObjPtr taObj} ok {
    TAHdr *thdrP = TARRAYHDR(taObj);
    if (thdrP->type != TA_BOOLEAN) {
        Tcl_SetResult(interp, "tarray type is not boolean", TCL_STATIC);
        return TCL_ERROR;
    }
        
    Tcl_SetObjResult(
        interp,
        Tcl_NewIntObj(ba_count_ones(TAHDRELEMPTR(thdrP, ba_t, 0), 0, thdrP->used)));
    return TCL_OK;
}

critcl::ccommand tarray::column::search TArray_SearchObjCmd


critcl::ccommand tarray::column::fill {} {
    int i, low, count;
    Tcl_Obj *taObj;
    int status;
    TArrayValue value;

    if (objc != 4 && objc != 5) {
	Tcl_WrongNumArgs(interp, 1, objv, "TARRAY VALUE LOW ?HIGH?");
	return TCL_ERROR;
    }

    taObj = objv[1];
    if ((status = TArrayConvert(interp, taObj)) != TCL_OK)
        return status;
    if ((status = TArrayValueFromObj(interp, objv[2],
                                     TARRAYTYPE(taObj), &value)) != TCL_OK)
        return TCL_ERROR;

    if (Tcl_IsShared(taObj))
        taObj = Tcl_DuplicateObj(objv[1]);

    if (objc == 5) {
        status = RationalizeRangeIndices(interp, TARRAYHDR(taObj), objv[3],
                                         objv[4], &low, &count);
        if (status == TCL_OK && count != 0) {
            status = TArrayMakeModifiable(interp, taObj, low+count, TARRAYELEMSLOTS(taObj));
            if (status == TCL_OK)
                TAHdrFillRange(interp, TARRAYHDR(taObj), &value, low, count);
        }
    } else {
        /* Not a range, either a list or single index */
        TAHdr *indicesP;
        /* Note status is TCL_OK at this point */
        switch (TArrayConvertToIndices(interp, objv[3], 1, &indicesP, &low)) {
        case TA_INDEX_TYPE_ERROR:
            status = TCL_ERROR;
            break;
        case TA_INDEX_TYPE_INT:
            if (low < 0 || low > TARRAYELEMCOUNT(taObj)) {
                TArrayIndexRangeError(interp, low);
                status = TCL_ERROR;
            } else {
                status = TArrayMakeModifiable(interp, taObj, low+1, 0);
                if (status == TCL_OK)
                    TAHdrFillRange(interp, TARRAYHDR(taObj), &value, low, 1);
            }
            break;
        case TA_INDEX_TYPE_TAHDR:
            status = TAHdrVerifyIndices(interp, TARRAYHDR(taObj), indicesP, &count);
            /* count is highest index specified in index array */
            if (status == TCL_OK) {
                status = TArrayMakeModifiable(interp, taObj, count+1, count+1); // TBD - count + extra?
                if (status == TCL_OK)
                    TAHdrFillIndices(interp, TARRAYHDR(taObj), &value, indicesP);
            }
            TAHDR_DECRREF(indicesP);
            break;
        }
    }

    if (status == TCL_OK)
        Tcl_SetObjResult(interp, taObj);
    else if (taObj != objv[1])
        Tcl_DecrRefCount(taObj); /* We allocated it so free it */

    return status;
}

critcl::cproc tarray::grid::create {Tcl_Interp* interp Tcl_Obj* objP} ok {
    Tcl_Obj **taObjs;
    TAHdr *thdrP;
    int i;
    int status;
    
    if (objP->typePtr != &gTArrayType) {
        if ((status = TArrayConvert(interp, objP) != TCL_OK))
            return TCL_OK;
    }            

    thdrP = TARRAYHDR(objP);
    if (thdrP->type != TA_OBJ)
        return TArrayBadTypeError(interp, thdrP);

    taObjs = TAHDRELEMPTR(thdrP, Tcl_Obj *, 0);
    for (i = 0; i < thdrP->used; ++i, ++taObjs) {
        if ((status = TArrayConvert(interp, *taObjs)) != TCL_OK)
            return TCL_ERROR;
    }

    Tcl_SetObjResult(interp, objP);
    return TCL_OK;
}

critcl::ccommand tarray::grid::fill {} {
    int i, tuple_width;
    Tcl_Obj **taObjs;
    Tcl_Obj *gridObj;
    int we_allocated_gridobj;
    int status;

    if (objc != 4 && objc != 5) {
	Tcl_WrongNumArgs(interp, 1, objv, "GRID VALUELIST LOW ?HIGH?");
	return TCL_ERROR;
    }

    gridObj = objv[1];
    if (Tcl_IsShared(gridObj)) {
        gridObj = Tcl_DuplicateObj(gridObj);
        we_allocated_gridobj = 1;
    } else
        we_allocated_gridobj = 0;

    status = TGridFillFromObjs(interp, objv[3], objv[objc == 5 ? 4 : 3],
                               gridObj, objv[2]);

    if (status == TCL_OK)
        Tcl_SetObjResult(interp, gridObj);
    else {
        if (we_allocated_gridobj)
            Tcl_DecrRefCount(gridObj);
    }

    return status;
}

package provide tarray 0.1

