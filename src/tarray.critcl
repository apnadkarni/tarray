#
# Copyright (c) 2012-2015, Ashok P. Nadkarni
# All rights reserved.
#
# See the file LICENSE for license
#

proc win32_target {} {
    switch -glob -- [critcl::targetconfig] {
        win32-* -
        mingw* { return 1 }
        default { return 0 }
    }
}

################################################################
# Set up configuration options for the package
array set build_opts {}

# Enable compiling of unsupported functions
set build_opts(unsupported) 1

# Figure out whether parallelized operations are to be enabled.
# On Windows, parallelized operations are enabled via native Win32 calls.
# Other platforms depend on the presence of libdispatch.
if {[win32_target]} {
    set build_opts(mt_enable) 1
    set build_opts(use_libdispatch) 0
} else {
    if {[critcl::check {
        #include <dispatch/dispatch.h>
    }]} {
        set build_opts(mt_enable) 1
        set build_opts(use_libdispatch) 1
    } else {
        set build_opts(mt_enable) 0
        set build_opts(use_libdispatch) 0
    }
}


################################################################
# Standard critcl meta information

package require critcl 3.1
critcl::buildrequirement {
    package require critcl::class
}

critcl::license "Ashok P. Nadkarni"
critcl::summary "Tcl Typed Array Extension"
critcl::description {
    Implements the tarray::column and tarray::table commands providing 
    accessed to typed array values. This extension is targeted towards
    Tcl applications dealing with a large number of data items.
}

critcl::clean_cache
critcl::tcl 8.6

################################################################
# Compiler/platform specific flags
if {[string match "*-gcc" [critcl::targetconfig]] ||
    [string match "linux-*-\\*" [critcl::targetconfig]] ||
    [string match  "mingw*" [critcl::targetconfig]]} {
    # Flags required for gcc
    critcl::cflags -std=gnu99 -Winline
}

if {[win32_target]} {
   # Need XP at least
   critcl::cflags -D_WIN32_WINNT=0x0500
}

critcl::csources bitarray.c column.c errors.c parseargs.c \
    table.c tafold.c tajoin.c taloop.c \
    tamath.c tarandom.c tarbc.c tarray.c tasearch.c tasort.c tastring.c \
    timsort.c timsort_r.c pcg_basic.c \
    rbcStubLib.c

if {$build_opts(unsupported)} {
    critcl::csources unsupported.c
    critcl::ccommand tarray::unsupported::dump ta_dump_cmd

}
critcl::tsources tabulate.tcl tarray.tcl taprint.tcl tarbc.tcl dbimport.tcl taversion.tcl
critcl::cheaders tarray.h tamath.h bitarray.h timsort.h timsort-impl.h pcg_basic.h rbcDecls.h

critcl::ccode {
#include "tarray.h"
#include <math.h>
#include "pcg_basic.h"
}

if {$build_opts(mt_enable)} {

    if {! $build_opts(use_libdispatch)} {
        critcl::csources mt.c
    }

    critcl::cflags -DTA_MT_ENABLE
}

critcl::ccommand tarray::unsupported::config {} {
    const char *vname;
    int *pval;	 
    if (objc < 2 || objc > 3) {
        Tcl_WrongNumArgs(interp, 1, objv, "CONFIGVAR ?VALUE?");
        return TCL_ERROR;
    }

    vname = Tcl_GetString(objv[1]);
    if (ta_strequal(vname, "experiment"))
        pval = &ta_experiment;
    else if (ta_strequal(vname, "full_validation"))
        pval = &ta_full_validation;
#ifdef TA_MT_ENABLE
    else if (ta_strequal(vname, "sort_mt_threshold"))
        pval = &ta_sort_mt_threshold;
    else if (ta_strequal(vname, "sort_mt_enable_any"))
        pval = &ta_sort_mt_enable_any;
    else if (ta_strequal(vname, "search_mt_threshold"))
        pval = &ta_search_mt_threshold;
    else if (ta_strequal(vname, "fill_mt_threshold"))
        pval = &ta_fill_mt_threshold;
    else if (ta_strequal(vname, "minmax_mt_threshold"))
        pval = &ta_minmax_mt_threshold;
    else if (ta_strequal(vname, "fold_mt_threshold"))
        pval = &ta_fold_mt_threshold;
    else if (ta_strequal(vname, "math_mt_threshold"))
        pval = &ta_math_mt_threshold;
#endif
    else {
        Tcl_SetResult(interp, "Invalid config setting name.", TCL_STATIC);
        return TCL_ERROR;
    }

    if (objc == 3) {
        if (Tcl_GetIntFromObj(interp, objv[2], pval) != TCL_OK)
        return TCL_ERROR;
    }
    Tcl_SetObjResult(interp, Tcl_NewIntObj(*pval));
    return TCL_OK;
}

if {$build_opts(use_libdispatch)} {
    critcl::clibraries -ldispatch
    critcl::cflags -DTA_USE_LIBDISPATCH
}


################################################################
# Type conversions

# WARNING: do not use this where there are multiple parameters to avoid
# shimmering crashes
critcl::argtype TColObjPtr {
    if (tcol_convert(interp, @@) != TCL_OK)
        return TCL_ERROR;
    @A = @@;
}

# WARNING: do not use this where there are multiple parameters to avoid
# shimmering crashes
critcl::argtype TableObjPtr {
    if (table_convert(interp, @@) != TCL_OK)
        return TCL_ERROR;
    @A = @@;
}

################################################################
# Common functions

critcl::ccode {
    typedef Tcl_Obj *TColObjPtr;
    typedef Tcl_Obj *TableObjPtr;

}

################################################################
# Initialization

critcl::cinit {
    ta_real_init(interp);
} {
}

################################################################
# General commands


################################################################
# Column commands

critcl::ccode {
    static TCL_RESULT table_put_parseargs(
        Tcl_Interp *ip, int objc, Tcl_Obj * const *objv,
        Tcl_Obj **potab, Tcl_Obj **povalues, Tcl_Obj **pomap, Tcl_Obj **poff)
    {
        if (objc < 3 || objc > 6) {
            if (ip)
                Tcl_WrongNumArgs(ip, 1, objv, "?-columns COLUMNMAP? TABLE VALUES ?POSITION?");
            return TCL_ERROR;
        }
        
        switch (objc) {
        case 3:
        case 4:
            /* Cannot contain an valid option. Parse as though no options */
            *pomap = NULL;
            *potab = objv[1];
            *povalues = objv[2];
            *poff = objc == 4 ? objv[3] : NULL;
            break;
        case 5:
        case 6:
            /* If valid, options must be present */
            /* To prevent shimmering, don't check for options if a tarray */
            if (strcmp(Tcl_GetString(objv[1]), "-columns"))
                return ta_invalid_opt_error(ip, Tcl_GetString(objv[1]));
            *pomap = objv[2];
            *potab = objv[3];
            *povalues = objv[4];
            *poff = objc == 6 ? objv[5] : NULL;
            break;
        }
        return TCL_OK;
    }
}

################################################################
# Table commands

critcl::ccommand tarray::table::put {} {
    Tcl_Obj *table, *ovalues, *omap, *ofirst;
    int status;

    if ((status = table_put_parseargs(interp, objc, objv, &table, &ovalues, &omap, &ofirst)) != TCL_OK)
        return status;

    if (Tcl_IsShared(table))
        table = Tcl_DuplicateObj(table);
    /* Values may be given as a table or a Tcl list */
    if (table_convert(NULL, ovalues) == TCL_OK)
        status = table_copy(interp, table, ovalues, ofirst, omap, 0);
    else
        status = table_put_objs(interp, table, ovalues, ofirst, omap, 0);

    TA_ASSERT(status != TCL_OK || table_check(interp, table));
    return ta_return_result(interp, status, table);
}

critcl::ccommand tarray::table::vput {} {
    Tcl_Obj *ovar, *table, *ovalues, *omap, *ofirst;
    int status;

    if ((status = table_put_parseargs(interp, objc, objv, &ovar, &ovalues, &omap, &ofirst)) != TCL_OK)
        return status;

    table = Tcl_ObjGetVar2(interp, ovar, NULL, TCL_LEAVE_ERR_MSG);
    if (table == NULL)
        return TCL_ERROR;
    if (Tcl_IsShared(table))
        table = Tcl_DuplicateObj(table);

    /* Values may be given as a table or a Tcl list */
    if (table_convert(NULL, ovalues) == TCL_OK)
        status = table_copy(interp, table, ovalues, ofirst, omap, 0);
    else
        status = table_put_objs(interp, table, ovalues, ofirst, omap, 0);

    TA_ASSERT(status != TCL_OK || table_check(interp, table));
    return ta_set_var_result(interp, status, ovar, table);
}

critcl::ccode {

    static TCL_RESULT table_fill_parseargs(
    Tcl_Interp *ip, int objc, Tcl_Obj * const *objv,
    Tcl_Obj **potab, Tcl_Obj **porow, Tcl_Obj **aindex, Tcl_Obj **bindex, Tcl_Obj **pomap)
    {
        int argoff;

        if (objc < 4 || objc > 7) {
            if (ip)
                Tcl_WrongNumArgs(ip, 1, objv, "?-columns COLUMNMAP? TABLE ROW (INDEXLIST | LOW ?HIGH?)");
            return TCL_ERROR;
        }

        argoff = 0;
        *pomap = NULL;
        /* If 4 or 5 args, no options are present */
        if (objc > 5) {
            /* To prevent shimmering, don't check for options if a tarray */
            if (strcmp(Tcl_GetString(objv[1]), "-columns"))
                return ta_invalid_opt_error(ip, Tcl_GetString(objv[1]));
            argoff = 2;
            *pomap = objv[2];
        }

        *potab = objv[++argoff];
        *porow = objv[++argoff];
        *aindex = objv[++argoff];
        *bindex = ++argoff < objc ? objv[argoff] : NULL;
        
        return TCL_OK;

    }
}

critcl::ccommand tarray::table::fill {} {
    Tcl_Obj *table, *orow, *aindex, *bindex, *omap;
    int status;

    if (table_fill_parseargs(interp, objc, objv, &table, &orow, &aindex, &bindex, &omap) != TCL_OK)
        return TCL_ERROR;

    if (Tcl_IsShared(table))
        table = Tcl_DuplicateObj(table);

    status = table_fill_obj(interp, table, orow, aindex, bindex, omap, 0);
    TA_ASSERT(status != TCL_OK || table_check(interp, table));
    return ta_return_result(interp, status, table);
}

critcl::ccommand tarray::table::vfill {} {
    int status;
    Tcl_Obj *ovar, *table, *orow, *aindex, *bindex, *omap;

    if (table_fill_parseargs(interp, objc, objv, &ovar, &orow, &aindex, &bindex, &omap) != TCL_OK)
        return TCL_ERROR;

    table = Tcl_ObjGetVar2(interp, ovar, NULL, TCL_LEAVE_ERR_MSG);
    if (table == NULL)
        return TCL_ERROR;
    if (Tcl_IsShared(table))
        table = Tcl_DuplicateObj(table);

    status = table_fill_obj(interp, table, orow, aindex, bindex, omap, 0);
    TA_ASSERT(status != TCL_OK || table_check(interp, table));
    return ta_set_var_result(interp, status, ovar, table);
}

critcl::ccommand tarray::table::delete {} {
    Tcl_Obj *table;
    int status;

    if (objc != 3 && objc != 4) {
	Tcl_WrongNumArgs(interp, 1, objv, "TABLE (INDEXLIST | LOW ?HIGH?)");
	return TCL_ERROR;
    }
    
    table = objv[1];
    if (Tcl_IsShared(table))
        table = Tcl_DuplicateObj(table);
    status = table_delete(interp, table, objv[2], objc == 4 ? objv[3] : NULL);
    TA_ASSERT(status != TCL_OK || table_check(interp, table));
    return ta_return_result(interp, status, table);
}


critcl::ccommand tarray::table::vdelete {} {
    Tcl_Obj *table;
    int status;

    if (objc != 3 && objc != 4) {
	Tcl_WrongNumArgs(interp, 1, objv, "TABLEVAR (INDEXLIST | LOW ?HIGH?)");
	return TCL_ERROR;
    }
    
    table = Tcl_ObjGetVar2(interp, objv[1], NULL, TCL_LEAVE_ERR_MSG);
    if (table == NULL)
        return TCL_ERROR;
    if (Tcl_IsShared(table))
        table = Tcl_DuplicateObj(table);
    status = table_delete(interp, table, objv[2], objc == 4 ? objv[3] : NULL);
    TA_ASSERT(status != TCL_OK || table_check(interp, table));
    return ta_set_var_result(interp, status, objv[1], table);
}

critcl::ccommand tarray::table::get {} {
    return table_retrieve(interp, objc, objv, TA_RETRIEVE_GET);
}

critcl::ccommand tarray::table::range {} {
    return table_retrieve(interp, objc, objv, TA_RETRIEVE_RANGE);
}

critcl::cproc tarray::table::index {Tcl_Interp* interp Tcl_Obj* GRID Tcl_Obj* INDEX} ok {
    int ix;
    Tcl_Obj *o;

    if (table_convert(interp, GRID) == TCL_OK) {
        int end = table_length(GRID) - 1;
	if (ta_convert_index(interp, INDEX, &ix, end, 0, end) == TCL_OK) {
            o = table_index(interp, GRID, ix);
            if (o) {
                Tcl_SetObjResult(interp, o);
                return TCL_OK;
            }
        }
    }
    return TCL_ERROR;
}


critcl::ccode {

    static TCL_RESULT table_insert_parseargs(
    Tcl_Interp *ip, int objc, Tcl_Obj * const *objv,
    Tcl_Obj **potab, Tcl_Obj **povalues, Tcl_Obj **pofirst,  int *pcount, Tcl_Obj **pomap)
    {
        int argoff;

        if (objc < 4 || objc > 7) {
            if (ip)
                Tcl_WrongNumArgs(ip, 1, objv, "?-columns COLUMNMAP? TABLE ROW LOW ?COUNT?");
            return TCL_ERROR;
        }

        argoff = 0;
        *pomap = NULL;
        /* If 4 or 5 args, no options are present */
        if (objc > 5) {
            if (strcmp(Tcl_GetString(objv[1]), "-columns"))
                return ta_invalid_opt_error(ip, Tcl_GetString(objv[1]));
            argoff = 2;
            *pomap = objv[2];
        }

        *potab = objv[++argoff];
        *povalues = objv[++argoff];
        *pofirst = objv[++argoff];
        if (++argoff < objc) {
            if (ta_get_int_from_obj(ip, objv[argoff], pcount) != TCL_OK)
                return TCL_ERROR;
        } else
            *pcount = 1;
        
        return TCL_OK;
    }

    static TCL_RESULT table_inject_parseargs(
    Tcl_Interp *ip, int objc, Tcl_Obj * const *objv,
    Tcl_Obj **potab, Tcl_Obj **povalues, Tcl_Obj **pofirst, Tcl_Obj **pomap)
    {
        int argoff;

        if (objc != 4 && objc != 6) {
            if (ip)
                Tcl_WrongNumArgs(ip, 1, objv, "?-columns COLUMNMAP? TABLE ROWS POS");
            return TCL_ERROR;
        }

        argoff = 0;
        *pomap = NULL;
        if (objc == 6) {
            if (strcmp(Tcl_GetString(objv[1]), "-columns"))
                return ta_invalid_opt_error(ip, Tcl_GetString(objv[1]));
            argoff = 2;
            *pomap = objv[2];
        }

        *potab = objv[++argoff];
        *povalues = objv[++argoff];
        *pofirst = objv[++argoff];
        return TCL_OK;
    }
}

critcl::ccommand tarray::table::insert {} {
    Tcl_Obj *table, *ovalues, *ofirst, *omap;
    int status, count;

    if (table_insert_parseargs(interp, objc, objv, &table, &ovalues,
                               &ofirst, &count, &omap) != TCL_OK)
        return TCL_ERROR;

    if (Tcl_IsShared(table))
        table = Tcl_DuplicateObj(table);
    status = table_insert_row(interp, table, ovalues, ofirst, count, omap);
    TA_ASSERT(status != TCL_OK || table_check(interp, table));
    return ta_return_result(interp, status, table);
}

critcl::ccommand tarray::table::vinsert {} {
    Tcl_Obj *ovar, *table, *ovalues, *ofirst, *omap;
    int status, count;

    if (table_insert_parseargs(interp, objc, objv, &ovar, &ovalues,
                               &ofirst, &count, &omap) != TCL_OK)
        return TCL_ERROR;

    table = Tcl_ObjGetVar2(interp, ovar, NULL, TCL_LEAVE_ERR_MSG);
    if (table == NULL)
        return TCL_ERROR;
    if (Tcl_IsShared(table))
        table = Tcl_DuplicateObj(table);
    status = table_insert_row(interp, table, ovalues, ofirst, count, omap);
    TA_ASSERT(status != TCL_OK || table_check(interp, table));
    return ta_set_var_result(interp, status, ovar, table);
}

critcl::ccommand tarray::table::inject {} {
    Tcl_Obj *table, *ovalues, *ofirst, *omap;
    int status;

    if (table_inject_parseargs(interp, objc, objv, &table, &ovalues,
                               &ofirst, &omap) != TCL_OK)
        return TCL_ERROR;

    if (Tcl_IsShared(table))
        table = Tcl_DuplicateObj(table);
    status = table_inject_rows(interp, table, ovalues, ofirst, omap);
    TA_ASSERT(status != TCL_OK || table_check(interp, table));
    return ta_return_result(interp, status, table);
}

critcl::ccommand tarray::table::vinject {} {
    Tcl_Obj *ovar, *table, *ovalues, *ofirst, *omap;
    int status;

    if (table_inject_parseargs(interp, objc, objv, &ovar, &ovalues,
                               &ofirst, &omap) != TCL_OK)
        return TCL_ERROR;

    table = Tcl_ObjGetVar2(interp, ovar, NULL, TCL_LEAVE_ERR_MSG);
    if (table == NULL)
        return TCL_ERROR;
    if (Tcl_IsShared(table))
        table = Tcl_DuplicateObj(table);
    status = table_inject_rows(interp, table, ovalues, ofirst, omap);
    TA_ASSERT(status != TCL_OK || table_check(interp, table));
    return ta_set_var_result(interp, status, ovar, table);
}

critcl::ccode {
    static TCL_RESULT table_place_parseargs(Tcl_Interp *ip, int objc, Tcl_Obj * const *objv, Tcl_Obj **potab, Tcl_Obj **povalues, Tcl_Obj **poindices, Tcl_Obj **pomap)
    {
        int argpos;
	char *s;
    
        if (objc == 4) {
            argpos = 0;
            *pomap = NULL;
        } else {
            if (objc != 6) {
                if (ip)
                    Tcl_WrongNumArgs(ip, 1, objv, "?-columns COLUMNMAP? TABLE VALUES INDICES");
                return TCL_ERROR;
            }
	    s = Tcl_GetString(objv[1]);
            if (strcmp(s, "-columns"))
                return ta_invalid_opt_error(ip, s);
            argpos = 2;
            *pomap = objv[2];
        }

        *potab = objv[1+argpos];
        *povalues = objv[2+argpos];
        *poindices = objv[3+argpos];
        
        return TCL_OK;
    }
}

critcl::ccommand tarray::table::place {} {
    int status;
    Tcl_Obj *otab, *ovalues, *oindices, *omap;
    
    if (table_place_parseargs(interp, objc, objv, &otab, &ovalues,
                           &oindices, &omap) != TCL_OK)
        return TCL_ERROR;

    if (Tcl_IsShared(otab))
        otab = Tcl_DuplicateObj(otab);

    status = table_place(interp, otab, ovalues, oindices, omap);
    TA_ASSERT(status != TCL_OK || table_check(interp, otab));
    return ta_return_result(interp, status, otab);
}


critcl::ccommand tarray::table::vplace {} {
    int status;
    Tcl_Obj *ovar, *ovalues, *oindices, *omap, *otab;
    
    if (table_place_parseargs(interp, objc, objv, &ovar, &ovalues,
                           &oindices, &omap) != TCL_OK)
        return TCL_ERROR;

    otab = Tcl_ObjGetVar2(interp, ovar, NULL, TCL_LEAVE_ERR_MSG);
    if (otab == NULL)
        return TCL_ERROR;
    if (Tcl_IsShared(otab))
        otab = Tcl_DuplicateObj(otab);
    
    status = table_place(interp, otab, ovalues, oindices, omap);
    TA_ASSERT(status != TCL_OK || table_check(interp, otab));
    return ta_set_var_result(interp, status, ovar, otab);
}

critcl::cproc tarray::table::reverse {Tcl_Interp* interp Tcl_Obj* table} ok {
    TCL_RESULT status;
    if (Tcl_IsShared(table))
        table = Tcl_DuplicateObj(table);

    status = table_reverse(interp, table);
    TA_ASSERT(status != TCL_OK || table_check(interp, table));
    return ta_return_result(interp, status, table);
}
    
critcl::cproc tarray::table::vreverse {Tcl_Interp* interp Tcl_Obj* ovar} ok {
    Tcl_Obj *table;
    TCL_RESULT status;

    table = Tcl_ObjGetVar2(interp, ovar, NULL, TCL_LEAVE_ERR_MSG);
    if (table == NULL)
        return TCL_ERROR;

    if (Tcl_IsShared(table))
        table = Tcl_DuplicateObj(table);

    status = table_reverse(interp, table);
    TA_ASSERT(status != TCL_OK || table_check(interp, table));
    return ta_set_var_result(interp, status, ovar, table);
}

critcl::cproc tarray::table::size {TableObjPtr TABLE} int {
    return table_length(TABLE);
}

critcl::cproc tarray::table::width {TableObjPtr TABLE} int {
    return table_width(TABLE);
}

critcl::ccommand tarray::table::column {} {
    Tcl_Obj *table;
    TCL_RESULT status;

    if (objc != 3 && objc != 4) {
	Tcl_WrongNumArgs(interp, 1, objv, "TABLEVAR COLSPEC ?NEWCOLUMN?");
	return TCL_ERROR;
    }

    table = objv[1];
    if (objc == 3)
        return table_get_column(interp, table, objv[2]);

    if (Tcl_IsShared(table))
        table = Tcl_DuplicateObj(table);

    status = table_set_column(interp, table, objv[2], objv[3]);
    TA_ASSERT(status != TCL_OK || table_check(interp, table));
    return ta_return_result(interp, status, table);
}

critcl::ccommand tarray::table::vcolumn {} {
    Tcl_Obj *table;
    TCL_RESULT status;

    if (objc != 3 && objc != 4) {
	Tcl_WrongNumArgs(interp, 1, objv, "TABLEVAR COLSPEC ?NEWCOLUMN?");
	return TCL_ERROR;
    }

    table = Tcl_ObjGetVar2(interp, objv[1], NULL, TCL_LEAVE_ERR_MSG);
    if (table == NULL)
        return TCL_ERROR;

    if (objc == 3)
        return table_get_column(interp, table, objv[2]);

    if (Tcl_IsShared(table))
        table = Tcl_DuplicateObj(table);

    status = table_set_column(interp, table, objv[2], objv[3]);
    TA_ASSERT(status != TCL_OK || table_check(interp, table));
    return ta_set_var_result(interp, status, objv[1], table);
}

critcl::cproc tarray::table::_columns {Tcl_Interp* interp TableObjPtr TABLE} ok {
    thdr_t *thdr = OBJTHDR(TABLE);
    Tcl_Obj **tcols = THDRELEMPTR(thdr, Tcl_Obj*, 0);
    Tcl_SetObjResult(interp, Tcl_NewListObj(thdr->used, tcols));
    return TCL_OK;
}

critcl::cproc tarray::table::cnames {Tcl_Interp* interp TableObjPtr TABLE} ok {
    Tcl_SetObjResult(interp, table_column_names(TABLE));
    return TCL_OK;
}

critcl::cproc tarray::table::slice {Tcl_Interp* interp TableObjPtr TABLE Tcl_Obj* COLUMNLIST} ok {
    Tcl_Obj *ocolnames, *ocolname, **pdstcols;
    int      count, status, srcindex;
    thdr_t  *thdr;
    int i;
    Tcl_Obj *oindex;
        
    /* Have to protect against shimmering between TABLE and the COLUMNLIST
       (this would be a caller bug but can cause a crash). In any case,
       since there is no reasonable call in practice where the table and 
       column list are the same, we simply don't allow the two to be
       the same rather than play games with duping objects */
    if (TABLE == COLUMNLIST) {
        Tcl_SetResult(interp, "Invalid column name list", TCL_STATIC);
        return TCL_ERROR;
    }

    if (table_convert(interp, TABLE) != TCL_OK)
        return TCL_ERROR;

    if ((status = Tcl_ListObjLength(interp, COLUMNLIST, &count)) != TCL_OK)
        return status;
    thdr = thdr_alloc(interp, TA_ANY, count);
    if (thdr == NULL)
        return TCL_ERROR;
    /* TBD - maybe we can use column_map_get_columns here ? */
    pdstcols = THDRELEMPTR(thdr, Tcl_Obj *, 0);
    ocolnames = Tcl_NewListObj(0, NULL);
    for (i = 0; i < count; ++i) {
        TA_NOFAIL(Tcl_ListObjIndex(interp, COLUMNLIST, i, &oindex), TCL_OK);
        TA_ASSERT(oindex);
        if (table_parse_column_index(interp, TABLE, oindex, &srcindex) != TCL_OK)
            break;
        if (table_column_index_to_name(interp, TABLE, srcindex, &ocolname) != TCL_OK)
            break;
        /* Everything seems in order. Store name->index mapping */
        Tcl_ListObjAppendElement(NULL, ocolnames, ocolname);
        Tcl_ListObjAppendElement(NULL, ocolnames, Tcl_NewIntObj(i));
        /* Store the column in the output */
        pdstcols[i] = table_column(TABLE, srcindex);
        Tcl_IncrRefCount(pdstcols[i]);
        thdr->used += 1;
    }
    if (i < count)
            status = TCL_ERROR; /* Early termination => error */
    else {
        /*
         * So far so good but tThere is one last thing to be checked - no
         * duplicate names. We do this by checking size of the column
         * names dictionary.
         */
        TA_NOFAIL(Tcl_DictObjSize(interp, ocolnames, &i), TCL_OK);
        status = i == count ? TCL_OK : ta_duplicate_columns_error(interp, COLUMNLIST);
    }

    if (status == TCL_ERROR) {
        thdr_decr_refs(thdr);
        Tcl_DecrRefCount(ocolnames);
    } else {
        Tcl_Obj *otab = table_new(thdr, ocolnames);
        TA_ASSERT(table_check(interp, otab));
        Tcl_SetObjResult(interp, otab);
    }
    return status;
}

# Helper to define integer commands that check overflow.
proc ta_define_integer_command {procname type typestr getfn op objfn} {
    
    set TEMPLATE {
        critcl::cproc tarray::%PROC% {Tcl_Interp* ip Tcl_Obj* oa Tcl_Obj* ob} ok {
            %TYPE%_t a, b, result;
            if (%GETFN%(ip, oa, &a) != TCL_OK || %GETFN%(ip, ob, &b) != TCL_OK)
                return TCL_ERROR;

            if (ovf_%OP%_%TYPE%(a, b, &result)) 
                return ta_integer_overflow_error(ip, "%TYPESTR%", 0);
            else {
                Tcl_SetObjResult(ip, %OBJFN%(result));
                return TCL_OK;
            }
        }
    }

    uplevel 1 [string map [list \
                               %PROC% $procname \
                               %TYPE% $type \
                               %TYPESTR% $typestr \
                               %GETFN%  $getfn \
                               %OP% $op \
                               %OBJFN% $objfn \
                              ] $TEMPLATE]
}

# TBD - document and test commands below
# Byte operations
ta_define_integer_command addu8 uint8 "unsigned 8-bit integer" ta_get_uint8_from_obj add Tcl_NewIntObj
ta_define_integer_command subu8 uint8 "unsigned 8-bit integer" ta_get_uint8_from_obj sub Tcl_NewIntObj
ta_define_integer_command mulu8 uint8 "unsigned 8-bit integer" ta_get_uint8_from_obj mul Tcl_NewIntObj

# 32-bit int operations
ta_define_integer_command add32 int32 "32-bit integer" ta_get_int_from_obj add Tcl_NewIntObj
ta_define_integer_command sub32 int32 "32-bit integer" ta_get_int_from_obj sub Tcl_NewIntObj
ta_define_integer_command mul32 int32 "32-bit integer" ta_get_int_from_obj mul Tcl_NewIntObj

# 32-bit unsigned operations
ta_define_integer_command addu32 uint32 "unsigned 32-bit integer" ta_get_uint_from_obj add Tcl_NewWideIntObj
ta_define_integer_command subu32 uint32 "unsigned 32-bit integer" ta_get_uint_from_obj sub Tcl_NewWideIntObj
ta_define_integer_command mulu32 uint32 "unsigned 32-bit integer" ta_get_uint_from_obj mul Tcl_NewWideIntObj

# 64-bit operations
ta_define_integer_command add64 int64 "64-bit integer" ta_get_int64_from_obj add Tcl_NewWideIntObj
ta_define_integer_command sub64 int64 "64-bit integer" ta_get_int64_from_obj sub Tcl_NewWideIntObj
ta_define_integer_command mul64 int64 "64-bit integer" ta_get_int64_from_obj mul Tcl_NewWideIntObj


critcl::cproc tarray::unsupported::compiler_info {Tcl_Interp* interp} ok {
    Tcl_Obj *objs[6];

    /* Return a keyed list */
    
    objs[0] = Tcl_NewStringObj("compiler", -1);
#if defined(_MSC_VER)
    objs[1] = Tcl_ObjPrintf("vc++ %u", _MSC_VER);
#elif defined(__GNUC__)
    objs[1] = Tcl_NewStringObj("gcc" __VERSION__, -1);
#else
    objs[1] = Tcl_NewStringObj("unknown", -1);
#endif

    objs[2] = Tcl_NewStringObj("opts", -1);

    objs[3] = Tcl_NewListObj(0, NULL);
#ifdef TA_MT_ENABLE
    Tcl_ListObjAppendElement(NULL, objs[3], Tcl_NewStringObj("mt_enabled", -1));
#endif
#if TA_ENABLE_ASSERT
    Tcl_ListObjAppendElement(NULL, objs[3], Tcl_NewStringObj("asserts_enabled", -1));
#endif

    /* Which Tcl did we build against ? (As opposed to run time) */
    objs[4] = Tcl_NewStringObj("tcl_headers", -1);
    objs[5] = Tcl_NewStringObj(TCL_PATCH_LEVEL, -1);

     Tcl_SetObjResult(interp, Tcl_NewListObj(6, objs));
     return TCL_OK;
}

critcl::cdata tarray::unsupported::critcl_info [critcl::showconfig]
# Commented out because will not work when building from TEA
#critcl::cdata tarray::unsupported::hg_id       [exec hg identify]

critcl::cproc tarray::unsupported::mt_split {Tcl_Interp* interp int tatype int first int count int min_hint int nsizes} ok {
#ifdef TA_MT_ENABLE
    int sizes[16];
    Tcl_Obj *ores;
    int i, split_count;
    if (nsizes > ARRAYSIZE(sizes)) {
        Tcl_SetResult(interp, "Invalid array size", TCL_STATIC);
        return TCL_ERROR;
    }
    split_count = thdr_calc_mt_split_ex(tatype, first, count, min_hint, nsizes, sizes);
    ores = Tcl_NewListObj(nsizes, NULL);
    for (i = 0; i < split_count; ++i)
        Tcl_ListObjAppendElement(interp, ores, Tcl_NewIntObj(sizes[i]));
    Tcl_SetObjResult(interp, ores);
    return TCL_OK;
#else
    Tcl_SetResult(interp, "Multithreading not enabled", TCL_STATIC);
    return TCL_ERROR;
#endif
}

critcl::class::define ::tarray::rng {
    include pcg_basic.h
    support {
        ta_value_t get_bounded_random(ta_rng_t *rng, ta_value_t *lbound, ta_value_t *ubound)
        {
            ta_value_t tav;
                
            TA_ASSERT(lbound->type == ubound->type);
            TA_ASSERT(lbound->type != TA_BOOLEAN); /* Does not support bounds */
            switch (lbound->type) {
            case TA_BYTE:
                tav.ucval = pcg32_boundedrand_r(&rng->rng[0],   
                                                ubound->ucval - lbound->ucval);
                tav.ucval += lbound->ucval;
                break;
            case TA_INT:
                tav.ival = pcg32_boundedrand_r(&rng->rng[0], 
                                               ubound->ival - lbound->ival);
                tav.ival += lbound->ival;
                break;
            case TA_UINT:
                tav.uival = pcg32_boundedrand_r(&rng->rng[0], 
                                                ubound->uival - lbound->uival);
                tav.uival += lbound->uival;
                break;
            case TA_WIDE:
                tav.wval = pcg32x2_boundedrand_r(rng->rng,
                                                 ubound->wval - lbound->wval);
                tav.wval += lbound->wval;
                break;
            case TA_DOUBLE:
                tav.dval = pcgdouble_boundedrand_r(rng->rng,
                                                   ubound->dval - lbound->dval);
                tav.dval += lbound->dval;
                break;
            default:
                ta_type_panic(lbound->type);
                break;
            }
            tav.type = lbound->type;
            return tav;
        }
    }
        
    insvariable ta_rng_t rng {} {
        instance->rng.nrefs = 1; /* Does not really matter */
    }
    insvariable {unsigned char} rtype
    insvariable {unsigned char} bounded {} { instance->bounded = 0; }
    insvariable ta_value_t lbound
    insvariable ta_value_t ubound
    constructor {
        if (objc < 1 || objc > 3) {
	    Tcl_AppendResult (interp, "wrong # args: should be \"rng\" new|create TYPE ?LOWBOUND ?HIGHBOUND??", NULL);
            goto error;
        }
        if (ta_parse_type(interp, objv[0], &instance->rtype) != TCL_OK)
            goto error;
        switch (instance->rtype) {
        case TA_BOOLEAN: case TA_BYTE: case TA_INT:
        case TA_UINT: case TA_WIDE: case TA_DOUBLE:
            break;
        default:
            ta_invalid_op_for_type(interp, instance->rtype);
            goto error;
        }
        tcol_random_init(&instance->rng);
        /* Note TA_BOOLEAN do not obey bounds */
        if (objc > 1 && instance->rtype != TA_BOOLEAN) {
            instance->bounded = 1;
            if (ta_value_from_obj(interp, objv[1], instance->rtype, &instance->lbound) != TCL_OK)
                goto error;
            if (objc > 2) {
                if (ta_value_from_obj(interp, objv[2], instance->rtype, &instance->ubound) != TCL_OK)
                    goto error;
            }
            if (ta_rng_fixup_bounds(interp,
                                    &instance->lbound, &instance->ubound,
                                    objc <= 2) != TCL_OK)
                goto error;
        } else if (instance->rtype == TA_BYTE) {
            instance->bounded = 1;
            instance->lbound.type = instance->ubound.type = TA_BYTE;
            instance->lbound.ucval = 0;
            instance->ubound.ucval = 255;
        }
    }
    method_introspection

    method seed proc {Tcl_Obj* SEED1 Tcl_Obj* SEED2} ok {
        Tcl_WideInt seed1;
        Tcl_WideInt seed2;
        TCL_RESULT res;
        if ((res = Tcl_GetWideIntFromObj(interp, SEED1, &seed1)) != TCL_OK ||
            (res = Tcl_GetWideIntFromObj(interp, SEED2, &seed2)) != TCL_OK)
            return res;
        pcg32_srandom_r(&instance->rng.rng[0], seed1, 0xf0f0f0f0);
        pcg32_srandom_r(&instance->rng.rng[1], seed2, 0x0f0f0f0f);
        return TCL_OK;
    }                                            

    method get command {?COUNT? ?LOWER UPPER?} {
        int count;
        int i, bounded;
        Tcl_Obj *ores = NULL;   /* Just to silence bogus gcc uninitialized use warnings */
        ta_value_t lbound, ubound;
        
        count = 1;
        bounded = instance->bounded;
        if (bounded) {
            lbound = instance->lbound;
            ubound = instance->ubound;
        }
        if (objc > 2) {
            if (Tcl_GetIntFromObj(interp, objv[2], &count) != TCL_OK)
                return TCL_ERROR;
            if (count < 0)
                return ta_negative_count_error(interp, count);
            if (objc > 3) {
                if (objc != 5)
                    return ta_invalid_argcount(interp);
                if (instance->rtype == TA_BOOLEAN) {
                    /* Booleans do not support bounds */
                    return ta_invalid_op_for_type(interp, instance->rtype);
                }
                if (ta_value_from_obj(interp, objv[3],
                                      instance->rtype, &lbound) != TCL_OK ||
                    ta_value_from_obj(interp, objv[4],
                                      instance->rtype, &ubound) != TCL_OK ||
                    ta_rng_fixup_bounds(interp, &lbound, &ubound, 0) != TCL_OK)
                    return TCL_ERROR;
                bounded = 1;
            }
        }

        if (count == 0)
            return TCL_OK;

        if (count > 1)
            ores = Tcl_NewListObj(count, NULL);
        if (bounded) {
            for (i = 0; i < count; ++i) {
                ta_value_t tav;
                tav = get_bounded_random(&instance->rng, &lbound, &ubound);
                if (count == 1) {
                    ores = ta_value_to_obj(&tav);
                    break;
                }
                Tcl_ListObjAppendElement(interp, ores, ta_value_to_obj(&tav));
            }
        } else {
            /* Unbounded */
            TA_ASSERT(instance->rtype != TA_BYTE);
            for (i = 0; i < count; ++i) {
                Tcl_Obj *o = NULL; /* Init just to silence gcc's bogus warnings */
                switch (instance->rtype) {
                case TA_BOOLEAN:
                    o = Tcl_NewIntObj(pcgbool_random_r(&instance->rng.rng[0]));
                    break;
                case TA_INT:
                    o = Tcl_NewIntObj(pcg32_random_r(&instance->rng.rng[0]));
                    break;
                case TA_UINT:
                    o = Tcl_NewWideIntObj(pcg32_random_r(&instance->rng.rng[0]));
                    break;
                case TA_WIDE:
                    o = Tcl_NewWideIntObj(pcg32x2_random_r(instance->rng.rng));
                    break;
                case TA_DOUBLE:
                    o = Tcl_NewDoubleObj(pcgdouble_random_r(instance->rng.rng));
                    break;
                default:
                    ta_type_panic(instance->rtype);
                    break;
                }
                if (count == 1) {
                    ores = o;
                    break;
                }
                Tcl_ListObjAppendElement(interp, ores, o);
            }
        }
        Tcl_SetObjResult(interp, ores);
        return TCL_OK;
    }

    method bounded proc {Tcl_Obj* olower Tcl_Obj* oupper} ok {
        ta_value_t lbound, ubound;
        ta_value_t tav;
        if (instance->rtype == TA_BOOLEAN) {
            /* Booleans do not support bounds */
            return ta_invalid_op_for_type(interp, instance->rtype);
        }
        if (ta_value_from_obj(interp, olower,
                              instance->rtype,&lbound) != TCL_OK ||
            ta_value_from_obj(interp, oupper,
                              instance->rtype,&ubound) != TCL_OK ||
            ta_rng_fixup_bounds(interp, &lbound, &ubound, 0) != TCL_OK)
            return TCL_ERROR;
        tav = get_bounded_random(&instance->rng, &lbound, &ubound);
        Tcl_SetObjResult(interp, ta_value_to_obj(&tav));
        return TCL_OK;
    }
}

critcl::ccommand tarray::rbc::init_stubs ta_rbc_init_stubs_cmd 
critcl::ccommand tarray::parseargs parseargs_cmd

package provide tarray [source [file join [file dirname [info script]] taversion.tcl]]

critcl::load

#
# Local Variables:
#  compile-command: "envset x64 && tclsh build.tcl extension -config ../src/tarray.cfg -keep -target win32-dev64"
# End:
