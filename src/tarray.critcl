#
# Copyright (c) 2012, Ashok P. Nadkarni
# All rights reserved.
#
# See the file LICENSE for license


package require critcl 3.1
critcl::buildrequirement {
    package require critcl::class ; # DSL, easy spec of Tcl class/object commands.
}
critcl::clean_cache
critcl::tcl 8.5
#critcl::debug symbols
#critcl::cflags -std=gnu99 -Winline

critcl::cheaders tarray.h

critcl::ccode {
#include "tarray.h"
}

critcl::csources tarray.c  bitarray.c tasort.c
critcl::tsources tarray.tcl

critcl::argtype TArrayObjPtr {
    if (TArrayVerifyType(interp, @@) != TCL_OK)
        return TCL_ERROR;
    @A = @@;
}

critcl::ccommand tarray::column::create {} {
    int init_size;
    int tatype;
    Tcl_Obj **elems;
    int nelems;
    TAHdr *thdrP;

    if (objc < 2 || objc > 4) {
        Tcl_WrongNumArgs(interp, 1, objv, "TYPE ?INITVAL? ?COUNT?");
        return TCL_ERROR;
    }

    if (Tcl_GetIndexFromObj(interp, objv[1], gTArrayTypeTokens, "TArrayType",
                            TCL_EXACT, &tatype) != TCL_OK) {
	return TCL_ERROR;
    }

    init_size = 0;
    nelems = 0;
    elems = NULL;
    if (objc > 2) {
        if (Tcl_ListObjGetElements(interp, objv[2], &nelems, &elems) != TCL_OK)
            return TCL_ERROR;
        if (objc > 3) {
            if (Tcl_GetIntFromObj(interp, objv[3], &init_size) != TCL_OK)
                return TCL_ERROR;
        }
    }

    thdrP = TArrayAllocAndInit(interp, tatype, nelems, elems, init_size);
    if (thdrP == NULL)
        return TCL_ERROR;

    Tcl_SetObjResult(interp, TArrayNewObj(thdrP));
    return TCL_OK;
}

critcl::cproc tarray::column::size {Tcl_Interp* interp Tcl_Obj* taobjP} ok {
    if (TArrayVerifyType(interp, taobjP) != TCL_OK)
        return TCL_ERROR;
    
    Tcl_SetObjResult(interp, Tcl_NewIntObj(TARRAYELEMCOUNT(taobjP)));
    return TCL_OK;
}

critcl::cproc tarray::column::type {Tcl_Interp* interp TArrayObjPtr taobjP} ok {
    int tatype = TARRAYTYPE(taobjP);

    Tcl_SetObjResult(interp, Tcl_NewStringObj(gTArrayTypeTokens[tatype], -1));
    return TCL_OK;
}

critcl::cproc tarray::column::index {Tcl_Interp* interp TArrayObjPtr taObj Tcl_Obj* indexObj} ok {
    Tcl_Obj *objP = TArrayIndex(interp, TARRAYHDR(taObj), indexObj);
    if (objP) {
        Tcl_SetObjResult(interp, objP);
        return TCL_OK;
    } else
        return TCL_ERROR;
}

critcl::cproc tarray::column::range {Tcl_Interp* interp TArrayObjPtr taobjP Tcl_Obj* lowObj Tcl_Obj* highObj} ok {
    TAHdr *thdrP;
    int low, count;

    if (RationalizeRangeIndices(interp, TARRAYHDR(taobjP), lowObj, highObj, &low, &count) != TCL_OK)
        return TCL_ERROR;

    thdrP = TArrayAlloc(TARRAYTYPE(taobjP), count);
    if (thdrP == NULL)
        return TCL_ERROR;

    TAHdrCopy(thdrP, 0, TARRAYHDR(taobjP), low, count);

    Tcl_SetObjResult(interp, TArrayNewObj(thdrP));
    return TCL_OK;
}

critcl::cproc tarray::column::get {Tcl_Interp* interp TArrayObjPtr taobjP Tcl_Obj* indicesP} ok {
    TAHdr *valuesP;
    TAHdr *thdrP = TArrayConvertToIndices(interp, indicesP);
    
    if (thdrP == NULL)
        return TCL_ERROR;

    valuesP = TArrayGetValues(interp, TARRAYHDR(taobjP), thdrP);
    if (valuesP) {
        Tcl_SetObjResult(interp, TArrayNewObj(valuesP));
    }

    TAHDR_DECRREF(thdrP);
    return valuesP ? TCL_OK : TCL_ERROR;
}

critcl::ccommand tarray::column::sort {} {
    static const char *switches[] = {
        "-decreasing", "-increasing", "-indices", NULL
    };
    enum TArraySortSwitches {
        TARRAY_SORT_DECREASING, TARRAY_SORT_INCREASING, TARRAY_SORT_INDICES
    };
    int decreasing = 0;
    int return_indices = 0;
    Tcl_Obj *srcObj;
    int i, n, opt;
    TAHdr *srcP;
    TAHdr *sortedP;
    Tcl_Obj *resultObj;
    int (__cdecl *cmpfn)(const void*, const void*);
    int (__cdecl *cmpindexedfn)(void *, const void*, const void*);

    if (objc < 2) {
	Tcl_WrongNumArgs(interp, 1, objv, "?options? tarray");
	return TCL_ERROR;
    }

    srcObj = objv[objc-1];
    if (TArrayVerifyType(interp, objv[objc-1]) != TCL_OK)
        return TCL_ERROR;
    srcP = TARRAYHDR(objv[objc-1]);
    for (i = 1; i < objc-1; ++i) {
	if (Tcl_GetIndexFromObj(interp, objv[i], switches, "option", 0, &opt)
            != TCL_OK) {
            return TCL_ERROR;
	}
        switch ((enum TArraySortSwitches) opt) {
        case TARRAY_SORT_DECREASING: decreasing = 1; break;
        case TARRAY_SORT_INCREASING: decreasing = 0; break;
        case TARRAY_SORT_INDICES: return_indices = 1; break;
        }
    }

    if (return_indices) {
        int *indexP;
        sortedP = TArrayAlloc(TARRAY_INT, srcP->used);
        resultObj = TArrayNewObj(sortedP);
        /* Initialize the indexes */
        sortedP->used = srcP->used;
        indexP = TAHDRELEMPTR(sortedP, int, 0);
        for (i = 0; i < srcP->used; ++i, ++indexP)
            *indexP = i;

        switch (sortedP->type) {
        case TARRAY_BOOLEAN:
            cmpindexedfn = decreasing ? uintcmpindexedrev : uintcmpindexed;
            break;
        case TARRAY_UINT:
            cmpindexedfn = decreasing ? uintcmpindexedrev : uintcmpindexed;
            break;
        case TARRAY_INT:
            cmpindexedfn = decreasing ? intcmpindexedrev : intcmpindexed;
            break;
        case TARRAY_WIDE:
            cmpindexedfn = decreasing ? widecmpindexedrev : widecmpindexed;
            break;
        case TARRAY_DOUBLE:
            cmpindexedfn = decreasing ? doublecmpindexedrev : doublecmpindexed;
            break;
        case TARRAY_OBJ:
            cmpindexedfn = decreasing ? tclobjcmpindexedrev : tclobjcmpindexed;
            break;
        default:
            TArrayTypePanic(sortedP->type);
        }
        tarray_qsort_r(TAHDRELEMPTR(sortedP, int, 0), sortedP->used, sizeof(int), TAHDRELEMPTR(srcP, unsigned char, 0), cmpindexedfn);
    } else {
        /* We want sorted contents. If object is not shared, we can
           sort in place, else need to modify */
        if (Tcl_IsShared(srcObj) || TAHDR_SHARED(srcP)) {
            /* Cannot modify in place. Need to dup it */
            sortedP = TAHdrClone(srcP, 0);
            resultObj = TArrayNewObj(sortedP);
        } else {
            sortedP = srcP;
            resultObj = srcObj;
            Tcl_InvalidateStringRep(resultObj);
        }
        /*
         * Return sorted contents. Boolean type we treat separately
         * since we just need to count how many 1's and 0's.
         */
        if (sortedP->type == TARRAY_BOOLEAN) {
            ba_t *baP = TAHDRELEMPTR(sortedP, ba_t, 0);
            n = ba_count_ones(baP, 0, sortedP->used); /* Number of 1's set */
            if (decreasing) {
                ba_fill(baP, 0, n, 1);
                ba_fill(baP, n, sortedP->used - n, 0);
            } else {
                ba_fill(baP, 0, sortedP->used - n, 0);
                ba_fill(baP, sortedP->used - n, n, 1);
            }
        } else {
            switch (sortedP->type) {
            case TARRAY_UINT:
                cmpfn = decreasing ? uintcmprev : uintcmp;
                break;
            case TARRAY_INT:
                cmpfn = decreasing ? intcmprev : intcmp;
                break;
            case TARRAY_WIDE:
                cmpfn = decreasing ? widecmprev : widecmp;
                break;
            case TARRAY_DOUBLE:
                cmpfn = decreasing ? doublecmprev : doublecmp;
                break;
            case TARRAY_OBJ:
                cmpfn = decreasing ? tclobjcmprev : tclobjcmp;
                break;
            default:
                TArrayTypePanic(sortedP->type);
            }
            qsort(TAHDRELEMPTR(sortedP, unsigned char, 0), sortedP->used,
                  sortedP->elem_bits / CHAR_BIT, cmpfn);
        }
    }

    Tcl_SetObjResult(interp, resultObj);
    return TCL_OK;
}

critcl::cproc tarray::column::bitsset {Tcl_Interp* interp TArrayObjPtr taobjP} ok {
    TAHdr *thdrP = TARRAYHDR(taobjP);
    if (thdrP->type != TARRAY_BOOLEAN) {
        Tcl_SetResult(interp, "tarray type is not boolean", TCL_STATIC);
        return TCL_ERROR;
    }
        
    Tcl_SetObjResult(
        interp,
        Tcl_NewIntObj(ba_count_ones(TAHDRELEMPTR(thdrP, ba_t, 0), 0, thdrP->used)));
    return TCL_OK;
}

critcl::ccommand tarray::column::search TArray_SearchObjCmd

critcl::ccommand tarray::column::delete {} {
    Tcl_Obj *taObj;
    TAHdr *thdrP;
    int low, count;

    if (objc != 3 && objc != 4) {
	Tcl_WrongNumArgs(interp, 1, objv, "TARRAY LOW ?HIGH?");
	return TCL_ERROR;
    }
    
    if (TArrayVerifyType(interp, objv[1]) != TCL_OK)
        return TCL_ERROR;
    thdrP = TARRAYHDR(objv[1]);
    if (RationalizeRangeIndices(interp, thdrP, objv[2],
                                objc == 4 ? objv[3] : objv[2],
                                &low, &count) != TCL_OK)
        return TCL_ERROR;

    taObj = TArrayMakeWritable(objv[1], thdrP->used, thdrP->used, 0);
    /* Note thdrP potentially INVALID at this point */
    TAHdrDelete(TARRAYHDR(taObj), low, count);
    Tcl_SetObjResult(interp, taObj);
    return TCL_OK;
}

critcl::ccommand tarray::column::fill {} {
    if (objc != 4 && objc != 5) {
	Tcl_WrongNumArgs(interp, 1, objv, "TARRAY VALUE LOW ?HIGH?");
	return TCL_ERROR;
    }
    
    return TArrayGridFillFromObjs(interp, objv[3], objv[objc == 5 ? 4 : 3], &objv[1], &objv[2], 1, TARRAY_FILL_SINGLE);
}

critcl::ccommand tarray::grid::fill {} {
    int i, tuple_width;
    Tcl_Obj **taObjs;
    Tcl_Obj **valueObjs;
    Tcl_Obj *gridObj;
    int we_own_gridobj;
    int status;

    if (objc != 4 && objc != 5) {
	Tcl_WrongNumArgs(interp, 1, objv, "TARRAYLIST VALUELIST LOW ?HIGH?");
	return TCL_ERROR;
    }

    gridObj = objv[1];
    if (Tcl_IsShared(gridObj)) {
        gridObj = Tcl_DuplicateObj(gridObj);
        we_own_gridobj = 1;
    } else
        we_own_gridobj = 0;

    status = TCL_ERROR;
    if (Tcl_ListObjGetElements(interp, gridObj, &tuple_width, &taObjs) == TCL_OK) {
        if (Tcl_ListObjGetElements(interp, objv[2], &i, &valueObjs) == TCL_OK) {
            if (i == tuple_width) {
                if (tuple_width == 0)
                    status = TCL_OK;          /* Return empty result */
                else
                    status =
                        TArrayGridFillFromObjs(interp, objv[3],
                                               objv[objc == 5 ? 4 : 3],
                                               taObjs, valueObjs,
                                               tuple_width, 0);
            } else {
                Tcl_SetResult(interp, "Count of values supplied does not match count of tarrays", TCL_STATIC);
                return TCL_ERROR;
            }
        }
    }

    if (we_own_gridobj)
        Tcl_DecrRefCount(gridObj);

    return status;
}

package provide tarray 0.1

