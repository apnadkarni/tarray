#
# Copyright (c) 2012-2015, Ashok P. Nadkarni
# All rights reserved.
#
# See the file LICENSE for license
#

proc win32_target {} {
    switch -glob -- [critcl::targetconfig] {
        win32-* -
        mingw* { return 1 }
        default { return 0 }
    }
}

################################################################
# Set up configuration options for the package
array set build_opts {}

# Enable compiling of unsupported functions
set build_opts(unsupported) 1

# Figure out whether parallelized operations are to be enabled.
# On Windows, parallelized operations are enabled via native Win32 calls.
# Other platforms depend on the presence of libdispatch.
if {[win32_target]} {
    set build_opts(mt_enable) 1
    set build_opts(use_libdispatch) 0
} else {
    if {[critcl::check {
        #include <dispatch/dispatch.h>
    }]} {
        set build_opts(mt_enable) 1
        set build_opts(use_libdispatch) 1
    } else {
        set build_opts(mt_enable) 0
        set build_opts(use_libdispatch) 0
    }
}


################################################################
# Standard critcl meta information

package require critcl 3.1
critcl::buildrequirement {
    package require critcl::class
}

critcl::license "Ashok P. Nadkarni"
critcl::summary "Tcl Typed Array Extension"
critcl::description {
    Implements the tarray::column and tarray::table commands providing 
    accessed to typed array values. This extension is targeted towards
    Tcl applications dealing with a large number of data items.
}

critcl::clean_cache
critcl::tcl 8.6

################################################################
# Compiler/platform specific flags
if {[string match "*-gcc" [critcl::targetconfig]] ||
    [string match "linux-*-\\*" [critcl::targetconfig]] ||
    [string match  "mingw*" [critcl::targetconfig]]} {
    # Flags required for gcc
    critcl::cflags -std=gnu99 -Winline
}

if {[win32_target]} {
   # Need XP at least
   critcl::cflags -D_WIN32_WINNT=0x0500
}

critcl::csources bitarray.c errors.c parseargs.c \
    table.c tafold.c tajoin.c taloop.c \
    tamath.c tarandom.c tarbc.c tarray.c tasearch.c tasort.c tastring.c \
    timsort.c timsort_r.c pcg_basic.c \
    rbcStubLib.c

if {$build_opts(unsupported)} {
    critcl::csources unsupported.c
    critcl::ccommand tarray::unsupported::dump ta_dump_cmd

}
critcl::tsources tabulate.tcl tarray.tcl taprint.tcl tarbc.tcl taversion.tcl
critcl::cheaders tarray.h bitarray.h timsort.h timsort-impl.h pcg_basic.h rbcDecls.h

critcl::ccode {
#include "tarray.h"
#include <math.h>
#include <fenv.h>
#include "pcg_basic.h"
}

if {$build_opts(mt_enable)} {

    if {! $build_opts(use_libdispatch)} {
        critcl::csources mt.c
    }

    critcl::cflags -DTA_MT_ENABLE
}

critcl::ccommand tarray::unsupported::config {} {
    const char *vname;
    int *pval;	 
    if (objc < 2 || objc > 3) {
        Tcl_WrongNumArgs(interp, 1, objv, "CONFIGVAR ?VALUE?");
        return TCL_ERROR;
    }

    vname = Tcl_GetString(objv[1]);
    if (ta_strequal(vname, "experiment"))
        pval = &ta_experiment;
    else if (ta_strequal(vname, "full_validation"))
        pval = &ta_full_validation;
#ifdef TA_MT_ENABLE
    else if (ta_strequal(vname, "sort_mt_threshold"))
        pval = &ta_sort_mt_threshold;
    else if (ta_strequal(vname, "sort_mt_enable_any"))
        pval = &ta_sort_mt_enable_any;
    else if (ta_strequal(vname, "search_mt_threshold"))
        pval = &ta_search_mt_threshold;
    else if (ta_strequal(vname, "fill_mt_threshold"))
        pval = &ta_fill_mt_threshold;
    else if (ta_strequal(vname, "minmax_mt_threshold"))
        pval = &ta_minmax_mt_threshold;
    else if (ta_strequal(vname, "fold_mt_threshold"))
        pval = &ta_fold_mt_threshold;
    else if (ta_strequal(vname, "math_mt_threshold"))
        pval = &ta_math_mt_threshold;
#endif
    else {
        Tcl_SetResult(interp, "Invalid config setting name.", TCL_STATIC);
        return TCL_ERROR;
    }

    if (objc == 3) {
        if (Tcl_GetIntFromObj(interp, objv[2], pval) != TCL_OK)
        return TCL_ERROR;
    }
    Tcl_SetObjResult(interp, Tcl_NewIntObj(*pval));
    return TCL_OK;
}

if {$build_opts(use_libdispatch)} {
    critcl::clibraries -ldispatch
    critcl::cflags -DTA_USE_LIBDISPATCH
}


################################################################
# Type conversions

# WARNING: do not use this where there are multiple parameters to avoid
# shimmering crashes
critcl::argtype TColObjPtr {
    if (tcol_convert(interp, @@) != TCL_OK)
        return TCL_ERROR;
    @A = @@;
}

# WARNING: do not use this where there are multiple parameters to avoid
# shimmering crashes
critcl::argtype TableObjPtr {
    if (table_convert(interp, @@) != TCL_OK)
        return TCL_ERROR;
    @A = @@;
}

################################################################
# Common functions

critcl::ccode {
    typedef Tcl_Obj *TColObjPtr;
    typedef Tcl_Obj *TableObjPtr;

    /*
     * If status is success, sets ip result to ores. Always returns status.
     * ores might be deallocated unless caller makes sure it is holding a 
     * ref count. Primary purpose of this trivial routine is to deal
     * with returning an object that might have been either allocated
     * or be an existing object passed in the objv[] array to a command.
     */
    TCL_RESULT ta_return_result(Tcl_Interp *ip, TCL_RESULT status, Tcl_Obj *ores)
    {
        Tcl_IncrRefCount(ores);
        if (status == TCL_OK)
            Tcl_SetObjResult(ip, ores);
        Tcl_DecrRefCount(ores);
        return status;
    }

    /*
     * Sets the value of the variable given by ovarname to ovalue and sets the
     * the interp result to the resulting value of the variable (which may be
     * different from ovalue because of traces).
     * 
     * IMPORTANT: Caller should NOT access ovalue again unless it has protected
     * it by bumping its ref count.
     */
    TCL_RESULT ta_set_var_result(Tcl_Interp *ip, TCL_RESULT status, Tcl_Obj *ovarname, Tcl_Obj *ovalue)
    {
        Tcl_Obj *oresult;
        Tcl_IncrRefCount(ovalue);
        if (status == TCL_OK) {
            oresult = Tcl_ObjSetVar2(ip, ovarname, NULL, ovalue, TCL_LEAVE_ERR_MSG);
            if (oresult)
                Tcl_SetObjResult(ip, oresult);
            else
                status = TCL_ERROR;
        }
        Tcl_DecrRefCount(ovalue);

        return status;
    }

}

################################################################
# Initialization

critcl::cinit {

    TA_ASSERT(ba_sanity_check() == 0);
    g_tcl_int_type_ptr = Tcl_GetObjType("int");
    g_tcl_double_type_ptr = Tcl_GetObjType("double");
    g_tcl_wide_type_ptr = Tcl_GetObjType("wide");
    g_tcl_dict_type_ptr = Tcl_GetObjType("dict");
    g_tcl_list_type_ptr = Tcl_GetObjType("list");
    g_tcl_string_type_ptr = Tcl_GetObjType("string");

    Tcl_NRCreateCommand(interp, "::tarray::loop",
                        ta_loop_cmd, ta_loop_nr_cmd, NULL, NULL);
    {
        /* Commands related to random number generation */
	ta_rng_t *prng;
        prng = ckalloc(sizeof(ta_rng_t));
        tcol_random_init(prng);
        prng->nrefs = 4;        /* For each command reference below */
	/* 
	 * Note all commands have the same ta_random_rng_delete
	 * as last parameter. That's not a typo
	 */
	Tcl_CreateObjCommand(interp, "::tarray::column::random",
                             tcol_random_cmd, prng, ta_random_rng_delete);
        Tcl_CreateObjCommand(interp, "::tarray::randseed",
                             ta_randseed_cmd, prng, ta_random_rng_delete);
        Tcl_CreateObjCommand(interp, "::tarray::column::shuffle",
                             tcol_shuffle_cmd, prng, ta_random_rng_delete);
        Tcl_CreateObjCommand(interp, "::tarray::column::vshuffle",
                             tcol_vshuffle_cmd, prng, ta_random_rng_delete);
    }
} {
}

################################################################
# General commands

# Check if two Tcl_Obj pointers refer to the same object
critcl::cproc tarray::_same_tclobj {Tcl_Obj* o1 Tcl_Obj* o2} int {
    return o1 == o2;
}

# TBD - tests and docs for the types command
critcl::ccommand tarray::types {} {
    int i;
    Tcl_Obj *o;
    Tcl_Obj *res;

    res = Tcl_NewListObj(objc-1, NULL);
    for (i = 1; i < objc; ++i) {
        o = objv[i];

        /* Try to convert to a tarray type but only if the type pointer is
         * a list, string or NULL. We don't want to disturb other types
         */
        if (o->typePtr == NULL ||
            o->typePtr == g_tcl_string_type_ptr ||
            o->typePtr == g_tcl_list_type_ptr) {
            if (table_convert(NULL, o) != TCL_OK)
                tcol_convert(NULL, o);
        }

        if (table_affirm(o)) {
            Tcl_ListObjAppendElement(interp, res, Tcl_NewStringObj("table", sizeof("table")-1));
        } else if (tcol_affirm(o)) {
            Tcl_ListObjAppendElement(interp, res,
                             Tcl_NewStringObj(ta_type_string(tcol_type(o)), -1));
        } else {
            Tcl_ListObjAppendElement(interp, res, Tcl_NewObj());
        }
    }
    Tcl_SetObjResult(interp, res);
    return TCL_OK;
}

################################################################
# Column commands
critcl::ccommand tarray::column::create {} {
    int init_size;
    unsigned char tatype;
    Tcl_Obj **elems;
    int nelems;
    thdr_t *thdrP;
    Tcl_Obj *o;

    if (objc < 2 || objc > 4) {
        Tcl_WrongNumArgs(interp, 1, objv, "TYPE ?INITVAL? ?INITSIZE?");
        return TCL_ERROR;
    }

    if (ta_parse_type(interp, objv[1], &tatype) != TCL_OK)
	return TCL_ERROR;

    init_size = 0;
    nelems = 0;
    elems = NULL;
    if (objc > 2) {
        if (objc > 3) {
            if (Tcl_GetIntFromObj(interp, objv[3], &init_size) != TCL_OK)
                return TCL_ERROR;
        }
        if (tcol_convert(NULL, objv[2]) == TCL_OK) {
            span_t *span;
            int first, count;
            thdr_t *thdr2;
            o = objv[2];
            if (tcol_type(o) == tatype) {
                Tcl_SetObjResult(interp, o); /* Already the right type */
                return TCL_OK;
            }
            thdrP = tcol_thdr(o);

            /* Special case - if signed/unsigned issue AND unshared 
               AND no string rep just flip the thdr header */
            if (! Tcl_IsShared(o) && o->bytes == NULL) {
                if (thdrP->nrefs == 1) {
                    if (thdrP->type == TA_INT && tatype == TA_UINT ||
                        thdrP->type == TA_UINT && tatype == TA_INT) {
                        thdrP->type = tatype;
                        thdrP->sort_order = THDR_UNSORTED;
                        Tcl_SetObjResult(interp, o);
                        return TCL_OK;
                    }
                }
            }

            span = tcol_span(o);
            if (span) {
                first = span->first;
                count = span->count;
            } else {
                first = 0;
                count = thdrP->used;
            }
            
            thdr2 = thdr_alloc(interp, tatype, count > init_size ? count : init_size);
            if (thdr2 == NULL)
                return TCL_ERROR;
            if (thdr_copy_cast(interp, thdr2, 0, thdrP, first, count, 0, 1) != TCL_OK) {
                thdr_decr_refs(thdr2);
                return TCL_ERROR;
            }
            o = tcol_new(thdr2);
            TA_ASSERT(tcol_check(interp, o));
            Tcl_SetObjResult(interp, o);
            return TCL_OK;
        }
        
        /* Initializer is not a column. Treat as a list */
        if (Tcl_ListObjGetElements(interp, objv[2], &nelems, &elems) != TCL_OK)
            return TCL_ERROR;
    }

    thdrP = thdr_alloc_and_init(interp, tatype, nelems, elems, init_size);
    if (thdrP == NULL)
        return TCL_ERROR;

    o = tcol_new(thdrP);

    TA_ASSERT(tcol_check(interp, o));
    Tcl_SetObjResult(interp, o);
    return TCL_OK;
}

critcl::ccommand tarray::column::delete {} {
    Tcl_Obj *tcol;
    int status;

    if (objc != 3 && objc != 4) {
	Tcl_WrongNumArgs(interp, 1, objv, "TARRAY (INDEXLIST | LOW ?HIGH?)");
	return TCL_ERROR;
    }
    
    tcol = objv[1];
    if (Tcl_IsShared(tcol))
        tcol = Tcl_DuplicateObj(objv[1]);

    status = tcol_delete(interp, tcol, objv[2], objc == 4 ? objv[3] : NULL);
    TA_ASSERT(status != TCL_OK || tcol_check(interp, tcol));
    return ta_return_result(interp, status, tcol);
}

critcl::ccommand tarray::column::vdelete {} {
    Tcl_Obj *tcol;
    int status;

    if (objc != 3 && objc != 4) {
	Tcl_WrongNumArgs(interp, 1, objv, "TARRAYVAR (INDEXLIST | LOW ?HIGH?)");
	return TCL_ERROR;
    }
    
    tcol = Tcl_ObjGetVar2(interp, objv[1], NULL, TCL_LEAVE_ERR_MSG);
    if (tcol == NULL)
        return TCL_ERROR;
    if (Tcl_IsShared(tcol))
        tcol = Tcl_DuplicateObj(tcol);

    status = tcol_delete(interp, tcol, objv[2], objc == 4 ? objv[3] : NULL);
    TA_ASSERT(status != TCL_OK || tcol_check(interp, tcol));
    return ta_set_var_result(interp, status, objv[1], tcol);
}

critcl::cproc tarray::column::size {TColObjPtr tcol} int {
    return tcol_occupancy(tcol);
}

critcl::cproc tarray::column::type {TColObjPtr tcol} Tcl_Obj*0 {
    return Tcl_NewStringObj(ta_type_string(tcol_type(tcol)), -1);
}

critcl::cproc tarray::column::equal {Tcl_Interp* ip Tcl_Obj* o1 Tcl_Obj* o2} ok {
    int equal;
    if (tcol_convert(ip, o1) != TCL_OK || tcol_convert(ip, o2) != TCL_OK)
        return TCL_ERROR;
    equal = tcol_equality_test(ip, o1, o2, 0);
    Tcl_SetObjResult(ip, Tcl_NewBooleanObj(equal));
    return TCL_OK;
}

critcl::cproc tarray::column::identical {Tcl_Interp* ip Tcl_Obj* o1 Tcl_Obj* o2} ok {
    int equal;
    if (tcol_convert(ip, o1) != TCL_OK || tcol_convert(ip, o2) != TCL_OK)
        return TCL_ERROR;
    equal = tcol_equality_test(ip, o1, o2, 1);
    Tcl_SetObjResult(ip, Tcl_NewBooleanObj(equal));
    return TCL_OK;
}

critcl::cproc tarray::column::cast {Tcl_Interp* interp Tcl_Obj* COLTYPE Tcl_Obj* COLUMN} ok {
    int count, first;
    unsigned char tatype;
    thdr_t *thdr, *thdr2;
    Tcl_Obj *o;
    span_t *span;

    if (ta_parse_type(interp, COLTYPE, &tatype) != TCL_OK)
	return TCL_ERROR;

    /* Convert the column AFTER COLTYPE conversion above to protect against
       shimmering */
    if (tcol_convert(interp, COLUMN) != TCL_OK)
        return TCL_ERROR;
    
    if (tcol_type(COLUMN) == tatype) {
        Tcl_SetObjResult(interp, COLUMN);
        return TCL_OK;
    }

    /* Special case - if signed/unsigned issue AND unshared just flip the
     * thdr header. Note that even if the thdr->nrefs is 1, the thdr
     * is shared if the Tcl_Obj is itself shared.
     */
    thdr = tcol_thdr(COLUMN);
    if ((thdr->type == TA_INT && tatype == TA_UINT 
         ||
         thdr->type == TA_UINT && tatype == TA_INT)
        && thdr->nrefs == 1 
        && ! Tcl_IsShared(COLUMN)) {
        /* Need to invalid existing string rep since a int like -1
         * would now have a string rep of 4294967295 and vice versa */
        Tcl_InvalidateStringRep(COLUMN);
        thdr->type = tatype;
        thdr->sort_order = THDR_UNSORTED;
        Tcl_SetObjResult(interp, COLUMN);
        return TCL_OK;
    }

    span = tcol_span(COLUMN);
    if (span) {
       first = span->first;
       count = span->count;
    } else {
        first = 0;
        count = thdr->used;
    }
            
    thdr2 = thdr_alloc(interp, tatype, count);
    if (thdr2 == NULL)
        return TCL_ERROR;
    if (thdr_copy_cast(interp, thdr2, 0, thdr, first, count, 0, 0) != TCL_OK) {
        thdr_decr_refs(thdr2);
        return TCL_ERROR;
    }
    o = tcol_new(thdr2);
    TA_ASSERT(tcol_check(interp, o));
    Tcl_SetObjResult(interp, o);
    return TCL_OK;
}

critcl::cproc tarray::column::index {Tcl_Interp* interp Tcl_Obj* COLUMN Tcl_Obj* INDEX} ok {
    int ix;
    Tcl_Obj *o;
    if (ta_convert_index(interp, INDEX, &ix, tcol_occupancy(COLUMN)-1, 0, tcol_occupancy(COLUMN)-1) != TCL_OK)
        return TCL_ERROR;

    /* Convert the column AFTER INDEX conversion above to protect against
       shimmering in case both refer to same object */
    if (tcol_convert(interp, COLUMN) != TCL_OK)
        return TCL_ERROR;

    o = tcol_index(interp, COLUMN, ix);
    if (o) {
        Tcl_SetObjResult(interp, o);
        return TCL_OK;
    } else
        return TCL_ERROR;
}

critcl::ccommand tarray::column::get {} {
    return tcol_retrieve(interp, objc, objv, TA_RETRIEVE_GET);
}

critcl::ccommand tarray::column::range {} {
    return tcol_retrieve(interp, objc, objv, TA_RETRIEVE_RANGE);
}

critcl::ccommand tarray::column::Sort {} {
    int flags, status;
    Tcl_Obj *tcol;
    Tcl_Obj *otarget = NULL;

    if (objc < 2) {
	Tcl_WrongNumArgs(interp, 1, objv, "?options? tarray");
	return TCL_ERROR;
    }

    if ((status = tcol_parse_sort_options(interp, objc, objv, &flags, &otarget)) != TCL_OK)
        return status;

    tcol = objv[objc-1];
    if (Tcl_IsShared(tcol))
        tcol = Tcl_DuplicateObj(tcol);

    if (flags & TA_SORT_INDIRECT) {
        TA_ASSERT(otarget != NULL);
        status = tcol_sort_indirect(interp, tcol, otarget, flags);
    } else
        status = tcol_sort(interp, tcol, flags);

    TA_ASSERT(status != TCL_OK || tcol_check(interp, tcol));
    return ta_return_result(interp, status, tcol);
}

critcl::ccommand tarray::column::vsort {} {
    Tcl_Obj *tcol;
    int status;
    int flags;
    Tcl_Obj *otarget = NULL;

    if (objc < 2) {
    	Tcl_WrongNumArgs(interp, 1, objv, "?options? COLUMNVAR");
        return TCL_ERROR;
    }

    if ((status = tcol_parse_sort_options(interp, objc, objv, &flags, &otarget)) != TCL_OK)
        return status;

    if (flags & TA_SORT_INDICES) {
        Tcl_SetResult(interp, "Invalid option -indices", TCL_STATIC);
        return TCL_ERROR;
    }

    tcol = Tcl_ObjGetVar2(interp, objv[objc-1], NULL, TCL_LEAVE_ERR_MSG);
    if (tcol == NULL)
        return TCL_ERROR;
    if (Tcl_IsShared(tcol))
        tcol = Tcl_DuplicateObj(tcol);

    if (flags & TA_SORT_INDIRECT) {
        TA_ASSERT(otarget != NULL);
        status = tcol_sort_indirect(interp, tcol, otarget, flags);
    } else {
        status = tcol_sort(interp, tcol, flags);
    }

    TA_ASSERT(status != TCL_OK || tcol_check(interp, tcol));
    return ta_set_var_result(interp, status, objv[objc-1], tcol);
}

# TBD - is this documented? Also test cases
critcl::cproc tarray::column::bitsset {Tcl_Interp* interp Tcl_Obj* COLUMN} ok {
    thdr_t *thdrP;
    span_t *span;
    int count, first;

    if (tcol_convert(interp, COLUMN) != TCL_OK)
        return TCL_ERROR;

    thdrP = tcol_thdr(COLUMN);
    
    if (thdrP->type != TA_BOOLEAN) {
        Tcl_SetResult(interp, "tarray type is not boolean", TCL_STATIC);
        return TCL_ERROR;
    }
        
    span = tcol_span(COLUMN);
    if (span) {
        first = span->first;
        count = span->count;
    } else {
        first = 0;
        count = thdrP->used;
    }
    Tcl_SetObjResult(
        interp,
        Tcl_NewIntObj(ba_count_ones(THDRELEMPTR(thdrP, ba_t, 0), first, first+count)));
    return TCL_OK;
}

critcl::ccommand tarray::column::series tcol_series_cmd

critcl::ccommand tarray::column::search tcol_search_cmd

critcl::ccommand tarray::column::lookup tcol_lookup_cmd

critcl::ccommand tarray::column::minmax tcol_minmax_cmd

critcl::ccommand tarray::column::math tcol_math_cmd

critcl::ccommand tarray::column::fold tcol_fold_cmd

critcl::ccommand tarray::column::_equalintervals tcol_equalintervals_cmd

critcl::ccommand tarray::column::_sortmerge_helper tcol_sortmerge_helper_cmd

critcl::ccommand tarray::column::insert {} {
    Tcl_Obj *tcol;
    int status;
    int count;

    if (objc != 4 && objc != 5) {
    	Tcl_WrongNumArgs(interp, 1, objv, "COLUMN VALUE POSITION ?COUNT?");
	return TCL_ERROR;
    }
    
    if (objc == 5) {
        status = ta_get_int_from_obj(interp, objv[4], &count);
        if (status != TCL_OK)
            return status;
    } else
        count = 1;
    
    tcol = objv[1];
    if (Tcl_IsShared(tcol))
        tcol = Tcl_DuplicateObj(tcol);
    status = tcol_insert_elem(interp, tcol, objv[2], objv[3], count);
    TA_ASSERT(status != TCL_OK || tcol_check(interp, tcol));
    return ta_return_result(interp, status, tcol);
}

critcl::ccommand tarray::column::vinsert {} {
    Tcl_Obj *tcol;
    int status;
    int count;

    if (objc != 4 && objc != 5) {
    	Tcl_WrongNumArgs(interp, 1, objv, "COLUMNVAR VALUE POSITION ?COUNT?");
	return TCL_ERROR;
    }
    
    if (objc == 5) {
        status = ta_get_int_from_obj(interp, objv[4], &count);
        if (status != TCL_OK)
            return status;
    } else
        count = 1;
    
    tcol = Tcl_ObjGetVar2(interp, objv[1], NULL, TCL_LEAVE_ERR_MSG);
    if (tcol == NULL)
        return TCL_ERROR;
    if (Tcl_IsShared(tcol))
        tcol = Tcl_DuplicateObj(tcol);
    status = tcol_insert_elem(interp, tcol, objv[2], objv[3], count);
    TA_ASSERT(status != TCL_OK || tcol_check(interp, tcol));
    return ta_set_var_result(interp, status, objv[1], tcol);
}

critcl::ccommand tarray::column::inject {} {
    Tcl_Obj *tcol;
    int status;

    if (objc != 4) {
    	Tcl_WrongNumArgs(interp, 1, objv, "COLUMN VALUES POSITION");
	return TCL_ERROR;
    }
    
    tcol = objv[1];
    if (Tcl_IsShared(tcol))
        tcol = Tcl_DuplicateObj(tcol);
    status = tcol_inject_elems(interp, tcol, objv[2], objv[3]);
    TA_ASSERT(status != TCL_OK || tcol_check(interp, tcol));
    return ta_return_result(interp, status, tcol);
}

critcl::ccommand tarray::column::vinject {} {
    Tcl_Obj *tcol;
    int status;

    if (objc != 4) {
    	Tcl_WrongNumArgs(interp, 1, objv, "COLUMNVAR VALUES POSITION");
	return TCL_ERROR;
    }
    
    tcol = Tcl_ObjGetVar2(interp, objv[1], NULL, TCL_LEAVE_ERR_MSG);
    if (tcol == NULL)
        return TCL_ERROR;
    if (Tcl_IsShared(tcol))
        tcol = Tcl_DuplicateObj(tcol);
    status = tcol_inject_elems(interp, tcol, objv[2], objv[3]);
    TA_ASSERT(status != TCL_OK || tcol_check(interp, tcol));
    return ta_set_var_result(interp, status, objv[1], tcol);
}

critcl::cproc tarray::column::put {Tcl_Interp* interp Tcl_Obj* COLUMN Tcl_Obj* VALUES Tcl_Obj* {FIRST 0}} ok {
    Tcl_Obj *tcol;
    int status;

    tcol = COLUMN;
    if (Tcl_IsShared(tcol))
        tcol = Tcl_DuplicateObj(tcol);

    /* Values may be given as a list or a tarray */
    if (tcol_convert(NULL, VALUES) == TCL_OK) {
        /* It is a tarray. Verify the right type */
        status = tcol_copy_thdr(interp, tcol, tcol_thdr(VALUES), tcol_span(VALUES), FIRST, 0);
    } else {
        status = tcol_put_objs(interp, tcol, VALUES, FIRST, 0);
    }

    TA_ASSERT(status != TCL_OK || tcol_check(interp, tcol));
    return ta_return_result(interp, status, tcol);
}

critcl::cproc tarray::column::vput {Tcl_Interp* interp Tcl_Obj* COLUMNVAR Tcl_Obj* VALUES Tcl_Obj* {FIRST 0}} ok {
    Tcl_Obj *tcol;
    int status;

    tcol = Tcl_ObjGetVar2(interp, COLUMNVAR, NULL, TCL_LEAVE_ERR_MSG);
    if (tcol == NULL)
        return TCL_ERROR;
    if (Tcl_IsShared(tcol))
        tcol = Tcl_DuplicateObj(tcol);

    /* Values may be given as a list or a tarray */
    if (tcol_convert(NULL, VALUES) == TCL_OK) {
        /* It is a tarray */
        status = tcol_copy_thdr(interp, tcol, tcol_thdr(VALUES), tcol_span(VALUES), FIRST, 0);
    } else {
        status = tcol_put_objs(interp, tcol, VALUES, FIRST, 0);
    }
    TA_ASSERT(status != TCL_OK || tcol_check(interp, tcol));
    return ta_set_var_result(interp, status, COLUMNVAR, tcol);
}

critcl::cproc tarray::column::place {Tcl_Interp* interp Tcl_Obj* COLUMN Tcl_Obj* VALUES Tcl_Obj* INDICES} ok {
    int status;

    if (Tcl_IsShared(COLUMN))
        COLUMN = Tcl_DuplicateObj(COLUMN);

    if (tcol_convert(NULL, VALUES) == TCL_OK)
        status = tcol_place_indices(interp, COLUMN, VALUES, INDICES);
    else
        status = tcol_place_objs(interp, COLUMN, VALUES, INDICES);
    TA_ASSERT(status != TCL_OK || tcol_check(interp, COLUMN));
    return ta_return_result(interp, status, COLUMN);
}

critcl::cproc tarray::column::vplace {Tcl_Interp* interp Tcl_Obj* COLUMNVAR Tcl_Obj* VALUES Tcl_Obj* INDICES} ok {
    Tcl_Obj *tcol;
    int status;

    tcol = Tcl_ObjGetVar2(interp, COLUMNVAR, NULL, TCL_LEAVE_ERR_MSG);
    if (tcol == NULL)
        return TCL_ERROR;
    if (Tcl_IsShared(tcol))
        tcol = Tcl_DuplicateObj(tcol);
    
    if (tcol_convert(NULL, VALUES) == TCL_OK)
        status = tcol_place_indices(interp, tcol, VALUES, INDICES);
    else
        status = tcol_place_objs(interp, tcol, VALUES, INDICES);

    TA_ASSERT(status != TCL_OK || tcol_check(interp, tcol));
    return ta_set_var_result(interp, status, COLUMNVAR, tcol);
}

critcl::ccommand tarray::column::fill {} {
    Tcl_Obj *tcol;
    int status;

    if (objc != 4 && objc != 5) {
	Tcl_WrongNumArgs(interp, 1, objv, "COLUMN VALUE (INDEXLIST | LOW ?HIGH?)");
	return TCL_ERROR;
    }

    tcol = objv[1];
    if (Tcl_IsShared(tcol))
        tcol = Tcl_DuplicateObj(tcol);

    status = tcol_fill_obj(interp, tcol, objv[2], objv[3],
                               objc == 5 ? objv[4] : NULL);
    TA_ASSERT(status != TCL_OK || tcol_check(interp, tcol));
    return ta_return_result(interp, status, tcol);
}

critcl::ccommand tarray::column::vfill {} {
    Tcl_Obj *tcol;
    int status;

    if (objc != 4 && objc != 5) {
	Tcl_WrongNumArgs(interp, 1, objv, "TCOLUMNVAR VALUE (INDEXLIST | LOW ?HIGH?)");
	return TCL_ERROR;
    }
    
    tcol = Tcl_ObjGetVar2(interp, objv[1], NULL, TCL_LEAVE_ERR_MSG);
    if (tcol == NULL)
        return TCL_ERROR;
    if (Tcl_IsShared(tcol))
        tcol = Tcl_DuplicateObj(tcol);

    status = tcol_fill_obj(interp, tcol, objv[2], objv[3], objc == 5 ? objv[4] : NULL);
    TA_ASSERT(status != TCL_OK || tcol_check(interp, tcol));
    return ta_set_var_result(interp, status, objv[1], tcol);
}

critcl::cproc tarray::column::reverse {Tcl_Interp* interp Tcl_Obj* tcol} ok {
    TCL_RESULT status;
    if (Tcl_IsShared(tcol))
        tcol = Tcl_DuplicateObj(tcol);
    status = tcol_reverse(interp, tcol);
    TA_ASSERT(status != TCL_OK || tcol_check(interp, tcol));
    return ta_return_result(interp, status, tcol);
}
    
critcl::cproc tarray::column::vreverse {Tcl_Interp* interp Tcl_Obj* ovar} ok {
    Tcl_Obj *tcol;
    TCL_RESULT status;
    tcol = Tcl_ObjGetVar2(interp, ovar, NULL, TCL_LEAVE_ERR_MSG);
    if (tcol == NULL)
        return TCL_ERROR;
    if (Tcl_IsShared(tcol))
        tcol = Tcl_DuplicateObj(tcol);

    status = tcol_reverse(interp, tcol);
    TA_ASSERT(status != TCL_OK || tcol_check(interp, tcol));
    return ta_set_var_result(interp, status, ovar, tcol);
}

critcl::ccommand tarray::column::intersect3 {} {
    Tcl_Obj *acol, *bcol;
    thdr_t *athdr, *bthdr;
    span_t *aspan, *bspan;
    int     afirst, acount, bfirst, bcount;
    thdr_t *aintersectb=NULL, *aminusb=NULL, *bminusa=NULL;
    int atype;
    unsigned char order, a_current_order, b_current_order;
    int free_acol = 0, free_bcol = 0;
    TCL_RESULT status = TCL_ERROR;
    int sort_flags, nmin, nocase = 0;
    Tcl_Obj *results[3];

    if (objc != 3 && objc != 4) {
	Tcl_WrongNumArgs(interp, 1, objv, "?-nocase? COLUMNA COLUMNB");
	return TCL_ERROR;
    }

    if (objc == 4) {
        if (! ta_strequal(Tcl_GetString(objv[1]), "-nocase"))
            return ta_invalid_opt_error(interp, "-nocase");
        nocase = 1;
    }

    acol = objv[objc-2];
    bcol = objv[objc-1];

    if ((status = tcol_convert(interp, acol)) != TCL_OK ||
        (status = tcol_convert(interp, bcol)) != TCL_OK)
        return status;

    athdr = OBJTHDR(acol);
    aspan = OBJTHDRSPAN(acol);
    atype = athdr->type;
    acount = aspan? aspan->count : athdr->used;
    bthdr = OBJTHDR(bcol);
    bspan = OBJTHDRSPAN(bcol);
    bcount = bspan? bspan->count : bthdr->used;

    if (athdr == bthdr && aspan == bspan) {
        /* TBD - also special case when either column is zero size */
        /* Optimize same object. Dunno how common this might be but ... */
        results[0] = acol;
        aminusb = thdr_alloc(interp, atype, 0);
        if (aminusb == NULL)
            goto vamoose;
        results[1] = tcol_new(aminusb);
        results[2] = results[1];
        Tcl_SetObjResult(interp, Tcl_NewListObj(3, results));
        return TCL_OK;
    }

    if (atype != bthdr->type)
        return ta_mismatched_types_error(interp, atype, bthdr->type);

    a_current_order = athdr->sort_order;
    b_current_order = bthdr->sort_order;

    /* Ensure both columns are in same sort order */
    order = THDR_UNSORTED;
    if (atype == TA_ANY || atype == TA_STRING) {
        /* TA_ANY/TA_STRING separated because we have to deal with nocase */
        if (a_current_order == b_current_order) {
            /* If unsorted or sorted with different case-sensitivity, resort */
            if ((nocase && SORT_ORDER_IS_NOCASE(a_current_order)) ||
                (!nocase && SORT_ORDER_IS_CASE(a_current_order))) {
                /* Both sorted appropriately. Lucky us, nought to do */
                order = a_current_order;
            } else {
                /* Either unsorted or wrong case sensitivity. We have to
                   sort/resort but try to make it as close to current
                   order for efficiency
                */
                if (SORT_ORDER_IS_DESCENDING(a_current_order))
                    order = nocase ? THDR_SORTED_DESCENDING_NOCASE : THDR_SORTED_DESCENDING;
                else
                    order = nocase ? THDR_SORTED_ASCENDING_NOCASE : THDR_SORTED_ASCENDING;
            }
        } else {
            /* Sort state is different for a and b */
            if ((nocase && SORT_ORDER_IS_NOCASE(a_current_order)) ||
                (!nocase && SORT_ORDER_IS_CASE(a_current_order))) {
                /* a is sorted appropriately. */
                if ((nocase && SORT_ORDER_IS_NOCASE(b_current_order)) ||
                    (!nocase && SORT_ORDER_IS_CASE(b_current_order))) {
                    /* b is also sorted appropriately but different from a, choose to sort smaller one.*/
                    order = acount < bcount ? b_current_order : a_current_order;
                } else
                    order = a_current_order; /* Only b needs sorting */
            } else {
                /* a is not sorted appropriately. */
                if ((nocase && SORT_ORDER_IS_NOCASE(b_current_order)) ||
                    (!nocase && SORT_ORDER_IS_CASE(b_current_order))) {
                    /* But b is so use its order */
                    order = b_current_order; /* sort a as b */
                } else {
                    /* Neither is sorted appropriately. Both will have to
                       be sorted. Still try to optimize by picking
                       something closer to the bigger column.
                    */
                    if (acount >= bcount) {
                        if (SORT_ORDER_IS_DESCENDING(a_current_order))
                            order = nocase ? THDR_SORTED_DESCENDING_NOCASE : THDR_SORTED_DESCENDING;
                        else if (SORT_ORDER_IS_ASCENDING(a_current_order))
                            order = nocase ? THDR_SORTED_ASCENDING_NOCASE : THDR_SORTED_ASCENDING;
                    }  
                    if (order == 0) {
                        if (SORT_ORDER_IS_DESCENDING(b_current_order))
                            order = nocase ? THDR_SORTED_DESCENDING_NOCASE : THDR_SORTED_DESCENDING;
                        else
                            order = nocase ? THDR_SORTED_ASCENDING_NOCASE : THDR_SORTED_ASCENDING;
                    }
                }
            }
        }
    } else if (atype != TA_BOOLEAN) {
        if (a_current_order == b_current_order) {
            if (a_current_order == THDR_UNSORTED)
                order = THDR_SORTED_ASCENDING;/* Both need sorting */
            else
                order = a_current_order;
        }
        else {
            /* a and b not sorted the same */
            if (a_current_order == THDR_UNSORTED)
                order = b_current_order; /* Sort a same as b */
            else if (bthdr->sort_order == THDR_UNSORTED)
                order = a_current_order; /* Sort b same as a */
            else {
                /* Both are sorted but not in same order. Resort the smaller */
                if (athdr->used < bthdr->used)
                    order = b_current_order;
                else
                    order = a_current_order;
            }
        }
    }
    
    if (atype != TA_BOOLEAN) {
        switch (order) {
        case THDR_SORTED_ASCENDING:         sort_flags = 0; break;
        case THDR_SORTED_DESCENDING:        sort_flags = TA_SORT_DECREASING; break;
        case THDR_SORTED_ASCENDING_NOCASE:  sort_flags = TA_SORT_NOCASE; break;
        case THDR_SORTED_DESCENDING_NOCASE: sort_flags = TA_SORT_NOCASE | TA_SORT_DECREASING; break;
        default:
            sort_flags = 0; /* Keep gcc happy */
            Tcl_Panic("Unexpected sort order %d in function intersect", order);
        }
                                                                        
        if (a_current_order != order) {
            /* a needs to be sorted. Needs to be unshared to do so */
            if (Tcl_IsShared(acol)) {
                acol = Tcl_DuplicateObj(acol);
                free_acol = 1;
            }
            if (tcol_sort(interp, acol, sort_flags) != TCL_OK)
                goto vamoose;
            athdr = tcol_thdr(acol);
            aspan = tcol_span(acol);
            TA_ASSERT(aspan == NULL);
            TA_ASSERT(acount == tcol_occupancy(acol));
        }

        if (b_current_order != order) {
            /* b needs to be sorted. Needs to be unshared to do so */
            if (Tcl_IsShared(bcol)) {
                bcol = Tcl_DuplicateObj(bcol);
                free_bcol = 1;
            }
            if (tcol_sort(interp, bcol, sort_flags) != TCL_OK)
                goto vamoose;
            bthdr = tcol_thdr(bcol);
            bspan = tcol_span(bcol);
            TA_ASSERT(bspan == NULL);
            TA_ASSERT(bcount == tcol_occupancy(bcol));
        }
    }

    /*
     * Create 3 arrays to hold the a intersect b, a-b, b-a.
     * Max num elems in intersect is smaller of two arrays.
     * Max num in a-b and b-a is num in a and b respectively.
     */
    nmin = acount;
    if (nmin > bcount)
        nmin = bcount;

    aintersectb = thdr_alloc(interp, atype, nmin);
    aminusb = thdr_alloc(interp, atype, acount);
    bminusa = thdr_alloc(interp, atype, bcount);
    if (aintersectb == NULL || aminusb == NULL || bminusa == NULL)
        goto vamoose;

    afirst = aspan ? aspan->first : 0;
    bfirst = bspan ? bspan->first : 0;
    
    /* IMPORTANT - INTERSECT must NOT error out else ref counts for
       type TA_ANY will be broken as they are updated later */
#define EQ(x_, y_) ((x_) == (y_))
#define LT(x_, y_) ((x_) < (y_))
#define INTERSECT(t_)                                                   \
    do {                                                                \
        t_ *pintersect = THDRELEMPTR(aintersectb, t_, 0);               \
        t_ *paminusb = THDRELEMPTR(aminusb, t_, 0);                     \
        t_ *pbminusa = THDRELEMPTR(bminusa, t_, 0);                     \
        t_ *a = THDRELEMPTR(athdr, t_, afirst);                         \
        t_ *b = THDRELEMPTR(bthdr, t_, bfirst);                         \
        t_ *aend = a + acount;                                     \
        t_ *bend = b + bcount;                                     \
                                                                        \
        if (SORT_ORDER_IS_ASCENDING(order)) {                           \
            while (a < aend && b < bend) {                              \
                if (EQ(*a, *b)) {                                       \
                    *pintersect++ = *a;                                 \
                    ++a;                                                \
                    ++b;                                                \
                } else if (LT(*a, *b)) {                                \
                    *paminusb++ = *a++;                                 \
                } else {                                                \
                    *pbminusa++ = *b++;                                 \
                }                                                       \
            }                                                           \
        } else {                                                        \
            /* Sorted in descending order */                            \
            while (a < aend && b < bend) {                              \
                if (EQ(*a, *b)) {                                       \
                    *pintersect++ = *a;                                 \
                    ++a;                                                \
                    ++b;                                                \
                } else if (LT(*a, *b)) {                                \
                    *pbminusa++ = *b++;                                 \
                } else {                                                \
                    *paminusb++ = *a++;                                 \
                }                                                       \
            }                                                           \
        }                                                               \
                                                                        \
        /* Now copy left over elements */                               \
        while (a < aend) {                                              \
            *paminusb++ = *a++;                                         \
        }                                                               \
        while (b < bend) {                                              \
            *pbminusa++ = *b++;                                         \
        }                                                               \
                                                                        \
        aintersectb->used = pintersect - THDRELEMPTR(aintersectb, t_, 0); \
        aminusb->used = paminusb - THDRELEMPTR(aminusb, t_, 0);         \
        bminusa->used = pbminusa - THDRELEMPTR(bminusa, t_, 0);         \
    } while (0)

    switch (atype) {
    case TA_BOOLEAN:
       {
           int ones_in_a, ones_in_b, zeroes_in_a, zeroes_in_b;
           int ones, zeroes;
           ba_t *pbits;
           ones_in_a = ba_count_ones(THDRELEMPTR(athdr, ba_t, 0), afirst, afirst+acount);
           ones_in_b = ba_count_ones(THDRELEMPTR(bthdr, ba_t, 0), bfirst, bfirst+bcount);
           zeroes_in_a = acount - ones_in_a;
           zeroes_in_b = bcount - ones_in_b;
           ones = ones_in_a < ones_in_b ? ones_in_a : ones_in_b;
           zeroes = zeroes_in_a < zeroes_in_b ? zeroes_in_a : zeroes_in_b;
           pbits = THDRELEMPTR(aintersectb, ba_t, 0);
           ba_fill(pbits, 0, zeroes, 0);
           ba_fill(pbits, zeroes, ones, 1);
           aintersectb->used = ones + zeroes;
           pbits = THDRELEMPTR(aminusb, ba_t, 0);
           if (zeroes_in_a > zeroes) {
               aminusb->used = zeroes_in_a - zeroes;
               ba_fill(pbits, 0, aminusb->used, 0);
           }
           if (ones_in_a > ones) {
               ba_fill(pbits, aminusb->used, ones_in_a - ones, 1);
               aminusb->used += ones_in_a - ones;
           }
           pbits = THDRELEMPTR(bminusa, ba_t, 0);
           if (zeroes_in_b > zeroes) {
               bminusa->used = zeroes_in_b - zeroes;
               ba_fill(pbits, 0, bminusa->used, 0);
           }
           if (ones_in_b > ones) {
               ba_fill(pbits, bminusa->used, ones_in_b - ones, 1);
               bminusa->used += ones_in_b - ones;
           }
       }
       break;

    case TA_UINT:
        INTERSECT(unsigned int);
        break;
    case TA_INT:
        INTERSECT(int);
        break;
    case TA_WIDE:
        INTERSECT(Tcl_WideInt);
        break;
    case TA_DOUBLE:
        INTERSECT(double);
        break;
    case TA_BYTE:
        INTERSECT(unsigned char);
        break;
    case TA_ANY:
#undef EQ
#undef LT
        /* TBD - why not EQ -> ta_obj_equal ? */
#define EQ(x_, y_) (ta_obj_compare((x_), (y_), nocase) == 0)
#define LT(x_, y_) (ta_obj_compare((x_), (y_), nocase) < 0)
        INTERSECT(Tcl_Obj *);
        /* Need to update ref counts */
        thdr_incr_obj_refs(aintersectb, 0, aintersectb->used);
        thdr_incr_obj_refs(aminusb, 0, aminusb->used);
        thdr_incr_obj_refs(bminusa, 0, bminusa->used);
        break;
    case TA_STRING:
#undef EQ
#undef LT
#define EQ(x_, y_) (tas_equal((x_), (y_), nocase))
#define LT(x_, y_) (tas_compare((x_), (y_), nocase) < 0)
        INTERSECT(tas_t *);
        /* Need to update ref counts */
        thdr_incr_tas_refs(aintersectb, 0, aintersectb->used);
        thdr_incr_tas_refs(aminusb, 0, aminusb->used);
        thdr_incr_tas_refs(bminusa, 0, bminusa->used);
        break;
    }

#undef EQ
#undef LT
    TA_ASSERT(aintersectb->used <= aintersectb->usable);
    TA_ASSERT(aminusb->used <= aminusb->usable);
    TA_ASSERT(bminusa->used <= bminusa->usable);
           
    /* TBD - shrink arrays if underutilized */

    results[0] = tcol_new(aintersectb);
    results[1] = tcol_new(aminusb);
    results[2] = tcol_new(bminusa);
    TA_ASSERT(tcol_check(interp, results[0]));
    TA_ASSERT(tcol_check(interp, results[1]));
    TA_ASSERT(tcol_check(interp, results[2]));
    Tcl_SetObjResult(interp, Tcl_NewListObj(3, results));

    status = TCL_OK;

vamoose:
    if (free_acol)
        Tcl_DecrRefCount(acol);
    if (free_bcol)
        Tcl_DecrRefCount(bcol);
    if (status != TCL_OK) {
        if (aintersectb)
            thdr_decr_refs(aintersectb);
        if (aminusb)
            thdr_decr_refs(aminusb);
        if (bminusa)
            thdr_decr_refs(bminusa);
    }
    return status;
}

critcl::ccode {
    static TCL_RESULT table_put_parseargs(
        Tcl_Interp *ip, int objc, Tcl_Obj * const *objv,
        Tcl_Obj **potab, Tcl_Obj **povalues, Tcl_Obj **pomap, Tcl_Obj **poff)
    {
        if (objc < 3 || objc > 6) {
            if (ip)
                Tcl_WrongNumArgs(ip, 1, objv, "?-columns COLUMNMAP? TABLE VALUES ?POSITION?");
            return TCL_ERROR;
        }
        
        switch (objc) {
        case 3:
        case 4:
            /* Cannot contain an valid option. Parse as though no options */
            *pomap = NULL;
            *potab = objv[1];
            *povalues = objv[2];
            *poff = objc == 4 ? objv[3] : NULL;
            break;
        case 5:
        case 6:
            /* If valid, options must be present */
            /* To prevent shimmering, don't check for options if a tarray */
            if (strcmp(Tcl_GetString(objv[1]), "-columns"))
                return ta_invalid_opt_error(ip, Tcl_GetString(objv[1]));
            *pomap = objv[2];
            *potab = objv[3];
            *povalues = objv[4];
            *poff = objc == 6 ? objv[5] : NULL;
            break;
        }
        return TCL_OK;
    }
}

################################################################
# Table commands

critcl::ccommand tarray::table::put {} {
    Tcl_Obj *table, *ovalues, *omap, *ofirst;
    int status;

    if ((status = table_put_parseargs(interp, objc, objv, &table, &ovalues, &omap, &ofirst)) != TCL_OK)
        return status;

    if (Tcl_IsShared(table))
        table = Tcl_DuplicateObj(table);
    /* Values may be given as a table or a Tcl list */
    if (table_convert(NULL, ovalues) == TCL_OK)
        status = table_copy(interp, table, ovalues, ofirst, omap, 0);
    else
        status = table_put_objs(interp, table, ovalues, ofirst, omap, 0);

    TA_ASSERT(status != TCL_OK || table_check(interp, table));
    return ta_return_result(interp, status, table);
}

critcl::ccommand tarray::table::vput {} {
    Tcl_Obj *ovar, *table, *ovalues, *omap, *ofirst;
    int status;

    if ((status = table_put_parseargs(interp, objc, objv, &ovar, &ovalues, &omap, &ofirst)) != TCL_OK)
        return status;

    table = Tcl_ObjGetVar2(interp, ovar, NULL, TCL_LEAVE_ERR_MSG);
    if (table == NULL)
        return TCL_ERROR;
    if (Tcl_IsShared(table))
        table = Tcl_DuplicateObj(table);

    /* Values may be given as a table or a Tcl list */
    if (table_convert(NULL, ovalues) == TCL_OK)
        status = table_copy(interp, table, ovalues, ofirst, omap, 0);
    else
        status = table_put_objs(interp, table, ovalues, ofirst, omap, 0);

    TA_ASSERT(status != TCL_OK || table_check(interp, table));
    return ta_set_var_result(interp, status, ovar, table);
}

critcl::ccode {

    static TCL_RESULT table_fill_parseargs(
    Tcl_Interp *ip, int objc, Tcl_Obj * const *objv,
    Tcl_Obj **potab, Tcl_Obj **porow, Tcl_Obj **aindex, Tcl_Obj **bindex, Tcl_Obj **pomap)
    {
        int argoff;

        if (objc < 4 || objc > 7) {
            if (ip)
                Tcl_WrongNumArgs(ip, 1, objv, "?-columns COLUMNMAP? TABLE ROW (INDEXLIST | LOW ?HIGH?)");
            return TCL_ERROR;
        }

        argoff = 0;
        *pomap = NULL;
        /* If 4 or 5 args, no options are present */
        if (objc > 5) {
            /* To prevent shimmering, don't check for options if a tarray */
            if (strcmp(Tcl_GetString(objv[1]), "-columns"))
                return ta_invalid_opt_error(ip, Tcl_GetString(objv[1]));
            argoff = 2;
            *pomap = objv[2];
        }

        *potab = objv[++argoff];
        *porow = objv[++argoff];
        *aindex = objv[++argoff];
        *bindex = ++argoff < objc ? objv[argoff] : NULL;
        
        return TCL_OK;

    }
}

critcl::ccommand tarray::table::fill {} {
    Tcl_Obj *table, *orow, *aindex, *bindex, *omap;
    int status;

    if (table_fill_parseargs(interp, objc, objv, &table, &orow, &aindex, &bindex, &omap) != TCL_OK)
        return TCL_ERROR;

    if (Tcl_IsShared(table))
        table = Tcl_DuplicateObj(table);

    status = table_fill_obj(interp, table, orow, aindex, bindex, omap, 0);
    TA_ASSERT(status != TCL_OK || table_check(interp, table));
    return ta_return_result(interp, status, table);
}

critcl::ccommand tarray::table::vfill {} {
    int status;
    Tcl_Obj *ovar, *table, *orow, *aindex, *bindex, *omap;

    if (table_fill_parseargs(interp, objc, objv, &ovar, &orow, &aindex, &bindex, &omap) != TCL_OK)
        return TCL_ERROR;

    table = Tcl_ObjGetVar2(interp, ovar, NULL, TCL_LEAVE_ERR_MSG);
    if (table == NULL)
        return TCL_ERROR;
    if (Tcl_IsShared(table))
        table = Tcl_DuplicateObj(table);

    status = table_fill_obj(interp, table, orow, aindex, bindex, omap, 0);
    TA_ASSERT(status != TCL_OK || table_check(interp, table));
    return ta_set_var_result(interp, status, ovar, table);
}

critcl::ccommand tarray::table::delete {} {
    Tcl_Obj *table;
    int status;

    if (objc != 3 && objc != 4) {
	Tcl_WrongNumArgs(interp, 1, objv, "TABLE (INDEXLIST | LOW ?HIGH?)");
	return TCL_ERROR;
    }
    
    table = objv[1];
    if (Tcl_IsShared(table))
        table = Tcl_DuplicateObj(table);
    status = table_delete(interp, table, objv[2], objc == 4 ? objv[3] : NULL);
    TA_ASSERT(status != TCL_OK || table_check(interp, table));
    return ta_return_result(interp, status, table);
}


critcl::ccommand tarray::table::vdelete {} {
    Tcl_Obj *table;
    int status;

    if (objc != 3 && objc != 4) {
	Tcl_WrongNumArgs(interp, 1, objv, "TABLEVAR (INDEXLIST | LOW ?HIGH?)");
	return TCL_ERROR;
    }
    
    table = Tcl_ObjGetVar2(interp, objv[1], NULL, TCL_LEAVE_ERR_MSG);
    if (table == NULL)
        return TCL_ERROR;
    if (Tcl_IsShared(table))
        table = Tcl_DuplicateObj(table);
    status = table_delete(interp, table, objv[2], objc == 4 ? objv[3] : NULL);
    TA_ASSERT(status != TCL_OK || table_check(interp, table));
    return ta_set_var_result(interp, status, objv[1], table);
}

critcl::ccommand tarray::table::get {} {
    return table_retrieve(interp, objc, objv, TA_RETRIEVE_GET);
}

critcl::ccommand tarray::table::range {} {
    return table_retrieve(interp, objc, objv, TA_RETRIEVE_RANGE);
}

critcl::cproc tarray::table::index {Tcl_Interp* interp Tcl_Obj* GRID Tcl_Obj* INDEX} ok {
    int ix;
    Tcl_Obj *o;

    if (table_convert(interp, GRID) == TCL_OK) {
        int end = table_length(GRID) - 1;
	if (ta_convert_index(interp, INDEX, &ix, end, 0, end) == TCL_OK) {
            o = table_index(interp, GRID, ix);
            if (o) {
                Tcl_SetObjResult(interp, o);
                return TCL_OK;
            }
        }
    }
    return TCL_ERROR;
}


critcl::ccode {

    static TCL_RESULT table_insert_parseargs(
    Tcl_Interp *ip, int objc, Tcl_Obj * const *objv,
    Tcl_Obj **potab, Tcl_Obj **povalues, Tcl_Obj **pofirst,  int *pcount, Tcl_Obj **pomap)
    {
        int argoff;

        if (objc < 4 || objc > 7) {
            if (ip)
                Tcl_WrongNumArgs(ip, 1, objv, "?-columns COLUMNMAP? TABLE ROW LOW ?COUNT?");
            return TCL_ERROR;
        }

        argoff = 0;
        *pomap = NULL;
        /* If 4 or 5 args, no options are present */
        if (objc > 5) {
            if (strcmp(Tcl_GetString(objv[1]), "-columns"))
                return ta_invalid_opt_error(ip, Tcl_GetString(objv[1]));
            argoff = 2;
            *pomap = objv[2];
        }

        *potab = objv[++argoff];
        *povalues = objv[++argoff];
        *pofirst = objv[++argoff];
        if (++argoff < objc) {
            if (ta_get_int_from_obj(ip, objv[argoff], pcount) != TCL_OK)
                return TCL_ERROR;
        } else
            *pcount = 1;
        
        return TCL_OK;
    }

    static TCL_RESULT table_inject_parseargs(
    Tcl_Interp *ip, int objc, Tcl_Obj * const *objv,
    Tcl_Obj **potab, Tcl_Obj **povalues, Tcl_Obj **pofirst, Tcl_Obj **pomap)
    {
        int argoff;

        if (objc != 4 && objc != 6) {
            if (ip)
                Tcl_WrongNumArgs(ip, 1, objv, "?-columns COLUMNMAP? TABLE ROWS POS");
            return TCL_ERROR;
        }

        argoff = 0;
        *pomap = NULL;
        if (objc == 6) {
            if (strcmp(Tcl_GetString(objv[1]), "-columns"))
                return ta_invalid_opt_error(ip, Tcl_GetString(objv[1]));
            argoff = 2;
            *pomap = objv[2];
        }

        *potab = objv[++argoff];
        *povalues = objv[++argoff];
        *pofirst = objv[++argoff];
        return TCL_OK;
    }
}

critcl::ccommand tarray::table::insert {} {
    Tcl_Obj *table, *ovalues, *ofirst, *omap;
    int status, count;

    if (table_insert_parseargs(interp, objc, objv, &table, &ovalues,
                               &ofirst, &count, &omap) != TCL_OK)
        return TCL_ERROR;

    if (Tcl_IsShared(table))
        table = Tcl_DuplicateObj(table);
    status = table_insert_row(interp, table, ovalues, ofirst, count, omap);
    TA_ASSERT(status != TCL_OK || table_check(interp, table));
    return ta_return_result(interp, status, table);
}

critcl::ccommand tarray::table::vinsert {} {
    Tcl_Obj *ovar, *table, *ovalues, *ofirst, *omap;
    int status, count;

    if (table_insert_parseargs(interp, objc, objv, &ovar, &ovalues,
                               &ofirst, &count, &omap) != TCL_OK)
        return TCL_ERROR;

    table = Tcl_ObjGetVar2(interp, ovar, NULL, TCL_LEAVE_ERR_MSG);
    if (table == NULL)
        return TCL_ERROR;
    if (Tcl_IsShared(table))
        table = Tcl_DuplicateObj(table);
    status = table_insert_row(interp, table, ovalues, ofirst, count, omap);
    TA_ASSERT(status != TCL_OK || table_check(interp, table));
    return ta_set_var_result(interp, status, ovar, table);
}

critcl::ccommand tarray::table::inject {} {
    Tcl_Obj *table, *ovalues, *ofirst, *omap;
    int status;

    if (table_inject_parseargs(interp, objc, objv, &table, &ovalues,
                               &ofirst, &omap) != TCL_OK)
        return TCL_ERROR;

    if (Tcl_IsShared(table))
        table = Tcl_DuplicateObj(table);
    status = table_inject_rows(interp, table, ovalues, ofirst, omap);
    TA_ASSERT(status != TCL_OK || table_check(interp, table));
    return ta_return_result(interp, status, table);
}

critcl::ccommand tarray::table::vinject {} {
    Tcl_Obj *ovar, *table, *ovalues, *ofirst, *omap;
    int status;

    if (table_inject_parseargs(interp, objc, objv, &ovar, &ovalues,
                               &ofirst, &omap) != TCL_OK)
        return TCL_ERROR;

    table = Tcl_ObjGetVar2(interp, ovar, NULL, TCL_LEAVE_ERR_MSG);
    if (table == NULL)
        return TCL_ERROR;
    if (Tcl_IsShared(table))
        table = Tcl_DuplicateObj(table);
    status = table_inject_rows(interp, table, ovalues, ofirst, omap);
    TA_ASSERT(status != TCL_OK || table_check(interp, table));
    return ta_set_var_result(interp, status, ovar, table);
}

critcl::ccode {
    static TCL_RESULT table_place_parseargs(Tcl_Interp *ip, int objc, Tcl_Obj * const *objv, Tcl_Obj **potab, Tcl_Obj **povalues, Tcl_Obj **poindices, Tcl_Obj **pomap)
    {
        int argpos;
	char *s;
    
        if (objc == 4) {
            argpos = 0;
            *pomap = NULL;
        } else {
            if (objc != 6) {
                if (ip)
                    Tcl_WrongNumArgs(ip, 1, objv, "?-columns COLUMNMAP? TABLE VALUES INDICES");
                return TCL_ERROR;
            }
	    s = Tcl_GetString(objv[1]);
            if (strcmp(s, "-columns"))
                return ta_invalid_opt_error(ip, s);
            argpos = 2;
            *pomap = objv[2];
        }

        *potab = objv[1+argpos];
        *povalues = objv[2+argpos];
        *poindices = objv[3+argpos];
        
        return TCL_OK;
    }
}

critcl::ccommand tarray::table::place {} {
    int status;
    Tcl_Obj *otab, *ovalues, *oindices, *omap;
    
    if (table_place_parseargs(interp, objc, objv, &otab, &ovalues,
                           &oindices, &omap) != TCL_OK)
        return TCL_ERROR;

    if (Tcl_IsShared(otab))
        otab = Tcl_DuplicateObj(otab);

    status = table_place(interp, otab, ovalues, oindices, omap);
    TA_ASSERT(status != TCL_OK || table_check(interp, otab));
    return ta_return_result(interp, status, otab);
}


critcl::ccommand tarray::table::vplace {} {
    int status;
    Tcl_Obj *ovar, *ovalues, *oindices, *omap, *otab;
    
    if (table_place_parseargs(interp, objc, objv, &ovar, &ovalues,
                           &oindices, &omap) != TCL_OK)
        return TCL_ERROR;

    otab = Tcl_ObjGetVar2(interp, ovar, NULL, TCL_LEAVE_ERR_MSG);
    if (otab == NULL)
        return TCL_ERROR;
    if (Tcl_IsShared(otab))
        otab = Tcl_DuplicateObj(otab);
    
    status = table_place(interp, otab, ovalues, oindices, omap);
    TA_ASSERT(status != TCL_OK || table_check(interp, otab));
    return ta_set_var_result(interp, status, ovar, otab);
}

critcl::cproc tarray::table::reverse {Tcl_Interp* interp Tcl_Obj* table} ok {
    TCL_RESULT status;
    if (Tcl_IsShared(table))
        table = Tcl_DuplicateObj(table);

    status = table_reverse(interp, table);
    TA_ASSERT(status != TCL_OK || table_check(interp, table));
    return ta_return_result(interp, status, table);
}
    
critcl::cproc tarray::table::vreverse {Tcl_Interp* interp Tcl_Obj* ovar} ok {
    Tcl_Obj *table;
    TCL_RESULT status;

    table = Tcl_ObjGetVar2(interp, ovar, NULL, TCL_LEAVE_ERR_MSG);
    if (table == NULL)
        return TCL_ERROR;

    if (Tcl_IsShared(table))
        table = Tcl_DuplicateObj(table);

    status = table_reverse(interp, table);
    TA_ASSERT(status != TCL_OK || table_check(interp, table));
    return ta_set_var_result(interp, status, ovar, table);
}

critcl::cproc tarray::table::size {TableObjPtr TABLE} int {
    return table_length(TABLE);
}

critcl::cproc tarray::table::width {TableObjPtr TABLE} int {
    return table_width(TABLE);
}

critcl::ccommand tarray::table::column {} {
    Tcl_Obj *table;
    TCL_RESULT status;

    if (objc != 3 && objc != 4) {
	Tcl_WrongNumArgs(interp, 1, objv, "TABLEVAR COLSPEC ?NEWCOLUMN?");
	return TCL_ERROR;
    }

    table = objv[1];
    if (objc == 3)
        return table_get_column(interp, table, objv[2]);

    if (Tcl_IsShared(table))
        table = Tcl_DuplicateObj(table);

    status = table_set_column(interp, table, objv[2], objv[3]);
    TA_ASSERT(status != TCL_OK || table_check(interp, table));
    return ta_return_result(interp, status, table);
}

critcl::ccommand tarray::table::vcolumn {} {
    Tcl_Obj *table;
    TCL_RESULT status;

    if (objc != 3 && objc != 4) {
	Tcl_WrongNumArgs(interp, 1, objv, "TABLEVAR COLSPEC ?NEWCOLUMN?");
	return TCL_ERROR;
    }

    table = Tcl_ObjGetVar2(interp, objv[1], NULL, TCL_LEAVE_ERR_MSG);
    if (table == NULL)
        return TCL_ERROR;

    if (objc == 3)
        return table_get_column(interp, table, objv[2]);

    if (Tcl_IsShared(table))
        table = Tcl_DuplicateObj(table);

    status = table_set_column(interp, table, objv[2], objv[3]);
    TA_ASSERT(status != TCL_OK || table_check(interp, table));
    return ta_set_var_result(interp, status, objv[1], table);
}

critcl::cproc tarray::table::_columns {Tcl_Interp* interp TableObjPtr TABLE} ok {
    thdr_t *thdr = OBJTHDR(TABLE);
    Tcl_Obj **tcols = THDRELEMPTR(thdr, Tcl_Obj*, 0);
    Tcl_SetObjResult(interp, Tcl_NewListObj(thdr->used, tcols));
    return TCL_OK;
}

critcl::cproc tarray::table::cnames {Tcl_Interp* interp TableObjPtr TABLE} ok {
    Tcl_SetObjResult(interp, table_column_names(TABLE));
    return TCL_OK;
}

critcl::cproc tarray::table::slice {Tcl_Interp* interp TableObjPtr TABLE Tcl_Obj* COLUMNLIST} ok {
    Tcl_Obj *ocolnames, *ocolname, **pdstcols;
    int      count, status, srcindex;
    thdr_t  *thdr;
    int i;
    Tcl_Obj *oindex;
        
    /* Have to protect against shimmering between TABLE and the COLUMNLIST
       (this would be a caller bug but can cause a crash). In any case,
       since there is no reasonable call in practice where the table and 
       column list are the same, we simply don't allow the two to be
       the same rather than play games with duping objects */
    if (TABLE == COLUMNLIST) {
        Tcl_SetResult(interp, "Invalid column name list", TCL_STATIC);
        return TCL_ERROR;
    }

    if (table_convert(interp, TABLE) != TCL_OK)
        return TCL_ERROR;

    if ((status = Tcl_ListObjLength(interp, COLUMNLIST, &count)) != TCL_OK)
        return status;
    thdr = thdr_alloc(interp, TA_ANY, count);
    if (thdr == NULL)
        return TCL_ERROR;
    /* TBD - maybe we can use column_map_get_columns here ? */
    pdstcols = THDRELEMPTR(thdr, Tcl_Obj *, 0);
    ocolnames = Tcl_NewListObj(0, NULL);
    for (i = 0; i < count; ++i) {
        TA_NOFAIL(Tcl_ListObjIndex(interp, COLUMNLIST, i, &oindex), TCL_OK);
        TA_ASSERT(oindex);
        if (table_parse_column_index(interp, TABLE, oindex, &srcindex) != TCL_OK)
            break;
        if (table_column_index_to_name(interp, TABLE, srcindex, &ocolname) != TCL_OK)
            break;
        /* Everything seems in order. Store name->index mapping */
        Tcl_ListObjAppendElement(NULL, ocolnames, ocolname);
        Tcl_ListObjAppendElement(NULL, ocolnames, Tcl_NewIntObj(i));
        /* Store the column in the output */
        pdstcols[i] = table_column(TABLE, srcindex);
        Tcl_IncrRefCount(pdstcols[i]);
        thdr->used += 1;
    }
    if (i < count)
            status = TCL_ERROR; /* Early termination => error */
    else {
        /*
         * So far so good but tThere is one last thing to be checked - no
         * duplicate names. We do this by checking size of the column
         * names dictionary.
         */
        TA_NOFAIL(Tcl_DictObjSize(interp, ocolnames, &i), TCL_OK);
        status = i == count ? TCL_OK : ta_duplicate_columns_error(interp, COLUMNLIST);
    }

    if (status == TCL_ERROR) {
        thdr_decr_refs(thdr);
        Tcl_DecrRefCount(ocolnames);
    } else {
        Tcl_Obj *otab = table_new(thdr, ocolnames);
        TA_ASSERT(table_check(interp, otab));
        Tcl_SetObjResult(interp, otab);
    }
    return status;
}

# Helper to define integer commands that check overflow.
proc ta_define_integer_command {procname type typestr getfn op objfn} {
    
    set TEMPLATE {
        critcl::cproc tarray::%PROC% {Tcl_Interp* ip Tcl_Obj* oa Tcl_Obj* ob} ok {
            %TYPE%_t a, b, result;
            if (%GETFN%(ip, oa, &a) != TCL_OK || %GETFN%(ip, ob, &b) != TCL_OK)
                return TCL_ERROR;

            if (ovf_%OP%_%TYPE%(a, b, &result)) 
                return ta_integer_overflow_error(ip, "%TYPESTR%", 0);
            else {
                Tcl_SetObjResult(ip, %OBJFN%(result));
                return TCL_OK;
            }
        }
    }

    uplevel 1 [string map [list \
                               %PROC% $procname \
                               %TYPE% $type \
                               %TYPESTR% $typestr \
                               %GETFN%  $getfn \
                               %OP% $op \
                               %OBJFN% $objfn \
                              ] $TEMPLATE]
}

# TBD - document and test commands below
# Byte operations
ta_define_integer_command addu8 uint8 "unsigned 8-bit integer" ta_get_uint8_from_obj add Tcl_NewIntObj
ta_define_integer_command subu8 uint8 "unsigned 8-bit integer" ta_get_uint8_from_obj sub Tcl_NewIntObj
ta_define_integer_command mulu8 uint8 "unsigned 8-bit integer" ta_get_uint8_from_obj mul Tcl_NewIntObj

# 32-bit int operations
ta_define_integer_command add32 int32 "32-bit integer" ta_get_int_from_obj add Tcl_NewIntObj
ta_define_integer_command sub32 int32 "32-bit integer" ta_get_int_from_obj sub Tcl_NewIntObj
ta_define_integer_command mul32 int32 "32-bit integer" ta_get_int_from_obj mul Tcl_NewIntObj

# 32-bit unsigned operations
ta_define_integer_command addu32 uint32 "unsigned 32-bit integer" ta_get_uint_from_obj add Tcl_NewWideIntObj
ta_define_integer_command subu32 uint32 "unsigned 32-bit integer" ta_get_uint_from_obj sub Tcl_NewWideIntObj
ta_define_integer_command mulu32 uint32 "unsigned 32-bit integer" ta_get_uint_from_obj mul Tcl_NewWideIntObj

# 64-bit operations
ta_define_integer_command add64 int64 "64-bit integer" ta_get_wide_from_obj add Tcl_NewWideIntObj
ta_define_integer_command sub64 int64 "64-bit integer" ta_get_wide_from_obj sub Tcl_NewWideIntObj
ta_define_integer_command mul64 int64 "64-bit integer" ta_get_wide_from_obj mul Tcl_NewWideIntObj


critcl::cproc tarray::unsupported::compiler_info {Tcl_Interp* interp} ok {
    Tcl_Obj *objs[6];

    /* Return a keyed list */
    
    objs[0] = Tcl_NewStringObj("compiler", -1);
#if defined(_MSC_VER)
    objs[1] = Tcl_ObjPrintf("vc++ %u", _MSC_VER);
#elif defined(__GNUC__)
    objs[1] = Tcl_NewStringObj("gcc" __VERSION__, -1);
#else
    objs[1] = Tcl_NewStringObj("unknown", -1);
#endif

    objs[2] = Tcl_NewStringObj("opts", -1);

    objs[3] = Tcl_NewListObj(0, NULL);
#ifdef TA_MT_ENABLE
    Tcl_ListObjAppendElement(NULL, objs[3], Tcl_NewStringObj("mt_enabled", -1));
#endif
#if TA_ENABLE_ASSERT
    Tcl_ListObjAppendElement(NULL, objs[3], Tcl_NewStringObj("asserts_enabled", -1));
#endif

    /* Which Tcl did we build against ? (As opposed to run time) */
    objs[4] = Tcl_NewStringObj("tcl_headers", -1);
    objs[5] = Tcl_NewStringObj(TCL_PATCH_LEVEL, -1);

     Tcl_SetObjResult(interp, Tcl_NewListObj(6, objs));
     return TCL_OK;
}

critcl::cdata tarray::unsupported::critcl_info [critcl::showconfig]
# Commented out because will not work when building from TEA
#critcl::cdata tarray::unsupported::hg_id       [exec hg identify]

critcl::cproc tarray::unsupported::mt_split {Tcl_Interp* interp int tatype int first int count int min_hint int nsizes} ok {
#ifdef TA_MT_ENABLE
    int sizes[16];
    Tcl_Obj *ores;
    int i, split_count;
    if (nsizes > ARRAYSIZE(sizes)) {
        Tcl_SetResult(interp, "Invalid array size", TCL_STATIC);
        return TCL_ERROR;
    }
    split_count = thdr_calc_mt_split_ex(tatype, first, count, min_hint, nsizes, sizes);
    ores = Tcl_NewListObj(nsizes, NULL);
    for (i = 0; i < split_count; ++i)
        Tcl_ListObjAppendElement(interp, ores, Tcl_NewIntObj(sizes[i]));
    Tcl_SetObjResult(interp, ores);
    return TCL_OK;
#else
    Tcl_SetResult(interp, "Multithreading not enabled", TCL_STATIC);
    return TCL_ERROR;
#endif
}

critcl::class::define ::tarray::rng {
    include pcg_basic.h
    support {
        ta_value_t get_bounded_random(ta_rng_t *rng, ta_value_t *lbound, ta_value_t *ubound)
        {
            ta_value_t tav;
                
            TA_ASSERT(lbound->type == ubound->type);
            TA_ASSERT(lbound->type != TA_BOOLEAN); /* Does not support bounds */
            switch (lbound->type) {
            case TA_BYTE:
                tav.ucval = pcg32_boundedrand_r(&rng->rng[0],   
                                                ubound->ucval - lbound->ucval);
                tav.ucval += lbound->ucval;
                break;
            case TA_INT:
                tav.ival = pcg32_boundedrand_r(&rng->rng[0], 
                                               ubound->ival - lbound->ival);
                tav.ival += lbound->ival;
                break;
            case TA_UINT:
                tav.uival = pcg32_boundedrand_r(&rng->rng[0], 
                                                ubound->uival - lbound->uival);
                tav.uival += lbound->uival;
                break;
            case TA_WIDE:
                tav.wval = pcg32x2_boundedrand_r(rng->rng,
                                                 ubound->wval - lbound->wval);
                tav.wval += lbound->wval;
                break;
            case TA_DOUBLE:
                tav.dval = pcgdouble_boundedrand_r(rng->rng,
                                                   ubound->dval - lbound->dval);
                tav.dval += lbound->dval;
                break;
            default:
                ta_type_panic(lbound->type);
                break;
            }
            tav.type = lbound->type;
            return tav;
        }
    }
        
    insvariable ta_rng_t rng {} {
        instance->rng.nrefs = 1; /* Does not really matter */
    }
    insvariable {unsigned char} rtype
    insvariable {unsigned char} bounded {} { instance->bounded = 0; }
    insvariable ta_value_t lbound
    insvariable ta_value_t ubound
    constructor {
        if (objc < 1 || objc > 3) {
	    Tcl_AppendResult (interp, "wrong # args: should be \"rng\" new|create TYPE ?LOWBOUND ?HIGHBOUND??", NULL);
            goto error;
        }
        if (ta_parse_type(interp, objv[0], &instance->rtype) != TCL_OK)
            goto error;
        switch (instance->rtype) {
        case TA_BOOLEAN: case TA_BYTE: case TA_INT:
        case TA_UINT: case TA_WIDE: case TA_DOUBLE:
            break;
        default:
            ta_invalid_op_for_type(interp, instance->rtype);
            goto error;
        }
        tcol_random_init(&instance->rng);
        /* Note TA_BOOLEAN do not obey bounds */
        if (objc > 1 && instance->rtype != TA_BOOLEAN) {
            instance->bounded = 1;
            if (ta_value_from_obj(interp, objv[1], instance->rtype, &instance->lbound) != TCL_OK)
                goto error;
            if (objc > 2) {
                if (ta_value_from_obj(interp, objv[2], instance->rtype, &instance->ubound) != TCL_OK)
                    goto error;
            }
            if (ta_rng_fixup_bounds(interp,
                                    &instance->lbound, &instance->ubound,
                                    objc <= 2) != TCL_OK)
                goto error;
        } else if (instance->rtype == TA_BYTE) {
            instance->bounded = 1;
            instance->lbound.type = instance->ubound.type = TA_BYTE;
            instance->lbound.ucval = 0;
            instance->ubound.ucval = 255;
        }
    }
    method_introspection

    method seed proc {Tcl_Obj* SEED1 Tcl_Obj* SEED2} ok {
        Tcl_WideInt seed1;
        Tcl_WideInt seed2;
        TCL_RESULT res;
        if ((res = Tcl_GetWideIntFromObj(interp, SEED1, &seed1)) != TCL_OK ||
            (res = Tcl_GetWideIntFromObj(interp, SEED2, &seed2)) != TCL_OK)
            return res;
        pcg32_srandom_r(&instance->rng.rng[0], seed1, 0xf0f0f0f0);
        pcg32_srandom_r(&instance->rng.rng[1], seed2, 0x0f0f0f0f);
        return TCL_OK;
    }                                            

    method get command {?COUNT? ?LOWER UPPER?} {
        int count;
        int i, bounded;
        Tcl_Obj *ores;
        ta_value_t lbound, ubound;
        
        count = 1;
        bounded = instance->bounded;
        if (bounded) {
            lbound = instance->lbound;
            ubound = instance->ubound;
        }
        if (objc > 2) {
            if (Tcl_GetIntFromObj(interp, objv[2], &count) != TCL_OK)
                return TCL_ERROR;
            if (count < 0)
                return ta_negative_count_error(interp, count);
            if (objc > 3) {
                if (objc != 5)
                    return ta_invalid_argcount(interp);
                if (instance->rtype == TA_BOOLEAN) {
                    /* Booleans do not support bounds */
                    return ta_invalid_op_for_type(interp, instance->rtype);
                }
                if (ta_value_from_obj(interp, objv[3],
                                      instance->rtype, &lbound) != TCL_OK ||
                    ta_value_from_obj(interp, objv[4],
                                      instance->rtype, &ubound) != TCL_OK ||
                    ta_rng_fixup_bounds(interp, &lbound, &ubound, 0) != TCL_OK)
                    return TCL_ERROR;
                bounded = 1;
            }
        }

        if (count == 0)
            return TCL_OK;

        if (count > 1)
            ores = Tcl_NewListObj(count, NULL);
        if (bounded) {
            for (i = 0; i < count; ++i) {
                ta_value_t tav;
                tav = get_bounded_random(&instance->rng, &lbound, &ubound);
                if (count == 1) {
                    ores = ta_value_to_obj(&tav);
                    break;
                }
                Tcl_ListObjAppendElement(interp, ores, ta_value_to_obj(&tav));
            }
        } else {
            /* Unbounded */
            TA_ASSERT(instance->rtype != TA_BYTE);
            for (i = 0; i < count; ++i) {
                Tcl_Obj *o;
                switch (instance->rtype) {
                case TA_BOOLEAN:
                    o = Tcl_NewIntObj(pcgbool_random_r(&instance->rng.rng[0]));
                    break;
                case TA_INT:
                    o = Tcl_NewIntObj(pcg32_random_r(&instance->rng.rng[0]));
                    break;
                case TA_UINT:
                    o = Tcl_NewWideIntObj(pcg32_random_r(&instance->rng.rng[0]));
                    break;
                case TA_WIDE:
                    o = Tcl_NewWideIntObj(pcg32x2_random_r(instance->rng.rng));
                    break;
                case TA_DOUBLE:
                    o = Tcl_NewDoubleObj(pcgdouble_random_r(instance->rng.rng));
                    break;
                default:
                    ta_type_panic(instance->rtype);
                    break;
                }
                if (count == 1) {
                    ores = o;
                    break;
                }
                Tcl_ListObjAppendElement(interp, ores, o);
            }
        }
        Tcl_SetObjResult(interp, ores);
        return TCL_OK;
    }

    method bounded proc {Tcl_Obj* olower Tcl_Obj* oupper} ok {
        ta_value_t lbound, ubound;
        ta_value_t tav;
        if (instance->rtype == TA_BOOLEAN) {
            /* Booleans do not support bounds */
            return ta_invalid_op_for_type(interp, instance->rtype);
        }
        if (ta_value_from_obj(interp, olower,
                              instance->rtype,&lbound) != TCL_OK ||
            ta_value_from_obj(interp, oupper,
                              instance->rtype,&ubound) != TCL_OK ||
            ta_rng_fixup_bounds(interp, &lbound, &ubound, 0) != TCL_OK)
            return TCL_ERROR;
        tav = get_bounded_random(&instance->rng, &lbound, &ubound);
        Tcl_SetObjResult(interp, ta_value_to_obj(&tav));
        return TCL_OK;
    }
}

critcl::ccommand tarray::rbc::init_stubs ta_rbc_init_stubs_cmd 
critcl::ccommand tarray::parseargs parseargs_cmd

package provide tarray [source [file join [file dirname [info script]] taversion.tcl]]

critcl::load

#
# Local Variables:
#  compile-command: "envset x64 && tclsh build.tcl extension -config ../src/tarray.cfg -keep -target win32-dev64"
# End:
