#
# Copyright (c) 2012-2015, Ashok P. Nadkarni
# All rights reserved.
#
# See the file LICENSE for license
#

proc win32_target {} {
    switch -glob -- [critcl::targetconfig] {
        win32-* -
        mingw* { return 1 }
        default { return 0 }
    }
}

################################################################
# Set up configuration options for the package

array set build_opts {}

# Multithreaded sort defaults to 0 on non-Win32 because it requires dispatch.dll
set build_opts(mt_enable) [win32_target]

# Normally we use libdispatch only on non-Win32 and only if mt_enable is set
# Override this in Win32 if you want explicitly use libdispatch even on Win32.
# 
set build_opts(use_libdispatch) 0
if {$build_opts(mt_enable) && ![win32_target]} {
    set build_opts(use_libdispatch) 1
}

# Enable compiling of unsupported functions
set build_opts(unsupported) 1

################################################################
# Standard critcl meta information

package require critcl 3.1

critcl::license "Ashok P. Nadkarni"
critcl::summary "Tcl Typed Array Extension"
critcl::description {
    Implements the tarray::column and tarray::table commands providing 
    accessed to typed array values. This extension is targeted towards
    Tcl applications dealing with a large number of data items.
}

critcl::clean_cache
critcl::tcl 8.5

################################################################
# Compiler/platform specific flags
if {[string match "*-gcc" [critcl::targetconfig]] ||
    [string match "linux-*-\\*" [critcl::targetconfig]] ||
    [string match  "mingw*" [critcl::targetconfig]]} {
    # Flags required for gcc
    critcl::cflags -std=gnu99 -Winline
}

if {[win32_target]} {
   # Need XP at least
   critcl::cflags -D_WIN32_WINNT=0x0500
}

critcl::csources bitarray.c errors.c table.c tafold.c tamath.c tarray.c tasearch.c tasort.c tastring.c timsort.c timsort_r.c

if {$build_opts(unsupported)} {
    critcl::csources unsupported.c
    critcl::ccommand tarray::unsupported::dump ta_dump_cmd

}
critcl::tsources tarray.tcl taprint.tcl
critcl::cheaders tarray.h timsort-impl.h

critcl::ccode {
#include "tarray.h"
}

if {$build_opts(mt_enable)} {

    if {! $build_opts(use_libdispatch)} {
        critcl::csources mt.c
    }

    critcl::cflags -DTA_MT_ENABLE

}

critcl::ccommand tarray::unsupported::config {} {
    const char *vname;
    int *pval;	 
    if (objc < 2 || objc > 3) {
        Tcl_WrongNumArgs(interp, 1, objv, "CONFIGVAR ?VALUE?");
        return TCL_ERROR;
    }

    vname = Tcl_GetString(objv[1]);
    if (ta_strequal(vname, "experiment"))
        pval = &ta_experiment;
    else if (ta_strequal(vname, "full_validation"))
        pval = &ta_full_validation;
#ifdef TA_MT_ENABLE
    else if (ta_strequal(vname, "sort_mt_threshold"))
        pval = &ta_sort_mt_threshold;
    else if (ta_strequal(vname, "sort_mt_enable_any"))
        pval = &ta_sort_mt_enable_any;
    else if (ta_strequal(vname, "search_mt_threshold"))
        pval = &ta_search_mt_threshold;
    else if (ta_strequal(vname, "fill_mt_threshold"))
        pval = &ta_fill_mt_threshold;
    else if (ta_strequal(vname, "minmax_mt_threshold"))
        pval = &ta_minmax_mt_threshold;
    else if (ta_strequal(vname, "fold_mt_threshold"))
        pval = &ta_fold_mt_threshold;
    else if (ta_strequal(vname, "math_mt_threshold"))
        pval = &ta_math_mt_threshold;
#endif
    else {
        Tcl_SetResult(interp, "Invalid config setting name.", TCL_STATIC);
        return TCL_ERROR;
    }

    if (objc == 3) {
        if (Tcl_GetIntFromObj(interp, objv[2], pval) != TCL_OK)
        return TCL_ERROR;
    }
    Tcl_SetObjResult(interp, Tcl_NewIntObj(*pval));
    return TCL_OK;
}


if {$build_opts(use_libdispatch)} {
    critcl::clibraries -ldispatch
    critcl::cflags -DTA_USE_LIBDISPATCH
}


################################################################
# Type conversions

critcl::argtype TColObjPtr {
    if (tcol_convert(interp, @@) != TCL_OK)
        return TCL_ERROR;
    @A = @@;
}

critcl::argtype TableObjPtr {
    if (table_convert(interp, @@) != TCL_OK)
        return TCL_ERROR;
    @A = @@;
}

################################################################
# Common functions

critcl::ccode {
    typedef Tcl_Obj *TColObjPtr;
    typedef Tcl_Obj *TableObjPtr;

    /*
     * If status is success, sets ip result to ores. Always returns status.
     * ores might be deallocated unless caller makes sure it is holding a 
     * ref count. Primary purpose of this trivial routine is to deal
     * with returning an object that might have been either allocated
     * or be an existing object passed in the objv[] array to a command.
     */
    TA_INLINE TCL_RESULT ta_return_result(Tcl_Interp *ip, TCL_RESULT status, Tcl_Obj *ores)
    {
        Tcl_IncrRefCount(ores);
        if (status == TCL_OK)
            Tcl_SetObjResult(ip, ores);
        Tcl_DecrRefCount(ores);
        return status;
    }

    /*
     * Sets the value of the variable given by ovarname to ovalue and sets the
     * the interp result to the resulting value of the variable (which may be
     * different from ovalue because of traces).
     * 
     * IMPORTANT: Caller should NOT access ovalue again unless it has protected
     * it by bumping its ref count.
     */
    TCL_RESULT ta_set_var_result(Tcl_Interp *ip, TCL_RESULT status, Tcl_Obj *ovarname, Tcl_Obj *ovalue)
    {
        Tcl_Obj *oresult;
        Tcl_IncrRefCount(ovalue);
        if (status == TCL_OK) {
            oresult = Tcl_ObjSetVar2(ip, ovarname, NULL, ovalue, TCL_LEAVE_ERR_MSG);
            if (oresult)
                Tcl_SetObjResult(ip, oresult);
            else
                status = TCL_ERROR;
        }
        Tcl_DecrRefCount(ovalue);

        return status;
    }

}

################################################################
# Initialization

critcl::cinit {
    TA_ASSERT(ba_sanity_check() == 0);
    g_tcl_list_type_ptr = Tcl_GetObjType("list");
    g_tcl_string_type_ptr = Tcl_GetObjType("string");
} {
}

################################################################
# General commands

critcl::ccommand tarray::types {} {
    /* TBD - tests for the types command */
    int i;
    Tcl_Obj *o;
    Tcl_Obj *res;

    if (objc < 2) {
	Tcl_WrongNumArgs(interp, 1, objv, "?VALUE...?");
	return TCL_ERROR;
    }

    res = Tcl_NewListObj(objc-1, NULL);
    for (i = 1; i < objc; ++i) {
        o = objv[i];

	    /* Try to convert to a tarray type but only if the type pointer is
	     * a list, string or NULL. We don't want to disturb other types
             */
        if (o->typePtr == NULL ||
            o->typePtr == g_tcl_string_type_ptr ||
            o->typePtr == g_tcl_list_type_ptr) {
            if (table_convert(NULL, o) != TCL_OK)
                tcol_convert(NULL, o);
        }

        if (table_affirm(o)) {
            Tcl_ListObjAppendElement(interp, res, Tcl_NewStringObj("table", sizeof("table")-1));
        } else if (tcol_affirm(o)) {
            Tcl_ListObjAppendElement(interp, res,
                             Tcl_NewStringObj(ta_type_string(tcol_type(o)), -1));
        } else {
            Tcl_ListObjAppendElement(interp, res, Tcl_NewObj());
        }
    }
    Tcl_SetObjResult(interp, res);
    return TCL_OK;
}


################################################################
# Column commands
critcl::ccommand tarray::column::create {} {
    int init_size;
    int tatype;
    Tcl_Obj **elems;
    int nelems;
    thdr_t *thdrP;
    Tcl_Obj *o;

    if (objc < 2 || objc > 4) {
        Tcl_WrongNumArgs(interp, 1, objv, "TYPE ?INITVAL? ?INITSIZE?");
        return TCL_ERROR;
    }

    if (Tcl_GetIndexFromObj(interp, objv[1], g_type_tokens, "TArrayType",
                            TCL_EXACT, &tatype) != TCL_OK) {
	return TCL_ERROR;
    }

    init_size = 0;
    nelems = 0;
    elems = NULL;
    if (objc > 2) {
        if (Tcl_ListObjGetElements(interp, objv[2], &nelems, &elems) != TCL_OK)
            return TCL_ERROR;
        if (objc > 3) {
            if (Tcl_GetIntFromObj(interp, objv[3], &init_size) != TCL_OK)
                return TCL_ERROR;
        }
    }

    thdrP = thdr_alloc_and_init(interp, tatype, nelems, elems, init_size);
    if (thdrP == NULL)
        return TCL_ERROR;

    o = tcol_new(thdrP);

    TA_ASSERT(tcol_check(interp, o));
    Tcl_SetObjResult(interp, o);
    return TCL_OK;
}

critcl::ccommand tarray::column::delete {} {
    Tcl_Obj *tcol;
    int status;

    if (objc != 3 && objc != 4) {
	Tcl_WrongNumArgs(interp, 1, objv, "TARRAY (INDEXLIST | LOW ?HIGH?)");
	return TCL_ERROR;
    }
    
    tcol = objv[1];
    if (Tcl_IsShared(tcol))
        tcol = Tcl_DuplicateObj(objv[1]);

    status = tcol_delete(interp, tcol, objv[2], objc == 4 ? objv[3] : NULL);
    TA_ASSERT(status != TCL_OK || tcol_check(interp, tcol));
    return ta_return_result(interp, status, tcol);
}

critcl::ccommand tarray::column::vdelete {} {
    Tcl_Obj *tcol;
    int status;

    if (objc != 3 && objc != 4) {
	Tcl_WrongNumArgs(interp, 1, objv, "TARRAYVAR (INDEXLIST | LOW ?HIGH?)");
	return TCL_ERROR;
    }
    
    tcol = Tcl_ObjGetVar2(interp, objv[1], NULL, TCL_LEAVE_ERR_MSG);
    if (tcol == NULL)
        return TCL_ERROR;
    if (Tcl_IsShared(tcol))
        tcol = Tcl_DuplicateObj(tcol);

    status = tcol_delete(interp, tcol, objv[2], objc == 4 ? objv[3] : NULL);
    TA_ASSERT(status != TCL_OK || tcol_check(interp, tcol));
    return ta_set_var_result(interp, status, objv[1], tcol);
}

critcl::cproc tarray::column::size {TColObjPtr tcol} int {
    return tcol_occupancy(tcol);
}

critcl::cproc tarray::column::type {TColObjPtr tcol} "const char*" {
    return ta_type_string(tcol_type(tcol));
}

critcl::cproc tarray::column::cast {Tcl_Interp* interp TColObjPtr COLUMN Tcl_Obj* COLTYPE} ok {
    int tatype;
    thdr_t *thdr, *thdr2;
    Tcl_Obj *o;

    if (Tcl_GetIndexFromObj(interp, COLTYPE, g_type_tokens, "TArrayType",
                            TCL_EXACT, &tatype) != TCL_OK)
	return TCL_ERROR;

    if (tcol_type(COLUMN) == tatype) {
        Tcl_SetObjResult(interp, COLUMN);
        return TCL_OK;
    }

    if (Tcl_IsShared(COLUMN))
        COLUMN = Tcl_DuplicateObj(COLUMN);

    /* Special case - if signed/unsigned issue AND unshared just flip the
       thdr header */
    thdr = tcol_thdr(COLUMN);
    if (thdr->nrefs == 1) {
        if (thdr->type == TA_INT && tatype == TA_UINT ||
            thdr->type == TA_UINT && tatype == TA_INT) {
            thdr->type = tatype;
            thdr->sort_order = THDR_UNSORTED;
            Tcl_SetObjResult(interp, COLUMN);
            return TCL_OK;
        }
    }

    thdr2 = thdr_alloc(interp, tatype, thdr->used);
    if (thdr2 == NULL)
        return TCL_ERROR;
    if (thdr_copy_cast(interp, thdr2, 0, thdr, 0, thdr->used, 0) != TCL_OK) {
        thdr_decr_refs(thdr2);
        return TCL_ERROR;
    }
    o = tcol_new(thdr2);
    TA_ASSERT(tcol_check(interp, o));
    Tcl_SetObjResult(interp, o);
    return TCL_OK;
}

critcl::cproc tarray::column::index {Tcl_Interp* interp TColObjPtr COLUMN Tcl_Obj* INDEX} ok {
    int ix;
    Tcl_Obj *o;
    if (ta_convert_index(interp, INDEX, &ix, tcol_occupancy(COLUMN)-1, 0, tcol_occupancy(COLUMN)-1) != TCL_OK)
        return TCL_ERROR;
    
    o = tcol_index(interp, COLUMN, ix);
    if (o) {
        Tcl_SetObjResult(interp, o);
        return TCL_OK;
    } else
        return TCL_ERROR;
}

critcl::ccommand tarray::column::get {} {
    return tcol_retrieve(interp, objc, objv, TA_RETRIEVE_GET);
}

critcl::ccommand tarray::column::range {} {
    return tcol_retrieve(interp, objc, objv, TA_RETRIEVE_RANGE);
}

critcl::ccommand tarray::column::sort {} {
    int flags, status;
    Tcl_Obj *tcol;
    Tcl_Obj *otarget = NULL;

    if (objc < 2) {
	Tcl_WrongNumArgs(interp, 1, objv, "?options? tarray");
	return TCL_ERROR;
    }

    if ((status = tcol_parse_sort_options(interp, objc, objv, &flags, &otarget)) != TCL_OK)
        return status;

    tcol = objv[objc-1];
    if (Tcl_IsShared(tcol))
        tcol = Tcl_DuplicateObj(tcol);

    if (flags & TA_SORT_INDIRECT) {
        TA_ASSERT(otarget != NULL);
        status = tcol_sort_indirect(interp, tcol, otarget, flags);
    } else
        status = tcol_sort(interp, tcol, flags);

    TA_ASSERT(status != TCL_OK || tcol_check(interp, tcol));
    return ta_return_result(interp, status, tcol);
}

critcl::ccommand tarray::column::vsort {} {
    Tcl_Obj *tcol;
    int status;
    int flags;
    Tcl_Obj *otarget = NULL;

    if (objc < 2) {
    	Tcl_WrongNumArgs(interp, 1, objv, "?options? COLUMNVAR");
        return TCL_ERROR;
    }

    if ((status = tcol_parse_sort_options(interp, objc, objv, &flags, &otarget)) != TCL_OK)
        return status;

    if (flags & TA_SORT_INDICES) {
        Tcl_SetResult(interp, "Invalid option -indices", TCL_STATIC);
        return TCL_ERROR;
    }

    tcol = Tcl_ObjGetVar2(interp, objv[objc-1], NULL, TCL_LEAVE_ERR_MSG);
    if (tcol == NULL)
        return TCL_ERROR;
    if (Tcl_IsShared(tcol))
        tcol = Tcl_DuplicateObj(tcol);

    if (flags & TA_SORT_INDIRECT) {
        TA_ASSERT(otarget != NULL);
        status = tcol_sort_indirect(interp, tcol, otarget, flags);
    } else {
        status = tcol_sort(interp, tcol, flags);
    }

    TA_ASSERT(status != TCL_OK || tcol_check(interp, tcol));
    return ta_set_var_result(interp, status, objv[objc-1], tcol);
}

critcl::cproc tarray::column::bitsset {Tcl_Interp* interp TColObjPtr tcol} ok {
    thdr_t *thdrP = tcol_thdr(tcol);
    if (thdrP->type != TA_BOOLEAN) {
        Tcl_SetResult(interp, "tarray type is not boolean", TCL_STATIC);
        return TCL_ERROR;
    }
        
    Tcl_SetObjResult(
        interp,
        Tcl_NewIntObj(ba_count_ones(THDRELEMPTR(thdrP, ba_t, 0), 0, thdrP->used)));
    return TCL_OK;
}

critcl::ccommand tarray::column::search tcol_search_cmd

critcl::ccommand tarray::column::lookup tcol_lookup_cmd

critcl::ccommand tarray::column::minmax tcol_minmax_cmd

critcl::ccommand tarray::column::math tcol_math_cmd

critcl::ccommand tarray::column::fold tcol_fold_cmd

critcl::ccommand tarray::column::insert {} {
    Tcl_Obj *tcol;
    int status;

    if (objc != 4 && objc != 5) {
    	Tcl_WrongNumArgs(interp, 1, objv, "COLUMN (VALUES POSITION | VALUE POSITION COUNT)");
	return TCL_ERROR;
    }
    
    tcol = objv[1];
    if (Tcl_IsShared(tcol))
        tcol = Tcl_DuplicateObj(tcol);
    status = tcol_insert_obj(interp, tcol, objv[2], objv[3], objc == 4 ? NULL : objv[4]);
    TA_ASSERT(status != TCL_OK || tcol_check(interp, tcol));
    return ta_return_result(interp, status, tcol);
}

critcl::ccommand tarray::column::vinsert {} {
    Tcl_Obj *tcol;
    int status;

    if (objc != 4 && objc != 5) {
    	Tcl_WrongNumArgs(interp, 1, objv, "COLUMNVAR (VALUES POSITION | VALUE POSITION COUNT)");
	return TCL_ERROR;
    }
    
    tcol = Tcl_ObjGetVar2(interp, objv[1], NULL, TCL_LEAVE_ERR_MSG);
    if (tcol == NULL)
        return TCL_ERROR;
    if (Tcl_IsShared(tcol))
        tcol = Tcl_DuplicateObj(tcol);
    status = tcol_insert_obj(interp, tcol, objv[2], objv[3], objc == 4 ? NULL : objv[4]);
    TA_ASSERT(status != TCL_OK || tcol_check(interp, tcol));
    return ta_set_var_result(interp, status, objv[1], tcol);
}

critcl::cproc tarray::column::put {Tcl_Interp* interp Tcl_Obj* COLUMN Tcl_Obj* VALUES Tcl_Obj* {FIRST 0}} ok {
    Tcl_Obj *tcol;
    int status;

    tcol = COLUMN;
    if (Tcl_IsShared(tcol))
        tcol = Tcl_DuplicateObj(tcol);

    /* Values may be given as a list or a tarray */
    if (tcol_convert(NULL, VALUES) == TCL_OK) {
        /* It is a tarray. Verify the right type */
        status = tcol_copy_thdr(interp, tcol, tcol_thdr(VALUES), FIRST, 0);
    } else {
        status = tcol_put_objs(interp, tcol, VALUES, FIRST, 0);
    }

    TA_ASSERT(status != TCL_OK || tcol_check(interp, tcol));
    return ta_return_result(interp, status, tcol);
}

critcl::cproc tarray::column::vput {Tcl_Interp* interp Tcl_Obj* COLUMNVAR Tcl_Obj* VALUES Tcl_Obj* {FIRST 0}} ok {
    Tcl_Obj *tcol;
    int status;

    tcol = Tcl_ObjGetVar2(interp, COLUMNVAR, NULL, TCL_LEAVE_ERR_MSG);
    if (tcol == NULL)
        return TCL_ERROR;
    if (Tcl_IsShared(tcol))
        tcol = Tcl_DuplicateObj(tcol);

    /* Values may be given as a list or a tarray */
    if (tcol_convert(NULL, VALUES) == TCL_OK) {
        /* It is a tarray */
        status = tcol_copy_thdr(interp, tcol, tcol_thdr(VALUES), FIRST, 0);
    } else {
        status = tcol_put_objs(interp, tcol, VALUES, FIRST, 0);
    }
    TA_ASSERT(status != TCL_OK || tcol_check(interp, tcol));
    return ta_set_var_result(interp, status, COLUMNVAR, tcol);
}

critcl::cproc tarray::column::place {Tcl_Interp* interp Tcl_Obj* COLUMN Tcl_Obj* VALUES Tcl_Obj* INDICES} ok {
    int status;

    if (Tcl_IsShared(COLUMN))
        COLUMN = Tcl_DuplicateObj(COLUMN);

    if (tcol_convert(NULL, VALUES) == TCL_OK)
        status = tcol_place_indices(interp, COLUMN, VALUES, INDICES);
    else
        status = tcol_place_objs(interp, COLUMN, VALUES, INDICES);
    TA_ASSERT(status != TCL_OK || tcol_check(interp, COLUMN));
    return ta_return_result(interp, status, COLUMN);
}

critcl::cproc tarray::column::vplace {Tcl_Interp* interp Tcl_Obj* COLUMNVAR Tcl_Obj* VALUES Tcl_Obj* INDICES} ok {
    Tcl_Obj *tcol;
    int status;

    tcol = Tcl_ObjGetVar2(interp, COLUMNVAR, NULL, TCL_LEAVE_ERR_MSG);
    if (tcol == NULL)
        return TCL_ERROR;
    if (Tcl_IsShared(tcol))
        tcol = Tcl_DuplicateObj(tcol);
    
    if (tcol_convert(NULL, VALUES) == TCL_OK)
        status = tcol_place_indices(interp, tcol, VALUES, INDICES);
    else
        status = tcol_place_objs(interp, tcol, VALUES, INDICES);

    TA_ASSERT(status != TCL_OK || tcol_check(interp, tcol));
    return ta_set_var_result(interp, status, COLUMNVAR, tcol);
}

critcl::ccommand tarray::column::fill {} {
    Tcl_Obj *tcol;
    int status;

    if (objc != 4 && objc != 5) {
	Tcl_WrongNumArgs(interp, 1, objv, "COLUMN VALUE (INDEXLIST | LOW ?HIGH?)");
	return TCL_ERROR;
    }

    tcol = objv[1];
    if (Tcl_IsShared(tcol))
        tcol = Tcl_DuplicateObj(tcol);

    status = tcol_fill_obj(interp, tcol, objv[2], objv[3],
                               objc == 5 ? objv[4] : NULL);
    TA_ASSERT(status != TCL_OK || tcol_check(interp, tcol));
    return ta_return_result(interp, status, tcol);
}

critcl::ccommand tarray::column::vfill {} {
    Tcl_Obj *tcol;
    int status;

    if (objc != 4 && objc != 5) {
	Tcl_WrongNumArgs(interp, 1, objv, "TCOLUMNVAR VALUE (INDEXLIST | LOW ?HIGH?)");
	return TCL_ERROR;
    }
    
    tcol = Tcl_ObjGetVar2(interp, objv[1], NULL, TCL_LEAVE_ERR_MSG);
    if (tcol == NULL)
        return TCL_ERROR;
    if (Tcl_IsShared(tcol))
        tcol = Tcl_DuplicateObj(tcol);

    status = tcol_fill_obj(interp, tcol, objv[2], objv[3], objc == 5 ? objv[4] : NULL);
    TA_ASSERT(status != TCL_OK || tcol_check(interp, tcol));
    return ta_set_var_result(interp, status, objv[1], tcol);
}

critcl::cproc tarray::column::reverse {Tcl_Interp* interp Tcl_Obj* tcol} ok {
    TCL_RESULT status;
    if (Tcl_IsShared(tcol))
        tcol = Tcl_DuplicateObj(tcol);
    status = tcol_reverse(interp, tcol);
    TA_ASSERT(status != TCL_OK || tcol_check(interp, tcol));
    return ta_return_result(interp, status, tcol);
}
    
critcl::cproc tarray::column::vreverse {Tcl_Interp* interp Tcl_Obj* ovar} ok {
    Tcl_Obj *tcol;
    TCL_RESULT status;
    tcol = Tcl_ObjGetVar2(interp, ovar, NULL, TCL_LEAVE_ERR_MSG);
    if (tcol == NULL)
        return TCL_ERROR;
    if (Tcl_IsShared(tcol))
        tcol = Tcl_DuplicateObj(tcol);

    status = tcol_reverse(interp, tcol);
    TA_ASSERT(status != TCL_OK || tcol_check(interp, tcol));
    return ta_set_var_result(interp, status, ovar, tcol);
}

critcl::ccommand tarray::column::intersect3 {} {
    Tcl_Obj *acol, *bcol;
    thdr_t *athdr, *bthdr;
    thdr_t *aintersectb=NULL, *aminusb=NULL, *bminusa=NULL;
    int atype;
    unsigned char order, a_current_order, b_current_order;
    int free_acol = 0, free_bcol = 0;
    TCL_RESULT status = TCL_ERROR;
    int sort_flags, nmin, nocase = 0;
    Tcl_Obj *results[3];

    if (objc != 3 && objc != 4) {
	Tcl_WrongNumArgs(interp, 1, objv, "?-nocase? COLUMNA COLUMNB");
	return TCL_ERROR;
    }

    if (objc == 4) {
        if (! ta_strequal(Tcl_GetString(objv[1]), "-nocase"))
            return ta_invalid_opt_error(interp, "-nocase");
        nocase = 1;
    }

    acol = objv[objc-2];
    bcol = objv[objc-1];

    if ((status = tcol_convert(interp, acol)) != TCL_OK ||
        (status = tcol_convert(interp, bcol)) != TCL_OK)
        return status;

    athdr = tcol_thdr(acol);
    atype = athdr->type;
    bthdr = tcol_thdr(bcol);

    if (athdr == bthdr) {
        /* TBD - also special case when either column is zero size */
        /* Optimize same object. Dunno how common this might be but ... */
        results[0] = acol;
        aminusb = thdr_alloc(interp, atype, 0);
        if (aminusb == NULL)
            goto vamoose;
        results[1] = tcol_new(aminusb);
        results[2] = results[1];
        Tcl_SetObjResult(interp, Tcl_NewListObj(3, results));
        return TCL_OK;
    }

    if (atype != bthdr->type)
        return ta_mismatched_types_error(interp, atype, bthdr->type);

    a_current_order = athdr->sort_order;
    b_current_order = bthdr->sort_order;

    /* Ensure both columns are in same sort order */
    order = THDR_UNSORTED;
    if (atype == TA_ANY || atype == TA_STRING) {
        /* TA_ANY/TA_STRING separated because we have to deal with nocase */
        if (a_current_order == b_current_order) {
            /* If unsorted or sorted with different case-sensitivity, resort */
            if ((nocase && SORT_ORDER_IS_NOCASE(a_current_order)) ||
                (!nocase && SORT_ORDER_IS_CASE(a_current_order))) {
                /* Both sorted appropriately. Lucky us, nought to do */
                order = a_current_order;
            } else {
                /* Either unsorted or wrong case sensitivity. We have to
                   sort/resort but try to make it as close to current
                   order for efficiency
                */
                if (SORT_ORDER_IS_DESCENDING(a_current_order))
                    order = nocase ? THDR_SORTED_DESCENDING_NOCASE : THDR_SORTED_DESCENDING;
                else
                    order = nocase ? THDR_SORTED_ASCENDING_NOCASE : THDR_SORTED_ASCENDING;
            }
        } else {
            /* Sort state is different for a and b */
            if ((nocase && SORT_ORDER_IS_NOCASE(a_current_order)) ||
                (!nocase && SORT_ORDER_IS_CASE(a_current_order))) {
                /* a is sorted appropriately. */
                if ((nocase && SORT_ORDER_IS_NOCASE(b_current_order)) ||
                    (!nocase && SORT_ORDER_IS_CASE(b_current_order))) {
                    /* b is also sorted appropriately but different from a, choose to sort smaller one.*/
                    order = athdr->used < bthdr->used ? b_current_order : a_current_order;
                } else
                    order = a_current_order; /* Only b needs sorting */
            } else {
                /* a is not sorted appropriately. */
                if ((nocase && SORT_ORDER_IS_NOCASE(b_current_order)) ||
                    (!nocase && SORT_ORDER_IS_CASE(b_current_order))) {
                    /* But b is so use its order */
                    order = b_current_order; /* sort a as b */
                } else {
                    /* Neither is sorted appropriately. Both will have to
                       be sorted. Still try to optimize by picking
                       something closer to the bigger column.
                    */
                    if (athdr->used >= bthdr->used) {
                        if (SORT_ORDER_IS_DESCENDING(a_current_order))
                            order = nocase ? THDR_SORTED_DESCENDING_NOCASE : THDR_SORTED_DESCENDING;
                        else if (SORT_ORDER_IS_ASCENDING(a_current_order))
                            order = nocase ? THDR_SORTED_ASCENDING_NOCASE : THDR_SORTED_ASCENDING;
                    }  
                    if (order == 0) {
                        if (SORT_ORDER_IS_DESCENDING(b_current_order))
                            order = nocase ? THDR_SORTED_DESCENDING_NOCASE : THDR_SORTED_DESCENDING;
                        else
                            order = nocase ? THDR_SORTED_ASCENDING_NOCASE : THDR_SORTED_ASCENDING;
                    }
                }
            }
        }
    } else if (atype != TA_BOOLEAN) {
        if (a_current_order == b_current_order) {
            if (a_current_order == THDR_UNSORTED)
                order = THDR_SORTED_ASCENDING;/* Both need sorting */
            else
                order = a_current_order;
        }
        else {
            /* a and b not sorted the same */
            if (a_current_order == THDR_UNSORTED)
                order = b_current_order; /* Sort a same as b */
            else if (bthdr->sort_order == THDR_UNSORTED)
                order = a_current_order; /* Sort b same as a */
            else {
                /* Both are sorted but not in same order. Resort the smaller */
                if (athdr->used < bthdr->used)
                    order = b_current_order;
                else
                    order = a_current_order;
            }
        }
    }
    
    if (atype != TA_BOOLEAN) {
        switch (order) {
        case THDR_SORTED_ASCENDING:         sort_flags = 0; break;
        case THDR_SORTED_DESCENDING:        sort_flags = TA_SORT_DECREASING; break;
        case THDR_SORTED_ASCENDING_NOCASE:  sort_flags = TA_SORT_NOCASE; break;
        case THDR_SORTED_DESCENDING_NOCASE: sort_flags = TA_SORT_NOCASE | TA_SORT_DECREASING; break;
        default:
            Tcl_Panic("Unexpected sort order %d in function intersect", order);
        }
                                                                        
        if (a_current_order != order) {
            /* a needs to be sorted. Needs to be unshared to do so */
            if (Tcl_IsShared(acol)) {
                acol = Tcl_DuplicateObj(acol);
                free_acol = 1;
            }
            if (tcol_sort(interp, acol, sort_flags) != TCL_OK)
                goto vamoose;
            athdr = tcol_thdr(acol);
        }

        if (b_current_order != order) {
            /* b needs to be sorted. Needs to be unshared to do so */
            if (Tcl_IsShared(bcol)) {
                bcol = Tcl_DuplicateObj(bcol);
                free_bcol = 1;
            }
            if (tcol_sort(interp, bcol, sort_flags) != TCL_OK)
                goto vamoose;
            bthdr = tcol_thdr(bcol);
        }
    }

    /*
     * Create 3 arrays to hold the a intersect b, a-b, b-a.
     * Max num elems in intersect is smaller of two arrays.
     * Max num in a-b and b-a is num in a and b respectively.
     */
    nmin = athdr->used;
    if (nmin > bthdr->used)
        nmin = bthdr->used;

    aintersectb = thdr_alloc(interp, atype, nmin);
    aminusb = thdr_alloc(interp, atype, athdr->used);
    bminusa = thdr_alloc(interp, atype, bthdr->used);
    if (aintersectb == NULL || aminusb == NULL || bminusa == NULL)
        goto vamoose;

    /* IMPORTANT - INTERSECT must NOT error out else ref counts for
       type TA_ANY will be broken as they are updated later */
#define EQ(x_, y_) ((x_) == (y_))
#define LT(x_, y_) ((x_) < (y_))
#define INTERSECT(t_)                                                   \
    do {                                                                \
        t_ *pintersect = THDRELEMPTR(aintersectb, t_, 0);               \
        t_ *paminusb = THDRELEMPTR(aminusb, t_, 0);                     \
        t_ *pbminusa = THDRELEMPTR(bminusa, t_, 0);                     \
        t_ *a = THDRELEMPTR(athdr, t_, 0);                              \
        t_ *b = THDRELEMPTR(bthdr, t_, 0);                              \
        t_ *aend = a + athdr->used;                                     \
        t_ *bend = b + bthdr->used;                                     \
                                                                        \
        if (SORT_ORDER_IS_ASCENDING(order)) {                           \
            while (a < aend && b < bend) {                              \
                if (EQ(*a, *b)) {                                       \
                    *pintersect++ = *a;                                 \
                    ++a;                                                \
                    ++b;                                                \
                } else if (LT(*a, *b)) {                                \
                    *paminusb++ = *a++;                                 \
                } else {                                                \
                    *pbminusa++ = *b++;                                 \
                }                                                       \
            }                                                           \
        } else {                                                        \
            /* Sorted in descending order */                            \
            while (a < aend && b < bend) {                              \
                if (EQ(*a, *b)) {                                       \
                    *pintersect++ = *a;                                 \
                    ++a;                                                \
                    ++b;                                                \
                } else if (LT(*a, *b)) {                                \
                    *pbminusa++ = *b++;                                 \
                } else {                                                \
                    *paminusb++ = *a++;                                 \
                }                                                       \
            }                                                           \
        }                                                               \
                                                                        \
        /* Now copy left over elements */                               \
        while (a < aend) {                                              \
            *paminusb++ = *a++;                                         \
        }                                                               \
        while (b < bend) {                                              \
            *pbminusa++ = *b++;                                         \
        }                                                               \
                                                                        \
        aintersectb->used = pintersect - THDRELEMPTR(aintersectb, t_, 0); \
        aminusb->used = paminusb - THDRELEMPTR(aminusb, t_, 0);         \
        bminusa->used = pbminusa - THDRELEMPTR(bminusa, t_, 0);         \
    } while (0)

    switch (atype) {
    case TA_BOOLEAN:
       {
           int ones_in_a, ones_in_b, zeroes_in_a, zeroes_in_b;
           int ones, zeroes;
           ba_t *pbits;
           ones_in_a = ba_count_ones(THDRELEMPTR(athdr, ba_t, 0), 0, athdr->used);
           ones_in_b = ba_count_ones(THDRELEMPTR(bthdr, ba_t, 0), 0, bthdr->used);
           zeroes_in_a = athdr->used - ones_in_a;
           zeroes_in_b = bthdr->used - ones_in_b;
           ones = ones_in_a < ones_in_b ? ones_in_a : ones_in_b;
           zeroes = zeroes_in_a < zeroes_in_b ? zeroes_in_a : zeroes_in_b;
           pbits = THDRELEMPTR(aintersectb, ba_t, 0);
           ba_fill(pbits, 0, zeroes, 0);
           ba_fill(pbits, zeroes, ones, 1);
           aintersectb->used = ones + zeroes;
           pbits = THDRELEMPTR(aminusb, ba_t, 0);
           if (zeroes_in_a > zeroes) {
               aminusb->used = zeroes_in_a - zeroes;
               ba_fill(pbits, 0, aminusb->used, 0);
           }
           if (ones_in_a > ones) {
               ba_fill(pbits, aminusb->used, ones_in_a - ones, 1);
               aminusb->used += ones_in_a - ones;
           }
           pbits = THDRELEMPTR(bminusa, ba_t, 0);
           if (zeroes_in_b > zeroes) {
               bminusa->used = zeroes_in_b - zeroes;
               ba_fill(pbits, 0, bminusa->used, 0);
           }
           if (ones_in_b > ones) {
               ba_fill(pbits, bminusa->used, ones_in_b - ones, 1);
               bminusa->used += ones_in_b - ones;
           }
       }
        break;
    case TA_UINT:
        INTERSECT(unsigned int);
        break;
    case TA_INT:
        INTERSECT(int);
        break;
    case TA_WIDE:
        INTERSECT(Tcl_WideInt);
        break;
    case TA_DOUBLE:
        INTERSECT(double);
        break;
    case TA_BYTE:
        INTERSECT(unsigned char);
        break;
    case TA_ANY:
#undef EQ
#undef LT
        /* TBD - why not EQ -> ta_obj_equal ? */
#define EQ(x_, y_) (ta_obj_compare((x_), (y_), nocase) == 0)
#define LT(x_, y_) (ta_obj_compare((x_), (y_), nocase) < 0)
        INTERSECT(Tcl_Obj *);
        /* Need to update ref counts */
        thdr_incr_obj_refs(aintersectb, 0, aintersectb->used);
        thdr_incr_obj_refs(aminusb, 0, aminusb->used);
        thdr_incr_obj_refs(bminusa, 0, bminusa->used);
        break;
    case TA_STRING:
#undef EQ
#undef LT
#define EQ(x_, y_) (tas_equal((x_), (y_), nocase))
#define LT(x_, y_) (tas_compare((x_), (y_), nocase) < 0)
        INTERSECT(tas_t *);
        /* Need to update ref counts */
        thdr_incr_tas_refs(aintersectb, 0, aintersectb->used);
        thdr_incr_tas_refs(aminusb, 0, aminusb->used);
        thdr_incr_tas_refs(bminusa, 0, bminusa->used);
        break;
    }

    TA_ASSERT(aintersectb->used <= aintersectb->usable);
    TA_ASSERT(aminusb->used <= aminusb->usable);
    TA_ASSERT(bminusa->used <= bminusa->usable);
           
    /* TBD - shrink arrays if underutilized */

    results[0] = tcol_new(aintersectb);
    results[1] = tcol_new(aminusb);
    results[2] = tcol_new(bminusa);
    TA_ASSERT(tcol_check(interp, results[0]));
    TA_ASSERT(tcol_check(interp, results[1]));
    TA_ASSERT(tcol_check(interp, results[2]));
    Tcl_SetObjResult(interp, Tcl_NewListObj(3, results));

    status = TCL_OK;

vamoose:
    if (free_acol)
        Tcl_DecrRefCount(acol);
    if (free_bcol)
        Tcl_DecrRefCount(bcol);
    if (status != TCL_OK) {
        if (aintersectb)
            thdr_decr_refs(aintersectb);
        if (aminusb)
            thdr_decr_refs(aminusb);
        if (bminusa)
            thdr_decr_refs(bminusa);
    }
    return status;
}

critcl::ccode {
    static TCL_RESULT table_put_parseargs(
        Tcl_Interp *ip, int objc, Tcl_Obj * const *objv,
        Tcl_Obj **potab, Tcl_Obj **povalues, Tcl_Obj **pomap, Tcl_Obj **poff)
    {
        if (objc < 3 || objc > 6) {
            if (ip)
                Tcl_WrongNumArgs(ip, 1, objv, "?-columns COLUMNMAP? TABLE VALUES ?POSITION?");
            return TCL_ERROR;
        }
        
        switch (objc) {
        case 3:
        case 4:
            /* Cannot contain an valid option. Parse as though no options */
            *pomap = NULL;
            *potab = objv[1];
            *povalues = objv[2];
            *poff = objc == 4 ? objv[3] : NULL;
            break;
        case 5:
        case 6:
            /* If valid, options must be present */
            /* To prevent shimmering, don't check for options if a tarray */
            if (strcmp(Tcl_GetString(objv[1]), "-columns"))
                return ta_invalid_opt_error(ip, Tcl_GetString(objv[1]));
            *pomap = objv[2];
            *potab = objv[3];
            *povalues = objv[4];
            *poff = objc == 6 ? objv[5] : NULL;
            break;
        }
        return TCL_OK;
    }
}

################################################################
# Table commands

critcl::ccommand tarray::table::put {} {
    Tcl_Obj *table, *ovalues, *omap, *ofirst;
    int status;

    if ((status = table_put_parseargs(interp, objc, objv, &table, &ovalues, &omap, &ofirst)) != TCL_OK)
        return status;

    if (Tcl_IsShared(table))
        table = Tcl_DuplicateObj(table);
    /* Values may be given as a table or a Tcl list */
    if (table_convert(NULL, ovalues) == TCL_OK)
        status = table_copy(interp, table, ovalues, ofirst, omap, 0);
    else
        status = table_put_objs(interp, table, ovalues, ofirst, omap, 0);

    TA_ASSERT(status != TCL_OK || table_check(interp, table));
    return ta_return_result(interp, status, table);
}

critcl::ccommand tarray::table::vput {} {
    Tcl_Obj *ovar, *table, *ovalues, *omap, *ofirst;
    int status;

    if ((status = table_put_parseargs(interp, objc, objv, &ovar, &ovalues, &omap, &ofirst)) != TCL_OK)
        return status;

    table = Tcl_ObjGetVar2(interp, ovar, NULL, TCL_LEAVE_ERR_MSG);
    if (table == NULL)
        return TCL_ERROR;
    if (Tcl_IsShared(table))
        table = Tcl_DuplicateObj(table);

    /* Values may be given as a table or a Tcl list */
    if (table_convert(NULL, ovalues) == TCL_OK)
        status = table_copy(interp, table, ovalues, ofirst, omap, 0);
    else
        status = table_put_objs(interp, table, ovalues, ofirst, omap, 0);

    TA_ASSERT(status != TCL_OK || table_check(interp, table));
    return ta_set_var_result(interp, status, ovar, table);
}

critcl::ccode {

    static TCL_RESULT table_fill_parseargs(
    Tcl_Interp *ip, int objc, Tcl_Obj * const *objv,
    Tcl_Obj **potab, Tcl_Obj **porow, Tcl_Obj **aindex, Tcl_Obj **bindex, Tcl_Obj **pomap)
    {
        int argoff;

        if (objc < 4 || objc > 7) {
            if (ip)
                Tcl_WrongNumArgs(ip, 1, objv, "?-columns COLUMNMAP? TABLE ROW (INDEXLIST | LOW ?HIGH?)");
            return TCL_ERROR;
        }

        argoff = 0;
        *pomap = NULL;
        /* If 4 or 5 args, no options are present */
        if (objc > 5) {
            /* To prevent shimmering, don't check for options if a tarray */
            if (strcmp(Tcl_GetString(objv[1]), "-columns"))
                return ta_invalid_opt_error(ip, Tcl_GetString(objv[1]));
            argoff = 2;
            *pomap = objv[2];
        }

        *potab = objv[++argoff];
        *porow = objv[++argoff];
        *aindex = objv[++argoff];
        *bindex = ++argoff < objc ? objv[argoff] : NULL;
        
        return TCL_OK;

    }
}

critcl::ccommand tarray::table::fill {} {
    Tcl_Obj *table, *orow, *aindex, *bindex, *omap;
    int status;

    if (table_fill_parseargs(interp, objc, objv, &table, &orow, &aindex, &bindex, &omap) != TCL_OK)
        return TCL_ERROR;

    if (Tcl_IsShared(table))
        table = Tcl_DuplicateObj(table);

    status = table_fill_obj(interp, table, orow, aindex, bindex, omap, 0);
    TA_ASSERT(status != TCL_OK || table_check(interp, table));
    return ta_return_result(interp, status, table);
}

critcl::ccommand tarray::table::vfill {} {
    int status;
    Tcl_Obj *ovar, *table, *orow, *aindex, *bindex, *omap;

    if (table_fill_parseargs(interp, objc, objv, &ovar, &orow, &aindex, &bindex, &omap) != TCL_OK)
        return TCL_ERROR;

    table = Tcl_ObjGetVar2(interp, ovar, NULL, TCL_LEAVE_ERR_MSG);
    if (table == NULL)
        return TCL_ERROR;
    if (Tcl_IsShared(table))
        table = Tcl_DuplicateObj(table);

    status = table_fill_obj(interp, table, orow, aindex, bindex, omap, 0);
    TA_ASSERT(status != TCL_OK || table_check(interp, table));
    return ta_set_var_result(interp, status, ovar, table);
}

critcl::ccommand tarray::table::delete {} {
    Tcl_Obj *table;
    int status;

    if (objc != 3 && objc != 4) {
	Tcl_WrongNumArgs(interp, 1, objv, "TABLE (INDEXLIST | LOW ?HIGH?)");
	return TCL_ERROR;
    }
    
    table = objv[1];
    if (Tcl_IsShared(table))
        table = Tcl_DuplicateObj(table);
    status = table_delete(interp, table, objv[2], objc == 4 ? objv[3] : NULL);
    TA_ASSERT(status != TCL_OK || table_check(interp, table));
    return ta_return_result(interp, status, table);
}


critcl::ccommand tarray::table::vdelete {} {
    Tcl_Obj *table;
    int status;

    if (objc != 3 && objc != 4) {
	Tcl_WrongNumArgs(interp, 1, objv, "TABLEVAR (INDEXLIST | LOW ?HIGH?)");
	return TCL_ERROR;
    }
    
    table = Tcl_ObjGetVar2(interp, objv[1], NULL, TCL_LEAVE_ERR_MSG);
    if (table == NULL)
        return TCL_ERROR;
    if (Tcl_IsShared(table))
        table = Tcl_DuplicateObj(table);
    status = table_delete(interp, table, objv[2], objc == 4 ? objv[3] : NULL);
    TA_ASSERT(status != TCL_OK || table_check(interp, table));
    return ta_set_var_result(interp, status, objv[1], table);
}

critcl::ccommand tarray::table::get {} {
    return table_retrieve(interp, objc, objv, TA_RETRIEVE_GET);
}

critcl::ccommand tarray::table::range {} {
    return table_retrieve(interp, objc, objv, TA_RETRIEVE_RANGE);
}

critcl::cproc tarray::table::index {Tcl_Interp* interp Tcl_Obj* GRID Tcl_Obj* INDEX} ok {
    int ix;
    Tcl_Obj *o;

    if (table_convert(interp, GRID) == TCL_OK) {
        int end = table_length(GRID) - 1;
	if (ta_convert_index(interp, INDEX, &ix, end, 0, end) == TCL_OK) {
            o = table_index(interp, GRID, ix);
            if (o) {
                Tcl_SetObjResult(interp, o);
                return TCL_OK;
            }
        }
    }
    return TCL_ERROR;
}


critcl::ccode {

    static TCL_RESULT table_insert_parseargs(
    Tcl_Interp *ip, int objc, Tcl_Obj * const *objv,
    Tcl_Obj **potab, Tcl_Obj **povalues, Tcl_Obj **pofirst, Tcl_Obj **pocount, Tcl_Obj **pomap)
    {
        int argoff;

        if (objc < 4 || objc > 7) {
            if (ip)
                Tcl_WrongNumArgs(ip, 1, objv, "?-columns COLUMNMAP? TABLE  (ROWS INDEXLIST | ROW LOW ?HIGH?)");
            return TCL_ERROR;
        }

        argoff = 0;
        *pomap = NULL;
        /* If 4 or 5 args, no options are present */
        if (objc > 5) {
            if (strcmp(Tcl_GetString(objv[1]), "-columns"))
                return ta_invalid_opt_error(ip, Tcl_GetString(objv[1]));
            argoff = 2;
            *pomap = objv[2];
        }

        *potab = objv[++argoff];
        *povalues = objv[++argoff];
        *pofirst = objv[++argoff];
        *pocount = ++argoff < objc ? objv[argoff] : NULL;
        
        return TCL_OK;
    }
}

critcl::ccommand tarray::table::insert {} {
    Tcl_Obj *table, *ovalues, *ofirst, *ocount, *omap;
    int status;

    if (table_insert_parseargs(interp, objc, objv, &table, &ovalues,
                               &ofirst, &ocount, &omap) != TCL_OK)
        return TCL_ERROR;

    if (Tcl_IsShared(table))
        table = Tcl_DuplicateObj(table);
    status = table_insert_obj(interp, table, ovalues, ofirst, ocount, omap);
    TA_ASSERT(status != TCL_OK || table_check(interp, table));
    return ta_return_result(interp, status, table);
}

critcl::ccommand tarray::table::vinsert {} {
    Tcl_Obj *ovar, *table, *ovalues, *ofirst, *ocount, *omap;
    int status;

    if (table_insert_parseargs(interp, objc, objv, &ovar, &ovalues,
                               &ofirst, &ocount, &omap) != TCL_OK)
        return TCL_ERROR;

    table = Tcl_ObjGetVar2(interp, ovar, NULL, TCL_LEAVE_ERR_MSG);
    if (table == NULL)
        return TCL_ERROR;
    if (Tcl_IsShared(table))
        table = Tcl_DuplicateObj(table);
    status = table_insert_obj(interp, table, ovalues, ofirst, ocount, omap);
    TA_ASSERT(status != TCL_OK || table_check(interp, table));
    return ta_set_var_result(interp, status, ovar, table);
}

critcl::ccode {
    static TCL_RESULT table_place_parseargs(Tcl_Interp *ip, int objc, Tcl_Obj * const *objv, Tcl_Obj **potab, Tcl_Obj **povalues, Tcl_Obj **poindices, Tcl_Obj **pomap)
    {
        int argpos;
	char *s;
    
        if (objc == 4) {
            argpos = 0;
            *pomap = NULL;
        } else {
            if (objc != 6) {
                if (ip)
                    Tcl_WrongNumArgs(ip, 1, objv, "?-columns COLUMNMAP? TABLE VALUES INDICES");
                return TCL_ERROR;
            }
	    s = Tcl_GetString(objv[1]);
            if (strcmp(s, "-columns"))
                return ta_invalid_opt_error(ip, s);
            argpos = 2;
            *pomap = objv[2];
        }

        *potab = objv[1+argpos];
        *povalues = objv[2+argpos];
        *poindices = objv[3+argpos];
        
        return TCL_OK;
    }
}

critcl::ccommand tarray::table::place {} {
    int status;
    Tcl_Obj *otab, *ovalues, *oindices, *omap;
    
    if (table_place_parseargs(interp, objc, objv, &otab, &ovalues,
                           &oindices, &omap) != TCL_OK)
        return TCL_ERROR;

    if (Tcl_IsShared(otab))
        otab = Tcl_DuplicateObj(otab);

    status = table_place(interp, otab, ovalues, oindices, omap);
    TA_ASSERT(status != TCL_OK || table_check(interp, otab));
    return ta_return_result(interp, status, otab);
}


critcl::ccommand tarray::table::vplace {} {
    int status;
    Tcl_Obj *ovar, *ovalues, *oindices, *omap, *otab;
    
    if (table_place_parseargs(interp, objc, objv, &ovar, &ovalues,
                           &oindices, &omap) != TCL_OK)
        return TCL_ERROR;

    otab = Tcl_ObjGetVar2(interp, ovar, NULL, TCL_LEAVE_ERR_MSG);
    if (otab == NULL)
        return TCL_ERROR;
    if (Tcl_IsShared(otab))
        otab = Tcl_DuplicateObj(otab);
    
    status = table_place(interp, otab, ovalues, oindices, omap);
    TA_ASSERT(status != TCL_OK || table_check(interp, otab));
    return ta_set_var_result(interp, status, ovar, otab);
}

critcl::cproc tarray::table::reverse {Tcl_Interp* interp Tcl_Obj* table} ok {
    TCL_RESULT status;
    if (Tcl_IsShared(table))
        table = Tcl_DuplicateObj(table);

    status = table_reverse(interp, table);
    TA_ASSERT(status != TCL_OK || table_check(interp, table));
    return ta_return_result(interp, status, table);
}
    
critcl::cproc tarray::table::vreverse {Tcl_Interp* interp Tcl_Obj* ovar} ok {
    Tcl_Obj *table;
    TCL_RESULT status;

    table = Tcl_ObjGetVar2(interp, ovar, NULL, TCL_LEAVE_ERR_MSG);
    if (table == NULL)
        return TCL_ERROR;

    if (Tcl_IsShared(table))
        table = Tcl_DuplicateObj(table);

    status = table_reverse(interp, table);
    TA_ASSERT(status != TCL_OK || table_check(interp, table));
    return ta_set_var_result(interp, status, ovar, table);
}

critcl::cproc tarray::table::size {TableObjPtr TABLE} int {
    return table_length(TABLE);
}

critcl::cproc tarray::table::width {TableObjPtr TABLE} int {
    return table_width(TABLE);
}

critcl::ccommand tarray::table::column {} {
    Tcl_Obj *table;
    TCL_RESULT status;

    if (objc != 3 && objc != 4) {
	Tcl_WrongNumArgs(interp, 1, objv, "TABLEVAR COLSPEC ?NEWCOLUMN?");
	return TCL_ERROR;
    }

    table = objv[1];
    if (objc == 3)
        return table_get_column(interp, table, objv[2]);

    if (Tcl_IsShared(table))
        table = Tcl_DuplicateObj(table);

    status = table_set_column(interp, table, objv[2], objv[3]);
    TA_ASSERT(status != TCL_OK || table_check(interp, table));
    return ta_return_result(interp, status, table);
}

critcl::ccommand tarray::table::vcolumn {} {
    Tcl_Obj *table;
    TCL_RESULT status;

    if (objc != 3 && objc != 4) {
	Tcl_WrongNumArgs(interp, 1, objv, "TABLEVAR COLSPEC ?NEWCOLUMN?");
	return TCL_ERROR;
    }

    table = Tcl_ObjGetVar2(interp, objv[1], NULL, TCL_LEAVE_ERR_MSG);
    if (table == NULL)
        return TCL_ERROR;

    if (objc == 3)
        return table_get_column(interp, table, objv[2]);

    if (Tcl_IsShared(table))
        table = Tcl_DuplicateObj(table);

    status = table_set_column(interp, table, objv[2], objv[3]);
    TA_ASSERT(status != TCL_OK || table_check(interp, table));
    return ta_set_var_result(interp, status, objv[1], table);
}


critcl::cproc tarray::table::cnames {Tcl_Interp* interp TableObjPtr TABLE} ok {
    Tcl_SetObjResult(interp, table_column_names(TABLE));
    return TCL_OK;
}

critcl::cproc tarray::table::slice {Tcl_Interp* interp TableObjPtr TABLE Tcl_Obj* COLUMNLIST} ok {
    Tcl_Obj *ocolnames, *ocolname, **pdstcols;
    int      count, status, srcindex;
    thdr_t  *thdr;
    int i;
    Tcl_Obj *oindex;
        
    if ((status = Tcl_ListObjLength(interp, COLUMNLIST, &count)) != TCL_OK)
        return status;
    thdr = thdr_alloc(interp, TA_ANY, count);
    if (thdr == NULL)
        return TCL_ERROR;
    /* TBD - maybe we can use column_map_get_columns here ? */
    pdstcols = THDRELEMPTR(thdr, Tcl_Obj *, 0);
    ocolnames = Tcl_NewListObj(0, NULL);
    for (i = 0; i < count; ++i) {
        TA_NOFAIL(Tcl_ListObjIndex(interp, COLUMNLIST, i, &oindex), TCL_OK);
        TA_ASSERT(oindex);
        if (table_parse_column_index(interp, TABLE, oindex, &srcindex) != TCL_OK)
            break;
        if (table_column_index_to_name(interp, TABLE, srcindex, &ocolname) != TCL_OK)
            break;
        /* Everything seems in order. Store name->index mapping */
        Tcl_ListObjAppendElement(NULL, ocolnames, ocolname);
        Tcl_ListObjAppendElement(NULL, ocolnames, Tcl_NewIntObj(i));
        /* Store the column in the output */
        pdstcols[i] = table_column(TABLE, srcindex);
        Tcl_IncrRefCount(pdstcols[i]);
        thdr->used += 1;
    }
    if (i < count)
            status = TCL_ERROR; /* Early termination => error */
    else {
        /*
         * So far so good but tThere is one last thing to be checked - no
         * duplicate names. We do this by checking size of the column
         * names dictionary.
         */
        TA_NOFAIL(Tcl_DictObjSize(interp, ocolnames, &i), TCL_OK);
        status = i == count ? TCL_OK : ta_duplicate_columns_error(interp, COLUMNLIST);
    }

    if (status == TCL_ERROR) {
        thdr_decr_refs(thdr);
        Tcl_DecrRefCount(ocolnames);
    } else {
        Tcl_Obj *otab = table_new(thdr, ocolnames);
        TA_ASSERT(table_check(interp, otab));
        Tcl_SetObjResult(interp, otab);
    }
    return status;
}


critcl::cproc tarray::unsupported::compiler_info {Tcl_Interp* interp} ok {
    Tcl_Obj *objs[6];

    /* Return a keyed list */
    
    objs[0] = Tcl_NewStringObj("compiler", -1);
#if defined(_MSC_VER)
    objs[1] = Tcl_ObjPrintf("vc++ %u", _MSC_VER);
#elif defined(__GNUC__)
    objs[1] = Tcl_NewStringObj("gcc" __VERSION__, -1);
#else
    objs[1] = Tcl_NewStringObj("unknown", -1);
#endif

    objs[2] = Tcl_NewStringObj("opts", -1);

    objs[3] = Tcl_NewListObj(0, NULL);
#ifdef TA_MT_ENABLE
    Tcl_ListObjAppendElement(NULL, objs[3], Tcl_NewStringObj("mt_enabled", -1));
#endif
#if TA_ENABLE_ASSERT
    Tcl_ListObjAppendElement(NULL, objs[3], Tcl_NewStringObj("asserts_enabled", -1));
#endif

    /* Which Tcl did we build against ? (As opposed to run time) */
    objs[4] = Tcl_NewStringObj("tcl_headers", -1);
    objs[5] = Tcl_NewStringObj(TCL_PATCH_LEVEL, -1);

     Tcl_SetObjResult(interp, Tcl_NewListObj(6, objs));
     return TCL_OK;
}

critcl::cdata tarray::unsupported::critcl_info [critcl::showconfig]
critcl::cdata tarray::unsupported::hg_id       [exec hg identify]

critcl::cproc tarray::unsupported::mt_split {Tcl_Interp* interp int tatype int first int count int min_hint int nsizes} ok {
    int sizes[16];
    Tcl_Obj *ores;
    int i, split_count;
    if (nsizes > ARRAYSIZE(sizes)) {
        Tcl_SetResult(interp, "Invalid array size", TCL_STATIC);
        return TCL_ERROR;
    }
    split_count = thdr_calc_mt_split_ex(tatype, first, count, min_hint, nsizes, sizes);
    ores = Tcl_NewListObj(nsizes, NULL);
    for (i = 0; i < split_count; ++i)
        Tcl_ListObjAppendElement(interp, ores, Tcl_NewIntObj(sizes[i]));
    Tcl_SetObjResult(interp, ores);
    return TCL_OK;
}

package provide tarray 0.7

critcl::load
