#
# Copyright (c) 2012, Ashok P. Nadkarni
# All rights reserved.
#
# See the file LICENSE for license


package require critcl 3.1
critcl::buildrequirement {
    package require critcl::class
}
critcl::clean_cache
critcl::tcl 8.5
critcl::debug symbols
#critcl::cflags -std=gnu99 -Winline

critcl::csources tarray.c tasearch.c bitarray.c tasort.c
critcl::tsources tarray.tcl
critcl::cheaders tarray.h

critcl::ccode {
#include "tarray.h"
    typedef Tcl_Obj *TArrayObjPtr;

    /* Must match order of TA_FORMAT_* in tarray.h */
    static const char *gFormatOptions[] = {
        "-tarray",
        "-list",
        "-dict",
        NULL
    };
}


critcl::cinit {
    g_tcl_list_type_ptr = Tcl_GetObjType("list");
} {
}

critcl::argtype TArrayObjPtr {
    if (tcol_convert(interp, @@) != TCL_OK)
        return TCL_ERROR;
    @A = @@;
}

critcl::argtype thdr_t* {
    if (tcol_convert(interp, @@) != TCL_OK)
        return TCL_ERROR;
    @A = TARRAYHDR(@@);
}

critcl::ccommand tarray::column::create {} {
    int init_size;
    int tatype;
    Tcl_Obj **elems;
    int nelems;
    thdr_t *thdrP;

    if (objc < 2 || objc > 4) {
        Tcl_WrongNumArgs(interp, 1, objv, "TYPE ?INITVAL? ?INITSIZE?");
        return TCL_ERROR;
    }

    if (Tcl_GetIndexFromObj(interp, objv[1], g_ta_type_tokens, "TArrayType",
                            TCL_EXACT, &tatype) != TCL_OK) {
	return TCL_ERROR;
    }

    init_size = 0;
    nelems = 0;
    elems = NULL;
    if (objc > 2) {
        if (Tcl_ListObjGetElements(interp, objv[2], &nelems, &elems) != TCL_OK)
            return TCL_ERROR;
        if (objc > 3) {
            if (Tcl_GetIntFromObj(interp, objv[3], &init_size) != TCL_OK)
                return TCL_ERROR;
        }
    }

    thdrP = thdr_alloc_and_init(interp, tatype, nelems, elems, init_size);
    if (thdrP == NULL)
        return TCL_ERROR;

    Tcl_SetObjResult(interp, tcol_new(thdrP));
    return TCL_OK;
}


critcl::ccommand tarray::column::delete {} {
    Tcl_Obj *tcol;
    int status;

    if (objc != 3 && objc != 4) {
	Tcl_WrongNumArgs(interp, 1, objv, "TARRAY (INDEXLIST | LOW ?HIGH?)");
	return TCL_ERROR;
    }
    
    tcol = objv[1];
    if (Tcl_IsShared(tcol))
        tcol = Tcl_DuplicateObj(objv[1]);

    status = tcol_delete(interp, tcol, objv[2], objc == 4 ? objv[3] : NULL);
    if (status == TCL_OK)
        Tcl_SetObjResult(interp, tcol);
    else if (tcol != objv[1])
        Tcl_DecrRefCount(tcol); /* We allocated it so free it */

    return status;
}

critcl::ccommand tarray::column::vdelete {} {
    Tcl_Obj *ovalue;
    Tcl_Obj *tcol;
    int status;

    if (objc != 3 && objc != 4) {
	Tcl_WrongNumArgs(interp, 1, objv, "TARRAYVAR (INDEXLIST | LOW ?HIGH?)");
	return TCL_ERROR;
    }
    
    ovalue = Tcl_ObjGetVar2(interp, objv[1], NULL, TCL_LEAVE_ERR_MSG);
    if (ovalue == NULL)
        return TCL_ERROR;

    tcol = Tcl_IsShared(ovalue) ? Tcl_DuplicateObj(ovalue) : ovalue;

    status = tcol_delete(interp, tcol, objv[2], objc == 4 ? objv[3] : NULL);
    if (status == TCL_OK) {
        /* Even if we had not duplicated the value in the variable, we
         * still need to store it back so that traces are triggered. Also,
         * do not want to rely ObjSetVar2 behaviour w.r.t to Tcl_Obj with
         * ref count 0 on error (currently it frees iff ref == 0) so
         * do a Incr/Decr
         */
        Tcl_IncrRefCount(tcol);
        ovalue = Tcl_ObjSetVar2(interp, objv[1], NULL, tcol, TCL_LEAVE_ERR_MSG);
        Tcl_DecrRefCount(tcol);
        if (ovalue)
            Tcl_SetObjResult(interp, ovalue);
        else
            status = TCL_ERROR;
    } else if (tcol != ovalue)
        Tcl_DecrRefCount(tcol); /* We allocated it so free it */

    return status;
}

critcl::cproc tarray::column::size {Tcl_Interp* interp TArrayObjPtr tcol} int {
    return tcol_occupancy(tcol);
}

critcl::cproc tarray::column::type {Tcl_Interp* interp TArrayObjPtr tcol} "const char*" {
    return ta_type_string(tcol_type(tcol));
}

critcl::cproc tarray::column::index {Tcl_Interp* interp thdr_t* tcolumn Tcl_Obj* index} ok {
    int ix;
    if (ta_convert_index(interp, index, &ix, tcolumn->used-1, 0, tcolumn->used-1) != TCL_OK)
        return TCL_ERROR;
    if (ix < 0 || ix >= tcolumn->used) {
        ta_index_range_error(interp, ix);
        return TCL_ERROR;
    }
    Tcl_SetObjResult(interp, thdr_index(tcolumn, ix));
    return TCL_OK;
}

critcl::ccommand tarray::column::get {} {
    Tcl_Obj *tcol;
    int low, count;
    int status;
    int fmt = TA_FORMAT_TARRAY;
    int ta_arg;
    thdr_t *pindices;

    if (objc < 3)
        goto badargs;
    
    /*
     * Parsing is ambiguous. We do not want check if objv[1] is an option
     * directly because it might shimmer a huge tarray into a string.
     * So check for options only if not a tarray. Note it is possible that
     * objv[1] is a tarray even though it's type does not indicate as much.
     * In that the string rep will anyways exist and question of shimmering
     * does not arise.
     */
    if (objv[1]->typePtr == &g_ta_type) {
        ta_arg = 1;
    } else {
        /* OK, see if it is an option */
        status = Tcl_GetIndexFromObj(NULL, objv[1], gFormatOptions,
                                     "FORMAT", TCL_EXACT, &fmt);
        if (status == TCL_OK)
            ta_arg = 2;
        else
            ta_arg = 1;
        if ((status = tcol_convert(interp, objv[ta_arg])) != TCL_OK)
            return status;
    }
       
    if ((objc - ta_arg) < 2 || (objc - ta_arg) > 3)
        goto badargs;

    switch (objc - ta_arg - 1) {
    case 1:
        switch (tcol_to_indices(interp, objv[ta_arg+1], 0, &pindices, NULL)) {
        case TA_INDEX_TYPE_ERROR:
            return TCL_ERROR;
        case TA_INDEX_TYPE_INT:
            Tcl_Panic("tcol_to_indices returned TA_INDEX_TYPE_INT when passed NULL pointer");
            break;
        case TA_INDEX_TYPE_thdr_t:
            tcol = tcol_get(interp, TARRAYHDR(objv[ta_arg]), pindices, fmt);
            thdr_decr_refs(pindices);
            break;
        }
        break;
    case 2:
        /* Range LOW HIGH */
        /* TBD - reuse the thdr_t if not shared */
        status = ta_fix_range_bounds(interp, TARRAYHDR(objv[ta_arg]),
                                         objv[ta_arg+1], objv[ta_arg+2],
                                         &low, &count);
        if (status != TCL_OK)
            return TCL_ERROR;
        tcol = ta_range(interp, objv[ta_arg], low, count, fmt);
        break;
    default:
        goto badargs;
    }

    if (tcol) {
        Tcl_SetObjResult(interp, tcol);
        return TCL_OK;
    } else
        return TCL_ERROR;

badargs:
    Tcl_WrongNumArgs(interp, 1, objv, "?OPTIONS? TCOLUMN (LOW ?HIGH? | INDEXLIST)");
    return TCL_ERROR;

}

critcl::ccommand tarray::column::sort {} {
    int decreasing;
    int return_indices;
    Tcl_Obj *tcol;
    int status;

    if (objc < 2) {
	Tcl_WrongNumArgs(interp, 1, objv, "?options? tarray");
	return TCL_ERROR;
    }

    if ((status = tcol_parse_sort_options(interp, objc, objv, &decreasing,
                                          &return_indices)) != TCL_OK)
        return status;

    tcol = objv[objc-1];
    if (Tcl_IsShared(tcol))
        tcol = Tcl_DuplicateObj(tcol);

    status = tcol_sort(interp, tcol, decreasing, return_indices);
    if (status == TCL_OK) {
        Tcl_SetObjResult(interp, tcol);
    } else if (tcol != objv[objc-1])
        Tcl_DecrRefCount(tcol); /* We allocated it so free it */
    return status;
}

critcl::ccommand tarray::column::vsort {} {
    int decreasing;
    int return_indices;
    Tcl_Obj *tcol;
    Tcl_Obj *ovarvalue;
    int status;

    if (objc < 2) {
    	Tcl_WrongNumArgs(interp, 1, objv, "?options? COLUMNVAR");
        return TCL_ERROR;
    }

    if ((status = tcol_parse_sort_options(interp, objc, objv, &decreasing,
                                          &return_indices)) != TCL_OK)
        return status;

    ovarvalue = Tcl_ObjGetVar2(interp, objv[objc-1], NULL, TCL_LEAVE_ERR_MSG);
    if (ovarvalue == NULL)
        return TCL_ERROR;

    tcol = ovarvalue;
    if (Tcl_IsShared(tcol))
            tcol = Tcl_DuplicateObj(tcol);

    status = tcol_sort(interp, tcol, decreasing, return_indices);
    if (status == TCL_OK) {
        /* Even if we had not duplicated the value in the variable, we
         * still need to store it back so that traces are triggered. Also,
         * do not want to rely ObjSetVar2 behaviour w.r.t to Tcl_Obj with
         * ref count 0 on error (currently it frees iff ref == 0) so
         * do a Incr/Decr
         */
        Tcl_IncrRefCount(tcol);
        ovarvalue = Tcl_ObjSetVar2(interp, objv[objc-1], NULL, tcol, TCL_LEAVE_ERR_MSG);
        Tcl_DecrRefCount(tcol);
        if (ovarvalue)
            Tcl_SetObjResult(interp, ovarvalue);
        else
            status = TCL_ERROR;
    } else if (tcol != ovarvalue)
        Tcl_DecrRefCount(tcol); /* We allocated it so free it */

    return status;
}

critcl::cproc tarray::column::bitsset {Tcl_Interp* interp TArrayObjPtr tcol} ok {
    thdr_t *thdrP = TARRAYHDR(tcol);
    if (thdrP->type != TA_BOOLEAN) {
        Tcl_SetResult(interp, "tarray type is not boolean", TCL_STATIC);
        return TCL_ERROR;
    }
        
    Tcl_SetObjResult(
        interp,
        Tcl_NewIntObj(ba_count_ones(THDRELEMPTR(thdrP, ba_t, 0), 0, thdrP->used)));
    return TCL_OK;
}

critcl::ccommand tarray::column::search tcol_search_cmd

critcl::ccommand tarray::column::insert {} {
    Tcl_Obj *tcol;
    int status;

    if (objc != 4 && objc != 5) {
    	Tcl_WrongNumArgs(interp, 1, objv, "COLUMN (VALUES POSITION | VALUE POSITION COUNT)");
	return TCL_ERROR;
    }
    
    tcol = objv[1];
    if (Tcl_IsShared(tcol))
        tcol = Tcl_DuplicateObj(tcol);

    if (objc == 4) {
        /* Values may be given as a list or a tarray */
        if ((status = tcol_convert(NULL, objv[2])) == TCL_OK)
            status = tcol_copy_thdr(interp, tcol, TARRAYHDR(objv[2]), objv[3], 1);
        else
            status = tcol_put_objs(interp, tcol, objv[2], objv[3], 1);
    } else {
        int pos, count, used;
        if ((status = Tcl_GetIntFromObj(interp, objv[4], &count)) == TCL_OK &&
            (status = tcol_convert(interp, tcol)) == TCL_OK) {
            used = tcol_occupancy(tcol);
            if (count < 0)
                count = 0;      /* Should we error instead? */
            if ((status = tcol_make_modifiable(interp, tcol, count+used, 0)) == TCL_OK &&
                (status = ta_convert_index(interp, objv[3], &pos, used,
                                           0, used)) == TCL_OK) {
                ta_value_t tav;
                if ((status = ta_value_from_obj(interp, objv[2],
                                                tcol_type(tcol), &tav)) == TCL_OK)
                    thdr_fill_range(interp, TARRAYHDR(tcol), &tav, pos, count, 1);
            }
        }
    }

    if (status == TCL_OK)
        Tcl_SetObjResult(interp, tcol);
    else if (tcol != objv[1])
        Tcl_DecrRefCount(tcol); /* We allocated it so free it */

    return status;
}

critcl::ccommand tarray::column::vinsert {} {
    Tcl_Obj *tcol;
    Tcl_Obj *ovarvalue;
    int status;

    if (objc != 4 && objc != 5) {
    	Tcl_WrongNumArgs(interp, 1, objv, "COLUMNVAR (VALUES POSITION | VALUE POSITION COUNT)");
	return TCL_ERROR;
    }
    
    ovarvalue = Tcl_ObjGetVar2(interp, objv[1], NULL, TCL_LEAVE_ERR_MSG);
    if (ovarvalue == NULL)
        return TCL_ERROR;

    tcol = ovarvalue;
    if (Tcl_IsShared(tcol))
        tcol = Tcl_DuplicateObj(tcol);

    if (objc == 4) {
        /* Values may be given as a list or a tarray */
        if ((status = tcol_convert(NULL, objv[2])) == TCL_OK)
            status = tcol_copy_thdr(interp, tcol, TARRAYHDR(objv[2]), objv[3], 1);
        else
            status = tcol_put_objs(interp, tcol, objv[2], objv[3], 1);
    } else {
        int pos, count, used;
        if ((status = Tcl_GetIntFromObj(interp, objv[4], &count)) == TCL_OK &&
            (status = tcol_convert(interp, tcol)) == TCL_OK) {
            used = tcol_occupancy(tcol);
            if (count < 0)
                count = 0;      /* Should we error instead? */
            if ((status = tcol_make_modifiable(interp, tcol, count+used, 0)) == TCL_OK &&
                (status = ta_convert_index(interp, objv[3], &pos, used,
                                           0, used)) == TCL_OK) {
                ta_value_t tav;
                if ((status = ta_value_from_obj(interp, objv[2],
                                                tcol_type(tcol), &tav)) == TCL_OK)
                    thdr_fill_range(interp, TARRAYHDR(tcol), &tav, pos, count, 1);
            }
        }
    }

    if (status == TCL_OK) {
        /* Even if we had not duplicated the value in the variable, we
         * still need to store it back so that traces are triggered. Also,
         * do not want to rely ObjSetVar2 behaviour w.r.t to Tcl_Obj with
         * ref count 0 on error (currently it frees iff ref == 0) so
         * do a Incr/Decr
         */
        Tcl_IncrRefCount(tcol);
        ovarvalue = Tcl_ObjSetVar2(interp, objv[1], NULL, tcol, TCL_LEAVE_ERR_MSG);
        Tcl_DecrRefCount(tcol);
        if (ovarvalue)
            Tcl_SetObjResult(interp, ovarvalue);
        else
            status = TCL_ERROR;
    } else if (tcol != ovarvalue)
        Tcl_DecrRefCount(tcol); /* We allocated it so free it */

    return status;
}



critcl::ccommand tarray::column::put {} {
    Tcl_Obj *tcol;
    int status;

    if (objc != 4) {
    	Tcl_WrongNumArgs(interp, 1, objv, "COLUMN VALUES FIRST");
	return TCL_ERROR;
    }
    
    tcol = objv[1];
    if (Tcl_IsShared(tcol))
        tcol = Tcl_DuplicateObj(objv[1]);

    /* Values may be given as a list or a tarray */
    if (tcol_convert(NULL, objv[2]) == TCL_OK) {
        /* It is a tarray. Verify the right type */
        status = tcol_copy_thdr(interp, tcol, TARRAYHDR(objv[2]), objv[3], 0);
    } else {
        status = tcol_put_objs(interp, tcol, objv[2], objv[3], 0);
    }

    if (status == TCL_OK)
        Tcl_SetObjResult(interp, tcol);
    else if (tcol != objv[1])
        Tcl_DecrRefCount(tcol); /* We allocated it so free it */

    return status;
}

critcl::ccommand tarray::column::vput {} {
    Tcl_Obj *tcol;
    Tcl_Obj *varValueObj;
    int status;

    if (objc != 4) {
	Tcl_WrongNumArgs(interp, 1, objv, "TCOLUMNVAR VALUES FIRST");
	return TCL_ERROR;
    }
    
    varValueObj = Tcl_ObjGetVar2(interp, objv[1], NULL, TCL_LEAVE_ERR_MSG);
    if (varValueObj == NULL)
        return TCL_ERROR;

    tcol = varValueObj;
    if (Tcl_IsShared(tcol))
        tcol = Tcl_DuplicateObj(varValueObj);

    /* Values may be given as a list or a tarray */
    if (tcol_convert(NULL, objv[2]) == TCL_OK) {
        /* It is a tarray. Verify the right type */
        status = tcol_copy_thdr(interp, tcol, TARRAYHDR(objv[2]), objv[3], 0);
    } else {
        status = tcol_put_objs(interp, tcol, objv[2], objv[3], 0);
    }

    if (status == TCL_OK) {
        /* Even if we had not duplicated the value in the variable, we
         * still need to store it back so that traces are triggered. Also,
         * do not want to rely ObjSetVar2 behaviour w.r.t to Tcl_Obj with
         * ref count 0 on error (currently it frees iff ref == 0) so
         * do a Incr/Decr
         */
        Tcl_IncrRefCount(tcol);
        varValueObj = Tcl_ObjSetVar2(interp, objv[1], NULL, tcol, TCL_LEAVE_ERR_MSG);
        Tcl_DecrRefCount(tcol);
        if (varValueObj)
            Tcl_SetObjResult(interp, varValueObj);
        else
            status = TCL_ERROR;
    } else if (tcol != varValueObj)
        Tcl_DecrRefCount(tcol); /* We allocated it so free it */

    return status;
}

critcl::ccommand tarray::column::place {} {
    Tcl_Obj *tcol;
    int status;

    if (objc != 4) {
	Tcl_WrongNumArgs(interp, 1, objv, "TCOLUMN VALUES INDEXLIST");
	return TCL_ERROR;
    }

    tcol = objv[1];
    if (Tcl_IsShared(tcol))
        tcol = Tcl_DuplicateObj(objv[1]);

    status = tcol_place_objs(interp, tcol, objv[2], objv[3]);
    if (status == TCL_OK)
        Tcl_SetObjResult(interp, tcol);
    else if (tcol != objv[1])
        Tcl_DecrRefCount(tcol); /* We allocated it so free it */

    return status;
}

critcl::ccommand tarray::column::vplace {} {
    Tcl_Obj *ovalue;
    Tcl_Obj *tcol;
    int status;

    if (objc != 4) {
	Tcl_WrongNumArgs(interp, 1, objv, "TCOLUMNVAR VALUES INDEXLIST");
	return TCL_ERROR;
    }

    ovalue = Tcl_ObjGetVar2(interp, objv[1], NULL, TCL_LEAVE_ERR_MSG);
    if (ovalue == NULL)
        return TCL_ERROR;

    tcol = Tcl_IsShared(ovalue) ? Tcl_DuplicateObj(ovalue) : ovalue;

    status = tcol_place_objs(interp, tcol, objv[2], objv[3]);
    if (status == TCL_OK) {
        /* Even if we had not duplicated the value in the variable, we
         * still need to store it back so that traces are triggered. Also,
         * do not want to rely ObjSetVar2 behaviour w.r.t to Tcl_Obj with
         * ref count 0 on error (currently it frees iff ref == 0) so
         * do a Incr/Decr
         */
        Tcl_IncrRefCount(tcol);
        ovalue = Tcl_ObjSetVar2(interp, objv[1], NULL, tcol, TCL_LEAVE_ERR_MSG);
        Tcl_DecrRefCount(tcol);
        if (ovalue)
            Tcl_SetObjResult(interp, ovalue);
        else
            status = TCL_ERROR;
    } else if (tcol != ovalue)
        Tcl_DecrRefCount(tcol); /* We allocated it so free it */

    return status;
}

critcl::ccommand tarray::column::fill {} {
    Tcl_Obj *tcol;
    int status;

    if (objc != 4 && objc != 5) {
	Tcl_WrongNumArgs(interp, 1, objv, "TCOLUMN VALUE (INDEXLIST | LOW ?HIGH?)");
	return TCL_ERROR;
    }

    tcol = objv[1];
    if (Tcl_IsShared(tcol))
        tcol = Tcl_DuplicateObj(objv[1]);

    status = tcol_fill_obj(interp, tcol, objv[2], objv[3],
                               objc == 5 ? objv[4] : NULL);
    if (status == TCL_OK)
        Tcl_SetObjResult(interp, tcol);
    else if (tcol != objv[1])
        Tcl_DecrRefCount(tcol); /* We allocated it so free it */

    return status;
}

critcl::ccommand tarray::column::vfill {} {
    Tcl_Obj *ovalue;
    Tcl_Obj *tcol;
    int status;

    if (objc != 4 && objc != 5) {
	Tcl_WrongNumArgs(interp, 1, objv, "TCOLUMNVAR VALUE (INDEXLIST | LOW ?HIGH?)");
	return TCL_ERROR;
    }
    
    ovalue = Tcl_ObjGetVar2(interp, objv[1], NULL, TCL_LEAVE_ERR_MSG);
    if (ovalue == NULL)
        return TCL_ERROR;

    tcol = Tcl_IsShared(ovalue) ? Tcl_DuplicateObj(ovalue) : ovalue;

    status = tcol_fill_obj(interp, tcol, objv[2], objv[3], objc == 5 ? objv[4] : NULL);
    if (status == TCL_OK) {
        /* Even if we had not duplicated the value in the variable, we
         * still need to store it back so that traces are triggered. Also,
         * do not want to rely ObjSetVar2 behaviour w.r.t to Tcl_Obj with
         * ref count 0 on error (currently it frees iff ref == 0) so
         * do a Incr/Decr
         */
        Tcl_IncrRefCount(tcol);
        ovalue = Tcl_ObjSetVar2(interp, objv[1], NULL, tcol, TCL_LEAVE_ERR_MSG);
        Tcl_DecrRefCount(tcol);
        if (ovalue)
            Tcl_SetObjResult(interp, ovalue);
        else
            status = TCL_ERROR;
    } else if (tcol != ovalue)
        Tcl_DecrRefCount(tcol); /* We allocated it so free it */

    return status;
}

critcl::cproc tarray::column::reverse {Tcl_Interp* interp Tcl_Obj* tcol} ok {
    thdr_t *thdr;
    TCL_RESULT status;

    if (Tcl_IsShared(tcol))
        tcol = Tcl_DuplicateObj(tcol);

    if ((status = tcol_convert(interp, tcol)) != TCL_OK)
        return status;

    thdr = TARRAYHDR(tcol);
    if (thdr_shared(thdr)) {
        thdr = thdr_clone_reversed(interp, thdr, 0);
        if (thdr == NULL)
            status = TCL_ERROR;
        else {
            tcol = tcol_new(thdr);
        }
    } else {
        thdr_reverse(thdr);
        Tcl_InvalidateStringRep(tcol);
    }
    
    if (status == TCL_OK)
        Tcl_SetObjResult(interp, tcol);
    
    return status;
}
    
critcl::cproc tarray::column::vreverse {Tcl_Interp* interp Tcl_Obj* ovar} ok {
    Tcl_Obj *ovalue;
    Tcl_Obj *tcol;
    thdr_t *thdr;
    TCL_RESULT status;

    ovalue = Tcl_ObjGetVar2(interp, ovar, NULL, TCL_LEAVE_ERR_MSG);
    if (ovalue == NULL)
        return TCL_ERROR;

    tcol = Tcl_IsShared(ovalue) ? Tcl_DuplicateObj(ovalue) : ovalue;

    if ((status = tcol_convert(interp, tcol)) != TCL_OK)
        return status;

    thdr = TARRAYHDR(tcol);
    if (thdr_shared(thdr)) {
        thdr = thdr_clone_reversed(interp, thdr, 0);
        if (thdr == NULL)
            status = TCL_ERROR;
        else {
            tcol = tcol_new(thdr);
        }
    } else {
        thdr_reverse(thdr);
        Tcl_InvalidateStringRep(tcol);
    }
    
    if (status == TCL_OK) {
        /* Even if we had not duplicated the value in the variable, we
         * still need to store it back so that traces are triggered. Also,
         * do not want to rely ObjSetVar2 behaviour w.r.t to Tcl_Obj with
         * ref count 0 on error (currently it frees iff ref == 0) so
         * do a Incr/Decr
         */
        Tcl_IncrRefCount(tcol);
        ovalue = Tcl_ObjSetVar2(interp, ovar, NULL, tcol, TCL_LEAVE_ERR_MSG);
        Tcl_DecrRefCount(tcol);
        if (ovalue)
            Tcl_SetObjResult(interp, ovalue);
        else
            status = TCL_ERROR;
    } else if (tcol != ovalue)
        Tcl_DecrRefCount(tcol); /* We allocated it so free it */

    return status;
}


critcl::cproc tarray::grid::create {Tcl_Interp* interp Tcl_Obj* objP} ok {
    Tcl_Obj **tcols;
    thdr_t *thdrP;
    int i;
    int status;
    
    if (objP->typePtr != &g_ta_type) {
        if ((status = tcol_convert(interp, objP) != TCL_OK))
            return TCL_OK;
    }            

    thdrP = TARRAYHDR(objP);
    if (thdrP->type != TA_OBJ)
        return ta_bad_type_error(interp, thdrP);

    tcols = THDRELEMPTR(thdrP, Tcl_Obj *, 0);
    for (i = 0; i < thdrP->used; ++i, ++tcols) {
        if ((status = tcol_convert(interp, *tcols)) != TCL_OK)
            return TCL_ERROR;
    }

    Tcl_SetObjResult(interp, objP);
    return TCL_OK;
}

critcl::ccommand tarray::grid::fill {} {
    int i, tuple_width;
    Tcl_Obj **tcols;
    Tcl_Obj *gridObj;
    int we_allocated_gridobj;
    int status;

    if (objc != 4 && objc != 5) {
	Tcl_WrongNumArgs(interp, 1, objv, "GRID VALUELIST LOW ?HIGH?");
	return TCL_ERROR;
    }

    gridObj = objv[1];
    if (Tcl_IsShared(gridObj)) {
        gridObj = Tcl_DuplicateObj(gridObj);
        we_allocated_gridobj = 1;
    } else
        we_allocated_gridobj = 0;

    status = TGridFillFromObjs(interp, objv[3], objv[objc == 5 ? 4 : 3],
                               gridObj, objv[2]);

    if (status == TCL_OK)
        Tcl_SetObjResult(interp, gridObj);
    else {
        if (we_allocated_gridobj)
            Tcl_DecrRefCount(gridObj);
    }

    return status;
}

package provide tarray 0.1

