#
# Copyright (c) 2012-2015, Ashok P. Nadkarni
# All rights reserved.
#
# See the file LICENSE for license
#

proc win32_target {} {
    switch -glob -- [critcl::targetconfig] {
        win32-* -
        mingw* { return 1 }
        default { return 0 }
    }
}

################################################################
# Set up configuration options for the package
array set build_opts {}

# Enable compiling of unsupported functions
set build_opts(unsupported) 1

# Figure out whether parallelized operations are to be enabled.
# On Windows, parallelized operations are enabled via native Win32 calls.
# Other platforms depend on the presence of libdispatch.
if {[win32_target]} {
    set build_opts(mt_enable) 1
    set build_opts(use_libdispatch) 0
} else {
    if {[critcl::check {
        #include <dispatch/dispatch.h>
    }]} {
        set build_opts(mt_enable) 1
        set build_opts(use_libdispatch) 1
    } else {
        set build_opts(mt_enable) 0
        set build_opts(use_libdispatch) 0
    }
}


################################################################
# Standard critcl meta information

package require critcl 3.1
critcl::buildrequirement {
    package require critcl::class
}

critcl::license "Ashok P. Nadkarni"
critcl::summary "Tcl Typed Array Extension"
critcl::description {
    Implements the tarray::column and tarray::table commands providing 
    accessed to typed array values. This extension is targeted towards
    Tcl applications dealing with a large number of data items.
}

critcl::clean_cache
critcl::tcl 8.6

################################################################
# Compiler/platform specific flags
if {[string match "*-gcc" [critcl::targetconfig]] ||
    [string match "linux-*-\\*" [critcl::targetconfig]] ||
    [string match  "mingw*" [critcl::targetconfig]]} {
    # Flags required for gcc
    critcl::cflags -std=gnu99 -Winline
}

if {[win32_target]} {
   # Need XP at least
   critcl::cflags -D_WIN32_WINNT=0x0500
}

critcl::csources bitarray.c column.c errors.c parseargs.c \
    table.c tafold.c tajoin.c taloop.c \
    tamath.c tarandom.c tarbc.c tarray.c tasearch.c tasort.c tastring.c \
    timsort.c timsort_r.c pcg_basic.c \
    rbcStubLib.c

if {$build_opts(unsupported)} {
    critcl::csources unsupported.c
    critcl::ccommand tarray::unsupported::dump ta_dump_cmd

}
critcl::tsources tabulate.tcl tarray.tcl taprint.tcl tarbc.tcl dbimport.tcl taversion.tcl
critcl::cheaders tarray.h tamath.h bitarray.h timsort.h timsort-impl.h pcg_basic.h rbcDecls.h

critcl::ccode {
#include "tarray.h"
#include <math.h>
#include "pcg_basic.h"
}

if {$build_opts(mt_enable)} {

    if {! $build_opts(use_libdispatch)} {
        critcl::csources mt.c
    }

    critcl::cflags -DTA_MT_ENABLE
}

critcl::ccommand tarray::unsupported::config {} {
    const char *vname;
    int *pval;	 
    if (objc < 2 || objc > 3) {
        Tcl_WrongNumArgs(interp, 1, objv, "CONFIGVAR ?VALUE?");
        return TCL_ERROR;
    }

    vname = Tcl_GetString(objv[1]);
    if (ta_strequal(vname, "experiment"))
        pval = &ta_experiment;
    else if (ta_strequal(vname, "full_validation"))
        pval = &ta_full_validation;
#ifdef TA_MT_ENABLE
    else if (ta_strequal(vname, "sort_mt_threshold"))
        pval = &ta_sort_mt_threshold;
    else if (ta_strequal(vname, "sort_mt_enable_any"))
        pval = &ta_sort_mt_enable_any;
    else if (ta_strequal(vname, "search_mt_threshold"))
        pval = &ta_search_mt_threshold;
    else if (ta_strequal(vname, "fill_mt_threshold"))
        pval = &ta_fill_mt_threshold;
    else if (ta_strequal(vname, "minmax_mt_threshold"))
        pval = &ta_minmax_mt_threshold;
    else if (ta_strequal(vname, "fold_mt_threshold"))
        pval = &ta_fold_mt_threshold;
    else if (ta_strequal(vname, "math_mt_threshold"))
        pval = &ta_math_mt_threshold;
#endif
    else {
        Tcl_SetResult(interp, "Invalid config setting name.", TCL_STATIC);
        return TCL_ERROR;
    }

    if (objc == 3) {
        if (Tcl_GetIntFromObj(interp, objv[2], pval) != TCL_OK)
        return TCL_ERROR;
    }
    Tcl_SetObjResult(interp, Tcl_NewIntObj(*pval));
    return TCL_OK;
}

if {$build_opts(use_libdispatch)} {
    critcl::clibraries -ldispatch
    critcl::cflags -DTA_USE_LIBDISPATCH
}


################################################################
# Type conversions

# WARNING: do not use this where there are multiple parameters to avoid
# shimmering crashes
critcl::argtype TColObjPtr {
    if (tcol_convert(interp, @@) != TCL_OK)
        return TCL_ERROR;
    @A = @@;
}

# WARNING: do not use this where there are multiple parameters to avoid
# shimmering crashes
critcl::argtype TableObjPtr {
    if (table_convert(interp, @@) != TCL_OK)
        return TCL_ERROR;
    @A = @@;
}

################################################################
# Common functions

critcl::ccode {
    typedef Tcl_Obj *TColObjPtr;
    typedef Tcl_Obj *TableObjPtr;

}

################################################################
# Initialization

critcl::cinit {
    ta_real_init(interp);
} {
}

critcl::cproc tarray::unsupported::compiler_info {Tcl_Interp* interp} ok {
    Tcl_Obj *objs[6];

    /* Return a keyed list */
    
    objs[0] = Tcl_NewStringObj("compiler", -1);
#if defined(_MSC_VER)
    objs[1] = Tcl_ObjPrintf("vc++ %u", _MSC_VER);
#elif defined(__GNUC__)
    objs[1] = Tcl_NewStringObj("gcc" __VERSION__, -1);
#else
    objs[1] = Tcl_NewStringObj("unknown", -1);
#endif

    objs[2] = Tcl_NewStringObj("opts", -1);

    objs[3] = Tcl_NewListObj(0, NULL);
#ifdef TA_MT_ENABLE
    Tcl_ListObjAppendElement(NULL, objs[3], Tcl_NewStringObj("mt_enabled", -1));
#endif
#if TA_ENABLE_ASSERT
    Tcl_ListObjAppendElement(NULL, objs[3], Tcl_NewStringObj("asserts_enabled", -1));
#endif

    /* Which Tcl did we build against ? (As opposed to run time) */
    objs[4] = Tcl_NewStringObj("tcl_headers", -1);
    objs[5] = Tcl_NewStringObj(TCL_PATCH_LEVEL, -1);

     Tcl_SetObjResult(interp, Tcl_NewListObj(6, objs));
     return TCL_OK;
}

critcl::cdata tarray::unsupported::critcl_info [critcl::showconfig]
# Commented out because will not work when building from TEA
#critcl::cdata tarray::unsupported::hg_id       [exec hg identify]

critcl::cproc tarray::unsupported::mt_split {Tcl_Interp* interp int tatype int first int count int min_hint int nsizes} ok {
#ifdef TA_MT_ENABLE
    int sizes[16];
    Tcl_Obj *ores;
    int i, split_count;
    if (nsizes > ARRAYSIZE(sizes)) {
        Tcl_SetResult(interp, "Invalid array size", TCL_STATIC);
        return TCL_ERROR;
    }
    split_count = thdr_calc_mt_split_ex(tatype, first, count, min_hint, nsizes, sizes);
    ores = Tcl_NewListObj(nsizes, NULL);
    for (i = 0; i < split_count; ++i)
        Tcl_ListObjAppendElement(interp, ores, Tcl_NewIntObj(sizes[i]));
    Tcl_SetObjResult(interp, ores);
    return TCL_OK;
#else
    Tcl_SetResult(interp, "Multithreading not enabled", TCL_STATIC);
    return TCL_ERROR;
#endif
}

critcl::class::define ::tarray::xrng {
    include pcg_basic.h
    support {
        ta_value_t xget_bounded_random(ta_rng_t *rng, ta_value_t *lbound, ta_value_t *ubound)
        {
            ta_value_t tav;
                
            TA_ASSERT(lbound->type == ubound->type);
            TA_ASSERT(lbound->type != TA_BOOLEAN); /* Does not support bounds */
            switch (lbound->type) {
            case TA_BYTE:
                tav.ucval = pcg32_boundedrand_r(&rng->rng[0],   
                                                ubound->ucval - lbound->ucval);
                tav.ucval += lbound->ucval;
                break;
            case TA_INT:
                tav.ival = pcg32_boundedrand_r(&rng->rng[0], 
                                               ubound->ival - lbound->ival);
                tav.ival += lbound->ival;
                break;
            case TA_UINT:
                tav.uival = pcg32_boundedrand_r(&rng->rng[0], 
                                                ubound->uival - lbound->uival);
                tav.uival += lbound->uival;
                break;
            case TA_WIDE:
                tav.wval = pcg32x2_boundedrand_r(rng->rng,
                                                 ubound->wval - lbound->wval);
                tav.wval += lbound->wval;
                break;
            case TA_DOUBLE:
                tav.dval = pcgdouble_boundedrand_r(rng->rng,
                                                   ubound->dval - lbound->dval);
                tav.dval += lbound->dval;
                break;
            default:
                ta_type_panic(lbound->type);
                break;
            }
            tav.type = lbound->type;
            return tav;
        }
    }
        
    insvariable ta_rng_t rng {} {
        instance->rng.nrefs = 1; /* Does not really matter */
    }
    insvariable {unsigned char} rtype
    insvariable {unsigned char} bounded {} { instance->bounded = 0; }
    insvariable ta_value_t lbound
    insvariable ta_value_t ubound
    constructor {
        if (objc < 1 || objc > 3) {
	    Tcl_AppendResult (interp, "wrong # args: should be \"rng\" new|create TYPE ?LOWBOUND ?HIGHBOUND??", NULL);
            goto error;
        }
        if (ta_parse_type(interp, objv[0], &instance->rtype) != TCL_OK)
            goto error;
        switch (instance->rtype) {
        case TA_BOOLEAN: case TA_BYTE: case TA_INT:
        case TA_UINT: case TA_WIDE: case TA_DOUBLE:
            break;
        default:
            ta_invalid_op_for_type(interp, instance->rtype);
            goto error;
        }
        tcol_random_init(&instance->rng);
        /* Note TA_BOOLEAN do not obey bounds */
        if (objc > 1 && instance->rtype != TA_BOOLEAN) {
            instance->bounded = 1;
            if (ta_value_from_obj(interp, objv[1], instance->rtype, &instance->lbound) != TCL_OK)
                goto error;
            if (objc > 2) {
                if (ta_value_from_obj(interp, objv[2], instance->rtype, &instance->ubound) != TCL_OK)
                    goto error;
            }
            if (ta_rng_fixup_bounds(interp,
                                    &instance->lbound, &instance->ubound,
                                    objc <= 2) != TCL_OK)
                goto error;
        } else if (instance->rtype == TA_BYTE) {
            instance->bounded = 1;
            instance->lbound.type = instance->ubound.type = TA_BYTE;
            instance->lbound.ucval = 0;
            instance->ubound.ucval = 255;
        }
    }
    method_introspection

    method seed proc {Tcl_Obj* SEED1 Tcl_Obj* SEED2} ok {
        Tcl_WideInt seed1;
        Tcl_WideInt seed2;
        TCL_RESULT res;
        if ((res = Tcl_GetWideIntFromObj(interp, SEED1, &seed1)) != TCL_OK ||
            (res = Tcl_GetWideIntFromObj(interp, SEED2, &seed2)) != TCL_OK)
            return res;
        pcg32_srandom_r(&instance->rng.rng[0], seed1, 0xf0f0f0f0);
        pcg32_srandom_r(&instance->rng.rng[1], seed2, 0x0f0f0f0f);
        return TCL_OK;
    }                                            

    method get command {?COUNT? ?LOWER UPPER?} {
        int count;
        int i, bounded;
        Tcl_Obj *ores = NULL;   /* Just to silence bogus gcc uninitialized use warnings */
        ta_value_t lbound, ubound;
        
        count = 1;
        bounded = instance->bounded;
        if (bounded) {
            lbound = instance->lbound;
            ubound = instance->ubound;
        }
        if (objc > 2) {
            if (Tcl_GetIntFromObj(interp, objv[2], &count) != TCL_OK)
                return TCL_ERROR;
            if (count < 0)
                return ta_negative_count_error(interp, count);
            if (objc > 3) {
                if (objc != 5)
                    return ta_invalid_argcount(interp);
                if (instance->rtype == TA_BOOLEAN) {
                    /* Booleans do not support bounds */
                    return ta_invalid_op_for_type(interp, instance->rtype);
                }
                if (ta_value_from_obj(interp, objv[3],
                                      instance->rtype, &lbound) != TCL_OK ||
                    ta_value_from_obj(interp, objv[4],
                                      instance->rtype, &ubound) != TCL_OK ||
                    ta_rng_fixup_bounds(interp, &lbound, &ubound, 0) != TCL_OK)
                    return TCL_ERROR;
                bounded = 1;
            }
        }

        if (count == 0)
            return TCL_OK;

        if (count > 1)
            ores = Tcl_NewListObj(count, NULL);
        if (bounded) {
            for (i = 0; i < count; ++i) {
                ta_value_t tav;
                tav = xget_bounded_random(&instance->rng, &lbound, &ubound);
                if (count == 1) {
                    ores = ta_value_to_obj(&tav);
                    break;
                }
                Tcl_ListObjAppendElement(interp, ores, ta_value_to_obj(&tav));
            }
        } else {
            /* Unbounded */
            TA_ASSERT(instance->rtype != TA_BYTE);
            for (i = 0; i < count; ++i) {
                Tcl_Obj *o = NULL; /* Init just to silence gcc's bogus warnings */
                switch (instance->rtype) {
                case TA_BOOLEAN:
                    o = Tcl_NewIntObj(pcgbool_random_r(&instance->rng.rng[0]));
                    break;
                case TA_INT:
                    o = Tcl_NewIntObj(pcg32_random_r(&instance->rng.rng[0]));
                    break;
                case TA_UINT:
                    o = Tcl_NewWideIntObj(pcg32_random_r(&instance->rng.rng[0]));
                    break;
                case TA_WIDE:
                    o = Tcl_NewWideIntObj(pcg32x2_random_r(instance->rng.rng));
                    break;
                case TA_DOUBLE:
                    o = Tcl_NewDoubleObj(pcgdouble_random_r(instance->rng.rng));
                    break;
                default:
                    ta_type_panic(instance->rtype);
                    break;
                }
                if (count == 1) {
                    ores = o;
                    break;
                }
                Tcl_ListObjAppendElement(interp, ores, o);
            }
        }
        Tcl_SetObjResult(interp, ores);
        return TCL_OK;
    }

    method bounded proc {Tcl_Obj* olower Tcl_Obj* oupper} ok {
        ta_value_t lbound, ubound;
        ta_value_t tav;
        if (instance->rtype == TA_BOOLEAN) {
            /* Booleans do not support bounds */
            return ta_invalid_op_for_type(interp, instance->rtype);
        }
        if (ta_value_from_obj(interp, olower,
                              instance->rtype,&lbound) != TCL_OK ||
            ta_value_from_obj(interp, oupper,
                              instance->rtype,&ubound) != TCL_OK ||
            ta_rng_fixup_bounds(interp, &lbound, &ubound, 0) != TCL_OK)
            return TCL_ERROR;
        tav = xget_bounded_random(&instance->rng, &lbound, &ubound);
        Tcl_SetObjResult(interp, ta_value_to_obj(&tav));
        return TCL_OK;
    }
}

critcl::ccommand tarray::rbc::init_stubs ta_rbc_init_stubs_cmd 
critcl::ccommand tarray::parseargs parseargs_cmd

package provide tarray [source [file join [file dirname [info script]] taversion.tcl]]

critcl::load

#
# Local Variables:
#  compile-command: "envset x64 && tclsh build.tcl extension -config ../src/tarray.cfg -keep -target win32-dev64"
# End:
