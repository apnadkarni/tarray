#ifndef TARRAY_H
#define TARRAY_H

#include <limits.h>
#include <stdlib.h>

/* If building out of twapi pool, use its settings */
#if defined(TWAPI_ENABLE_ASSERT) && !defined(TARRAY_ENABLE_ASSERT)
#define TARRAY_ENABLE_ASSERT TWAPI_ENABLE_ASSERT
#endif

#if TARRAY_ENABLE_ASSERT
#  if TARRAY_ENABLE_ASSERT == 1
#    define TARRAY_ASSERT(bool_) (void)( (bool_) || (Tcl_Panic("Assertion (%s) failed at line %d in file %s.", #bool_, __LINE__, __FILE__), 0) )
#  elif TARRAY_ENABLE_ASSERT == 2
#    define TARRAY_ASSERT(bool_) (void)( (bool_) || (DebugOutput("Assertion (" #bool_ ") failed at line " MAKESTRINGLITERAL2(__LINE__) " in file " __FILE__ "\n"), 0) )
#  elif TARRAY_ENABLE_ASSERT == 3
#    define TARRAY_ASSERT(bool_) do { if (! (bool_)) { __asm int 3 } } while (0)
#  else
#    error Invalid value for TARRAY_ENABLE_ASSERT
#  endif
#else
#define TARRAY_ASSERT(bool_) ((void) 0)
#endif

typedef int TCL_RESULT;

/* Must match gTArrayTypeTokens definition in tarray.c ! */
#define TARRAY_BOOLEAN 0
#define TARRAY_UINT 1
#define TARRAY_INT 2
#define TARRAY_WIDE 3
#define TARRAY_DOUBLE 4
#define TARRAY_BYTE 5
#define TARRAY_OBJ 6

typedef struct TArrayValue_s {
    unsigned char type;
    union {
        int          bval : 1;
        unsigned int uival;
        int          ival;
        Tcl_WideInt  wval;
        double       dval;
        unsigned char ucval;
        Tcl_Obj *     oval;
    };
} TArrayValue;

typedef Tcl_Obj *TArrayObjPtr;

extern const char *gTArrayTypeTokens[];

/* How many slots to allocate by default */
#define TARRAY_DEFAULT_NSLOTS 1000

#define TARRAY_MAX_ELEM_SIZE (sizeof(double) > sizeof(int) ? (sizeof(double) > sizeof(void*) ? sizeof(double) : sizeof(void*)) : sizeof(int))
#define TARRAY_MAX_COUNT (1 + (int)(((size_t)UINT_MAX - sizeof(TArrayHdr))/TARRAY_MAX_ELEM_SIZE))

typedef union TArrayHdr_s {
    void *pointer_aligner;
    double double_aligner;
    struct {
        int nrefs;              /* Ref count when shared between Tcl_Objs */
        int allocated;
        int used;
        unsigned char type;
        unsigned char elem_bits; /* Size of element in bits */
    };
} TArrayHdr;
#define TAHDRELEMPTR(thdr_, type_, index_) ((index_) + (type_ *)(sizeof(TArrayHdr) + (char *) (thdr_)))
#define TAHDRELEMUSEDBYTES(thdr_) ((((thdr_)->used * (thdr_)->elem_bits) + CHAR_BIT-1) / CHAR_BIT)

#define TARRAYDATA(optr_)  ((optr_)->internalRep.ptrAndLongRep.ptr)
#define TARRAYHDR(optr_) ((TArrayHdr *)TARRAYDATA(optr_))
#define TARRAYTYPE(optr_) (TARRAYHDR(optr_)->type)
#define TARRAYELEMSLOTS(optr_) ((TARRAYHDR(optr_))->allocated)
#define TARRAYELEMCOUNT(optr_) ((TARRAYHDR(optr_))->used)
#define TARRAYELEMPTR(optr_, type_, index_) TAHDRELEMPTR(TARRAYHDR(optr_), type_, index_)

/* How much extra slots to allocate when allocating memory. n_ should
 * be number of elements currently.
 */
#define TARRAY_EXTRA(n_)  \
    ((n_) < 10 ? 10 : ((n_) < 100 ? (n_) : ((n_) < 800 ? 100 : ((n_)/8))))

/* Can a TArrayHdr block be modified ? Must be unshared and large enough */
#define TAHDR_SHARED(th_) ((th_)->nrefs > 1)
#define TAHDR_WRITABLE(th_, size_) (TARRAYHDR_SHARED(th_) && (th_)->allocated >= (size_))

extern struct Tcl_ObjType gTArrayType;

#define TAHDR_INCRREF(thdr_) do { (thdr_)->nrefs++; } while (0)
#define TAHDR_DECRREF(thdr_)                                            \
    do {                                                                \
        TArrayHdr *h_ = (thdr_);  /* Temp in case parameter has sideeffects*/ \
        if (--(h_)->nrefs <= 0)                                         \
            TArrayHdrFree(h_);                                          \
    } while (0)

/* Sets a Tcl_Obj's internal rep pointer. Assumes the Tcl_Obj int rep is
   invalid / uninitialized */
#define TARRAY_OBJ_SETREP(obj_, thdr_)                                     \
    do {                                                                \
        TArrayHdr *h_ = (thdr_);  /* Temp in case parameter has sideeffects*/ \
        Tcl_Obj *o_ = (obj_);  /* Temp in case parameter has sideeffects*/ \
        TAHDR_INCRREF(h_); \
        TARRAYHDR(o_) = h_; \
        (o_)->typePtr = &gTArrayType; \
    } while (0)

/* ALLOCATE_ARRAY call should panic on failure to allocate */
#define TARRAY_ALLOCMEM ckalloc
#define TARRAY_FREEMEM(p_) if (p_) ckfree((char *)p_)
#define TARRAY_REALLOCMEM ckrealloc

/*
 * Prototypes - generated by cl
 */

/* Error and panic routines */
void TArrayTypePanic(unsigned char tatype);
void TArraySharedPanic(const char *where);
void TArrayTooSmallPanic(TArrayHdr *thdrP, const char *where);
TCL_RESULT TArrayBadArgError(Tcl_Interp *interp, const char *optname);
TCL_RESULT TArrayBadSearchOpError(Tcl_Interp *interp, enum TArraySearchSwitches op);


void TArrayIncrObjRefs(TArrayHdr *thdrP,int first,int count);
void TArrayDecrObjRefs(TArrayHdr *thdrP,int first,int count);
void TArrayHdrFree(TArrayHdr *thdrP);
TCL_RESULT TArrayVerifyType(struct Tcl_Interp *interp,struct Tcl_Obj *objP);
TCL_RESULT TArrayValueFromObj(Tcl_Interp *interp, Tcl_Obj *objP,
                                             unsigned char tatype, TArrayValue *tavP);
void TArrayHdrFill(Tcl_Interp *interp, TArrayHdr *thdrP,
                                   const TArrayValue *tavP, int pos, int count);
void TArrayHdrTupleFill(Tcl_Interp *interp,
                        TArrayHdr *const thdrs[],
                        TArrayValue const values[] ,
                        int nthdrs, int pos, int count);
TCL_RESULT TArrayTupleFill(Tcl_Interp *interp,
                           Tcl_Obj *lowObj, Tcl_Obj *highObj,
                           Tcl_Obj *const taObjs[], Tcl_Obj *const valueObjs[],
                           int tuple_width);

Tcl_Obj * TArrayNewObj(TArrayHdr *thdrP);
TCL_RESULT TArraySetFromObjs(struct Tcl_Interp *interp,TArrayHdr *thdrP,int first,int nelems,struct Tcl_Obj *const *elems );
int TArrayCalcSize(unsigned char tatype,int count);
TArrayHdr *TArrayRealloc(TArrayHdr *oldP,int new_count);
TArrayHdr *TArrayAlloc(unsigned char tatype, int count);
TArrayHdr *TArrayAllocAndInit(struct Tcl_Interp *interp,unsigned char tatype,int nelems,struct Tcl_Obj *const *elems ,int init_size);
int TArraySet(struct Tcl_Interp *interp,TArrayHdr *dstP,int dst_first,TArrayHdr *srcP,int src_first,int count);
TArrayHdr *TArrayClone(TArrayHdr *srcP, int init_size);
struct Tcl_Obj *TArrayIndex(struct Tcl_Interp *interp,TArrayHdr *thdrP,Tcl_Obj *indexObj);
TArrayHdr *TArrayConvertToIndices(struct Tcl_Interp *interp,struct Tcl_Obj *objP);
TArrayHdr *TArrayGetValues(struct Tcl_Interp *interp,TArrayHdr *srcP,TArrayHdr *indicesP);
int TArrayNumSetBits(TArrayHdr *thdrP);
TCL_RESULT TArraySetRange(Tcl_Interp *interp, TArrayHdr *dstP, int dst_first, int count, Tcl_Obj *objP);
TCL_RESULT IndexToInt(Tcl_Interp *interp, Tcl_Obj *objP, int *indexP, int end_value);
TCL_RESULT RationalizeRangeIndices(Tcl_Interp *interp, TArrayHdr *thdrP, Tcl_Obj *lowObj, Tcl_Obj *highObj, int *lowP, int *countP);


/* Search and sort routines */
int TArrayCompareObjs(Tcl_Obj *oaP, Tcl_Obj *obP, int ignorecase);

void bitarray_set(unsigned char *ucP, int offset, int count, int ival);
void bitarray_copy(const unsigned char *src_org, int src_offset,
                                  int src_len, unsigned char *dst_org, int dst_offset);

void tarray_qsort_r(void *a, size_t n, size_t es, void *thunk, int (*cmp)(void *, const void *, const void *));
int intcmp(const void *a, const void *b);
int intcmprev(const void *a, const void *b);
int uintcmp(const void *a, const void *b);
int uintcmprev(const void *a, const void *b);
int widecmp(const void *a, const void *b);
int widecmprev(const void *a, const void *b);
int doublecmp(const void *a, const void *b);
int doublecmprev(const void *a, const void *b);
int bytecmp(const void *a, const void *b);
int bytecmprev(const void *a, const void *b);
int tclobjcmp(const void *a, const void *b);
int tclobjcmprev(const void *a, const void *b);

int intcmpindexed(void *, const void *a, const void *b);
int intcmpindexedrev(void *, const void *a, const void *b);
int uintcmpindexed(void *, const void *a, const void *b);
int uintcmpindexedrev(void *, const void *a, const void *b);
int widecmpindexed(void *, const void *a, const void *b);
int widecmpindexedrev(void *, const void *a, const void *b);
int doublecmpindexed(void *, const void *a, const void *b);
int doublecmpindexedrev(void *, const void *a, const void *b);
int bytecmpindexed(void *, const void *a, const void *b);
int bytecmpindexedrev(void *, const void *a, const void *b);
int tclobjcmpindexed(void *, const void *a, const void *b);
int tclobjcmpindexedrev(void *, const void *a, const void *b);


/* Tcl script level commands */
TCL_RESULT TArray_SearchObjCmd(ClientData clientdata, Tcl_Interp *interp,
                                      int objc, Tcl_Obj *const objv[]);

#endif
