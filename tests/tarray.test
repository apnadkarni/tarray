package require Tcl 8.5
package require platform
package require tcltest
namespace eval tarray::test {
    set topdir [file dirname [file dirname [file normalize [info script]]]]
    set pkgdir [file join $topdir build lib tarray]
    if {[file exists [file join $pkgdir pkgIndex.tcl]]} {
        set auto_path [linsert $auto_path 0 $pkgdir]
    }

    proc validate {ta} {
        if {[llength $ta] != 3 ||
            [lindex $ta 0] ne "tarray" ||
            [lindex $ta 1] ni {any byte boolean double int uint wide}} {
            error "Value [string range $ta 0 40]... is not a tarray"
        }
    }
    tcltest::customMatch tarray tarray::test::tarray_compare
    proc tarray_compare {a b} {
        validate $a
        validate $b

        lassign $a _ atype avals
        lassign $b _ btype bvals
        if {$atype ne $btype} {
            error "Tarray types $atype and $btype do not match"
        }

        if {[llength $avals] != [llength $bvals]} {
            return 0
        }

        switch -exact -- $atype {
            boolean {
                foreach aval $avals bval $bvals {
                    if {!$aval != !$bval} { return 0 }
                }
            }
            any {
                foreach aval $avals bval $bvals {
                    if {$aval ne $bval} { return 0 }
                }
            }
            default {
                foreach aval $avals bval $bvals {
                    if {$aval != $bval} { return 0 }
                }
            }
        }

        return 1
    }


    ################################################################
    # Define standard data used in tests

    #
    # Common list with known values that can be used for multiple types
    # used to initialize various tarrays in tests
    variable known
    set known [list ]
    set i -1
    time {lappend known [incr i]} 256; # 0-255 -> So suitable for byte type

    #
    # Define the valid values
    variable counts {0 1 2 7 8 15 16 17 31 32 33 63 64 65 1001 32567 32568 100000}
    variable good
    foreach count $counts {
        # Booleans. Note the unaligned patterns are important
        foreach pat {0 1 01 10 011 010 1001 1100 11000011 101010101} {
            lappend good(boolean) [lrepeat $count {*}[split $pat ""]]
        }
        # [time] is nothing but a repeat mechanism

        # doubles
        set i 0.5
        set l [list 0.0]
        time {lappend l $i; set i [expr {$i * -1.0001}]} $count
        lappend good(double) $l
        lappend good(any) $l
        
        # ints
        set i 0
        set l {}
        time {lappend l [expr {$i & 1 ? -$i : $i}]; incr i} $count
        lappend good(int) $l
        lappend good(any) $l

        # uints
        set i -1
        set l {}
        time {lappend l [incr i]} $count
        lappend good(uint) $l
        lappend good(any) $l

        # Byte
        set i -1
        set l {}
        time {lappend l [expr {[incr i] & 0xff}]} $count
        lappend good(byte) $l
        lappend good(any) $l
        
        # wides
        set i 0
        set l {}
        time {lappend l [expr {$i & 1 ? -($i*$i) : ($i*$i)}]; incr i} $count
        lappend good(wide) $l
        lappend good(any) $l
    }

    # Differently formatted valid values
    lappend good(boolean) {0 1 5 -5 -1 1.0 1e0 -1e2 true false TRUE FALSE t f T F y n Y N yes no YES NO on off ON OFF}
    lappend good(int) {0 1 -1 0xdef -0xabc  012 -077}
    lappend good(uint) {0 1 0xdef  0xffffffff 0x80000000 012}
    lappend good(byte) {0 1 0xff 0x80 012}
    lappend good(wide) {0 1 -1 0xdef -0xabc  0x1ffffffff -0x1ffffffff 012 -077 }
    lappend good(double) {0 1 0.0 1.1 0x2 -0x3 011 -022 -1.1 1e10 1e-10 2.2e20 -3.3e-30 Inf -Inf}

    #
    # Invalid values. Note Unlike the good array, the bad array holds
    # a single list of bad values as they have to be checked one at a time
    # Note booleans are anything accepted by Tcl_GetBooleanFromObj which
    # is different from [string is boolean] which does not accept arbitrary
    # numerics.
    variable bad
    set bad(boolean) {abc}
    set bad(byte) {abc -1 256 1.0 1e0 true}
    set bad(int) {abc 1e1 0x1ffffffff false}
    set bad(uint) {abc -1 0x1ffffffff 1.0 1e0 true}
    set bad(wide) {abc 18446744073709551616 false}
    set bad(double) {abc true}

    ################################################################
    # Utility functions

    proc rep {type values} {
        return [list tarray $type $values]
    }
}

package require tarray

namespace eval tarray::test {
    namespace import ::tcltest::test

    # Note two general types of tests - via a temp variable and directly
    # from the create return value. The difference is that in the
    # former case the value ref count is > 1, and the object needs to
    # be dup'ed while in the latter the ref count is 1 and the called
    # command can directly use it

    ################################################################
    # tarray creation

    # Tests for creating empty tarrays
    foreach type {any boolean byte double int uint wide} {
        test column-create-$type-1.0 {
            Test creation of empty column
        } -body {
            tarray::column create $type
        } -result [rep $type {}]
        test column-create-$type-1.1 {
            Test creation of empty column with preallocation
        } -body {
            tarray::column create $type {} 1000
        } -result [rep $type {}]
    }

    #
    # Tests for creating various lengths with valid values in standard format
    foreach {type values} [array get good] {
        set num -1
        foreach value $values {
            test column-create-$type-2.[incr num] {
                Test creation of column with initializer
            } -body {
                tarray::column create $type $value
            } -result [rep $type $value] -match tarray
        }
    }

    #
    # Tests for invalid types
    foreach {type values} [array get bad] {
        set num -1
        foreach value $values {
            test column-create-$type-3.[incr num] {
                Test invalid values raise error in tarray creation
            } -body {
                tarray::column create $type [list $value]
            } -result * -match glob -returnCodes error
        }
    }
    
    ################################################################
    # Deletion of tarray elements

    foreach type {boolean any byte double int uint wide} {
        test column-delete-$type-1.0 {
            Test deletion of first element (shared tclobj)
        } -body {
            set ta [tarray::column create $type $known]
            tarray::column delete $ta 0
        } -result [rep $type [lrange $known 1 end]] -match tarray

        test column-delete-$type-1.1 {
            Test deletion of first element (unshared tclobj)
        } -body {
            tarray::column delete [tarray::column create $type $known] 0
        } -result [rep $type [lrange $known 1 end]] -match tarray

        test column-delete-$type-2.0 {
            Test deletion of last element (shared tclobj)
        } -body {
            set ta [tarray::column create $type $known]
            tarray::column delete $ta [expr {[llength $known]-1}]
        } -result [rep $type [lrange $known 0 end-1]] -match tarray

        test column-delete-$type-2.1 {
            Test deletion of last element (unshared tclobj)
        } -body {
            tarray::column delete [tarray::column create $type $known] [expr {[llength $known]-1}]
        } -result [rep $type [lrange $known 0 end-1]] -match tarray

        test column-delete-$type-3.0 {
            Test deletion of end element (shared tclobj)
        } -body {
            set ta [tarray::column create $type $known]
            tarray::column delete $ta end
        } -result [rep $type [lrange $known 0 end-1]] -match tarray

        test column-delete-$type-3.1 {
            Test deletion of end element (unshared tclobj)
        } -body {
            tarray::column delete [tarray::column create $type $known] end
        } -result [rep $type [lrange $known 0 end-1]] -match tarray

        set n -1
        foreach i {1 7 8 9 31 32 33 63 64 65 254} {
            test column-delete-$type-4.[incr n] {
                Test deletion of intermediate element (shared tclobj)
            } -body {
                set ta [tarray::column create $type $known]
                tarray::column delete $ta $i
            } -result [rep $type [concat [lrange $known 0 $i-1] [lrange $known $i+1 end]]] -match tarray

            test column-delete-$type-4.[incr n] {
                Test deletion of intermediate element (unshared tclobj)
            } -body {
                tarray::column delete [tarray::column create $type $known] $i
            } -result [rep $type [concat [lrange $known 0 $i-1] [lrange $known $i+1 end]]] -match tarray
        }

        test column-delete-$type-5.0 {
            Test deletion of out-of-range index
        } -body {
            tarray::column delete [tarray::column create $type $known] [expr {[llength $known] + 10}]
        } -result [rep $type $known] -match tarray

        test column-delete-$type-5.1 {
            Test deletion of out-of-range index (+1)
        } -body {
            tarray::column delete [tarray::column create $type $known] [llength $known]
        } -result [rep $type $known] -match tarray

        test column-delete-$type-5.2 {
            Test deletion of negative index
        } -body {
            tarray::column delete [tarray::column create $type $known] -1
        } -result [rep $type $known] -match tarray

        test column-delete-$type-5.3 {
            Test deletion of invalid syntax index
        } -body {
            tarray::column delete [tarray::column create $type $known] nonintsyntax
        } -returnCodes error -match glob -result *

        test column-delete-$type-6.0 {
            Test deletion of element from single element column (shared)
        } -body {
            set ta [tarray::column create $type [lrange $known 0 0]]
            tarray::column delete $ta 0
        } -result [rep $type {}] -match tarray

        test column-delete-$type-6.1 {
            Test deletion of element from single element column (unshared)
        } -body {
            tarray::column delete [tarray::column create $type [lrange $known 0 0]] end
        } -result [rep $type {}] -match tarray

        test column-delete-$type-7.0 {
            Test attempt to delete element from empty column (shared)
        } -body {
            set ta [tarray::column create $type {}]
            tarray::column delete $ta 0
        } -result [rep $type {}] -match tarray

        test column-delete-$type-7.1 {
            Test deletion of invalid index from empty column (unshared)
        } -body {
            tarray::column delete [tarray::column create $type {}] -1
        } -result [rep $type {}] -match tarray
    }
}
